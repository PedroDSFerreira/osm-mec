# -*- coding: utf-8 -*-
from collections import OrderedDict
from decimal import Decimal
from operator import attrgetter

import six
from pyangbind.lib.base import PybindBase
from pyangbind.lib.yangtypes import (ReferenceType, RestrictedClassType,
                                     RestrictedPrecisionDecimalType,
                                     TypedListType, YANGBinary, YANGBool,
                                     YANGDynClass, YANGListType)

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
    import builtins as __builtin__

    long = int
elif six.PY2:
    import __builtin__


class yc_logical_node_requirement_details_mec_app_descriptor__mec_appd_virtual_compute_logical_node_reqs_logical_node_requirement_details(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/logical-node-reqs/logical-node-requirement-details. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements. This could include the number of CPU cores on this logical node, a memory configuration specific to a logical node (e.g. such as available in the Linux kernel via the libnuma library) or a requirement related to the association of an I/O device with the logical node.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "logical-node-requirement-details"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "virtual-compute",
                "logical-node-reqs",
                "logical-node-requirement-details",
            ]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/virtual_compute/logical_node_reqs/logical_node_requirement_details/key (string)

        YANG Description: Key in the key-value pair
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/virtual_compute/logical_node_reqs/logical_node_requirement_details/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key in the key-value pair
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/virtual_compute/logical_node_reqs/logical_node_requirement_details/value (union)

        YANG Description: Value in the key-value pair
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/virtual_compute/logical_node_reqs/logical_node_requirement_details/value (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value in the key-value pair
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    YANGBool,
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["-2147483648..2147483647"]},
                        int_size=32,
                    ),
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["0..4294967295"]},
                        int_size=32,
                    ),
                    six.text_type,
                ],
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="union",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with union""",
                    "defined-type": "mec-app-descriptor:union",
                    "generated-type": """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='union', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_logical_node_reqs_mec_app_descriptor__mec_appd_virtual_compute_logical_node_reqs(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/logical-node-reqs. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: The logical node requirements
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__logical_node_requirement_details",
    )

    _yang_name = "logical-node-reqs"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__logical_node_requirement_details = YANGDynClass(
            base=YANGListType(
                "key",
                yc_logical_node_requirement_details_mec_app_descriptor__mec_appd_virtual_compute_logical_node_reqs_logical_node_requirement_details,
                yang_name="logical-node-requirement-details",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="logical-node-requirement-details",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-compute", "logical-node-reqs"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/virtual_compute/logical_node_reqs/id (string)

        YANG Description: Identifier of the logical node requirement
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/virtual_compute/logical_node_reqs/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Identifier of the logical node requirement
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_logical_node_requirement_details(self):
        """
        Getter method for logical_node_requirement_details, mapped from YANG variable /mec_appd/virtual_compute/logical_node_reqs/logical_node_requirement_details (list)

        YANG Description: The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements. This could include the number of CPU cores on this logical node, a memory configuration specific to a logical node (e.g. such as available in the Linux kernel via the libnuma library) or a requirement related to the association of an I/O device with the logical node.
        """
        return self.__logical_node_requirement_details

    def _set_logical_node_requirement_details(self, v, load=False):
        """
        Setter method for logical_node_requirement_details, mapped from YANG variable /mec_appd/virtual_compute/logical_node_reqs/logical_node_requirement_details (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_logical_node_requirement_details is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_logical_node_requirement_details() directly.

        YANG Description: The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements. This could include the number of CPU cores on this logical node, a memory configuration specific to a logical node (e.g. such as available in the Linux kernel via the libnuma library) or a requirement related to the association of an I/O device with the logical node.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_logical_node_requirement_details_mec_app_descriptor__mec_appd_virtual_compute_logical_node_reqs_logical_node_requirement_details,
                    yang_name="logical-node-requirement-details",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="logical-node-requirement-details",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """logical_node_requirement_details must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_logical_node_requirement_details_mec_app_descriptor__mec_appd_virtual_compute_logical_node_reqs_logical_node_requirement_details, yang_name="logical-node-requirement-details", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="logical-node-requirement-details", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__logical_node_requirement_details = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_logical_node_requirement_details(self):
        self.__logical_node_requirement_details = YANGDynClass(
            base=YANGListType(
                "key",
                yc_logical_node_requirement_details_mec_app_descriptor__mec_appd_virtual_compute_logical_node_reqs_logical_node_requirement_details,
                yang_name="logical-node-requirement-details",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="logical-node-requirement-details",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    logical_node_requirement_details = __builtin__.property(
        _get_logical_node_requirement_details, _set_logical_node_requirement_details
    )

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("logical_node_requirement_details", logical_node_requirement_details),
        ]
    )


class yc_target_performance_parameters_mec_app_descriptor__mec_appd_virtual_compute_request_additional_capabilities_target_performance_parameters(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/request-additional-capabilities/target-performance-parameters. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Specifies especific attributes, dependent on the requested additional capability type.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "target-performance-parameters"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "virtual-compute",
                "request-additional-capabilities",
                "target-performance-parameters",
            ]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/target_performance_parameters/key (string)

        YANG Description: Key in the key-value pair
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/target_performance_parameters/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key in the key-value pair
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/target_performance_parameters/value (union)

        YANG Description: Value in the key-value pair
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/target_performance_parameters/value (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value in the key-value pair
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    YANGBool,
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["-2147483648..2147483647"]},
                        int_size=32,
                    ),
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["0..4294967295"]},
                        int_size=32,
                    ),
                    six.text_type,
                ],
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="union",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with union""",
                    "defined-type": "mec-app-descriptor:union",
                    "generated-type": """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='union', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_request_additional_capabilities_mec_app_descriptor__mec_appd_virtual_compute_request_additional_capabilities(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/request-additional-capabilities. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Specifies requirements for additional capabilities. These may be for a range of purposes. One example is acceleration related capabilities
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__name",
        "__support_mandatory",
        "__min_requested_additional_capability_version",
        "__preferred_requested_additional_capability_version",
        "__target_performance_parameters",
    )

    _yang_name = "request-additional-capabilities"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__support_mandatory = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="support-mandatory",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )
        self.__min_requested_additional_capability_version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="min-requested-additional-capability-version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__preferred_requested_additional_capability_version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="preferred-requested-additional-capability-version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__target_performance_parameters = YANGDynClass(
            base=YANGListType(
                "key",
                yc_target_performance_parameters_mec_app_descriptor__mec_appd_virtual_compute_request_additional_capabilities_target_performance_parameters,
                yang_name="target-performance-parameters",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="target-performance-parameters",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-compute", "request-additional-capabilities"]

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/name (string)

        YANG Description: Specifies a requested additional capability for the VDU
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: Specifies a requested additional capability for the VDU
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_support_mandatory(self):
        """
        Getter method for support_mandatory, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/support_mandatory (boolean)

        YANG Description: Indicates whether the requested additional capability is mandatory for successful operation
        """
        return self.__support_mandatory

    def _set_support_mandatory(self, v, load=False):
        """
        Setter method for support_mandatory, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/support_mandatory (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_support_mandatory is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_support_mandatory() directly.

        YANG Description: Indicates whether the requested additional capability is mandatory for successful operation
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                is_leaf=True,
                yang_name="support-mandatory",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """support_mandatory must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__support_mandatory = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_support_mandatory(self):
        self.__support_mandatory = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="support-mandatory",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    def _get_min_requested_additional_capability_version(self):
        """
        Getter method for min_requested_additional_capability_version, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/min_requested_additional_capability_version (string)

        YANG Description: Specifies the minimum version of the requested additional capability
        """
        return self.__min_requested_additional_capability_version

    def _set_min_requested_additional_capability_version(self, v, load=False):
        """
        Setter method for min_requested_additional_capability_version, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/min_requested_additional_capability_version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_min_requested_additional_capability_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_min_requested_additional_capability_version() directly.

        YANG Description: Specifies the minimum version of the requested additional capability
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="min-requested-additional-capability-version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """min_requested_additional_capability_version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-requested-additional-capability-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__min_requested_additional_capability_version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_min_requested_additional_capability_version(self):
        self.__min_requested_additional_capability_version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="min-requested-additional-capability-version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_preferred_requested_additional_capability_version(self):
        """
        Getter method for preferred_requested_additional_capability_version, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/preferred_requested_additional_capability_version (string)

        YANG Description: Specifies the preferred version of the requested additional capability
        """
        return self.__preferred_requested_additional_capability_version

    def _set_preferred_requested_additional_capability_version(self, v, load=False):
        """
        Setter method for preferred_requested_additional_capability_version, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/preferred_requested_additional_capability_version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_preferred_requested_additional_capability_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_preferred_requested_additional_capability_version() directly.

        YANG Description: Specifies the preferred version of the requested additional capability
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="preferred-requested-additional-capability-version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """preferred_requested_additional_capability_version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferred-requested-additional-capability-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__preferred_requested_additional_capability_version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_preferred_requested_additional_capability_version(self):
        self.__preferred_requested_additional_capability_version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="preferred-requested-additional-capability-version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_target_performance_parameters(self):
        """
        Getter method for target_performance_parameters, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/target_performance_parameters (list)

        YANG Description: Specifies especific attributes, dependent on the requested additional capability type.
        """
        return self.__target_performance_parameters

    def _set_target_performance_parameters(self, v, load=False):
        """
        Setter method for target_performance_parameters, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities/target_performance_parameters (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_target_performance_parameters is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_target_performance_parameters() directly.

        YANG Description: Specifies especific attributes, dependent on the requested additional capability type.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_target_performance_parameters_mec_app_descriptor__mec_appd_virtual_compute_request_additional_capabilities_target_performance_parameters,
                    yang_name="target-performance-parameters",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="target-performance-parameters",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """target_performance_parameters must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_target_performance_parameters_mec_app_descriptor__mec_appd_virtual_compute_request_additional_capabilities_target_performance_parameters, yang_name="target-performance-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="target-performance-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__target_performance_parameters = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_target_performance_parameters(self):
        self.__target_performance_parameters = YANGDynClass(
            base=YANGListType(
                "key",
                yc_target_performance_parameters_mec_app_descriptor__mec_appd_virtual_compute_request_additional_capabilities_target_performance_parameters,
                yang_name="target-performance-parameters",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="target-performance-parameters",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    name = __builtin__.property(_get_name, _set_name)
    support_mandatory = __builtin__.property(
        _get_support_mandatory, _set_support_mandatory
    )
    min_requested_additional_capability_version = __builtin__.property(
        _get_min_requested_additional_capability_version,
        _set_min_requested_additional_capability_version,
    )
    preferred_requested_additional_capability_version = __builtin__.property(
        _get_preferred_requested_additional_capability_version,
        _set_preferred_requested_additional_capability_version,
    )
    target_performance_parameters = __builtin__.property(
        _get_target_performance_parameters, _set_target_performance_parameters
    )

    _pyangbind_elements = OrderedDict(
        [
            ("name", name),
            ("support_mandatory", support_mandatory),
            (
                "min_requested_additional_capability_version",
                min_requested_additional_capability_version,
            ),
            (
                "preferred_requested_additional_capability_version",
                preferred_requested_additional_capability_version,
            ),
            ("target_performance_parameters", target_performance_parameters),
        ]
    )


class yc_compute_requirements_mec_app_descriptor__mec_appd_virtual_compute_compute_requirements(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/compute-requirements. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Specifies compute requirements
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "compute-requirements"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-compute", "compute-requirements"]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/virtual_compute/compute_requirements/key (string)

        YANG Description: Key in the key-value pair
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/virtual_compute/compute_requirements/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key in the key-value pair
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/virtual_compute/compute_requirements/value (union)

        YANG Description: Value in the key-value pair
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/virtual_compute/compute_requirements/value (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value in the key-value pair
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    YANGBool,
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["-2147483648..2147483647"]},
                        int_size=32,
                    ),
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["0..4294967295"]},
                        int_size=32,
                    ),
                    six.text_type,
                ],
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="union",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with union""",
                    "defined-type": "mec-app-descriptor:union",
                    "generated-type": """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='union', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_vdu_mem_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_memory_vdu_mem_requirements(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/virtual-memory/vdu-mem-requirements. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Array of key-value pair requirements on the memory for the VDU.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "vdu-mem-requirements"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "virtual-compute",
                "virtual-memory",
                "vdu-mem-requirements",
            ]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/vdu_mem_requirements/key (string)

        YANG Description: Key in the key-value pair
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/vdu_mem_requirements/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key in the key-value pair
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/vdu_mem_requirements/value (union)

        YANG Description: Value in the key-value pair
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/vdu_mem_requirements/value (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value in the key-value pair
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    YANGBool,
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["-2147483648..2147483647"]},
                        int_size=32,
                    ),
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["0..4294967295"]},
                        int_size=32,
                    ),
                    six.text_type,
                ],
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="union",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with union""",
                    "defined-type": "mec-app-descriptor:union",
                    "generated-type": """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='union', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_virtual_memory_mec_app_descriptor__mec_appd_virtual_compute_virtual_memory(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/virtual-memory. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: The virtual memory of the virtualised compute
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__mem_size",
        "__mem_oversubscription_policy",
        "__vdu_mem_requirements",
        "__numa_enabled",
    )

    _yang_name = "virtual-memory"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__mem_size = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="mem-size",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )
        self.__mem_oversubscription_policy = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="mem-oversubscription-policy",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__vdu_mem_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vdu_mem_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_memory_vdu_mem_requirements,
                yang_name="vdu-mem-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="vdu-mem-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__numa_enabled = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="numa-enabled",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-compute", "virtual-memory"]

    def _get_mem_size(self):
        """
        Getter method for mem_size, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/mem_size (uint64)

        YANG Description: Amount of virtual Memory (e.g. in MB)
        """
        return self.__mem_size

    def _set_mem_size(self, v, load=False):
        """
        Setter method for mem_size, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/mem_size (uint64)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_mem_size is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_mem_size() directly.

        YANG Description: Amount of virtual Memory (e.g. in MB)
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..18446744073709551615"]},
                    int_size=64,
                ),
                is_leaf=True,
                yang_name="mem-size",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint64",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """mem_size must be of a type compatible with uint64""",
                    "defined-type": "uint64",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mem-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
                }
            )

        self.__mem_size = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_mem_size(self):
        self.__mem_size = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="mem-size",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )

    def _get_mem_oversubscription_policy(self):
        """
        Getter method for mem_oversubscription_policy, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/mem_oversubscription_policy (string)

        YANG Description: The memory core oversubscription policy in terms of virtual memory to physical memory on the platform
        """
        return self.__mem_oversubscription_policy

    def _set_mem_oversubscription_policy(self, v, load=False):
        """
        Setter method for mem_oversubscription_policy, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/mem_oversubscription_policy (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_mem_oversubscription_policy is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_mem_oversubscription_policy() directly.

        YANG Description: The memory core oversubscription policy in terms of virtual memory to physical memory on the platform
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="mem-oversubscription-policy",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """mem_oversubscription_policy must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mem-oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__mem_oversubscription_policy = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_mem_oversubscription_policy(self):
        self.__mem_oversubscription_policy = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="mem-oversubscription-policy",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_vdu_mem_requirements(self):
        """
        Getter method for vdu_mem_requirements, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/vdu_mem_requirements (list)

        YANG Description: Array of key-value pair requirements on the memory for the VDU.
        """
        return self.__vdu_mem_requirements

    def _set_vdu_mem_requirements(self, v, load=False):
        """
        Setter method for vdu_mem_requirements, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/vdu_mem_requirements (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_vdu_mem_requirements is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_vdu_mem_requirements() directly.

        YANG Description: Array of key-value pair requirements on the memory for the VDU.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_vdu_mem_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_memory_vdu_mem_requirements,
                    yang_name="vdu-mem-requirements",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="vdu-mem-requirements",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """vdu_mem_requirements must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_vdu_mem_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_memory_vdu_mem_requirements, yang_name="vdu-mem-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-mem-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__vdu_mem_requirements = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_vdu_mem_requirements(self):
        self.__vdu_mem_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vdu_mem_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_memory_vdu_mem_requirements,
                yang_name="vdu-mem-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="vdu-mem-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_numa_enabled(self):
        """
        Getter method for numa_enabled, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/numa_enabled (boolean)

        YANG Description: It specifies the memory allocation to be cognisant of the relevant process/core allocation. The cardinality can be 0 during the allocation request, if no particular value is requested.
        """
        return self.__numa_enabled

    def _set_numa_enabled(self, v, load=False):
        """
        Setter method for numa_enabled, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory/numa_enabled (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_numa_enabled is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_numa_enabled() directly.

        YANG Description: It specifies the memory allocation to be cognisant of the relevant process/core allocation. The cardinality can be 0 during the allocation request, if no particular value is requested.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                is_leaf=True,
                yang_name="numa-enabled",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """numa_enabled must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__numa_enabled = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_numa_enabled(self):
        self.__numa_enabled = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="numa-enabled",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    mem_size = __builtin__.property(_get_mem_size, _set_mem_size)
    mem_oversubscription_policy = __builtin__.property(
        _get_mem_oversubscription_policy, _set_mem_oversubscription_policy
    )
    vdu_mem_requirements = __builtin__.property(
        _get_vdu_mem_requirements, _set_vdu_mem_requirements
    )
    numa_enabled = __builtin__.property(_get_numa_enabled, _set_numa_enabled)

    _pyangbind_elements = OrderedDict(
        [
            ("mem_size", mem_size),
            ("mem_oversubscription_policy", mem_oversubscription_policy),
            ("vdu_mem_requirements", vdu_mem_requirements),
            ("numa_enabled", numa_enabled),
        ]
    )


class yc_vdu_cpu_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_vdu_cpu_requirements(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/virtual-cpu/vdu-cpu-requirements. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Array of key-value pair requirements on the Compute (CPU) for the VDU.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "vdu-cpu-requirements"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "virtual-compute",
                "virtual-cpu",
                "vdu-cpu-requirements",
            ]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/vdu_cpu_requirements/key (string)

        YANG Description: Key in the key-value pair
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/vdu_cpu_requirements/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key in the key-value pair
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/vdu_cpu_requirements/value (union)

        YANG Description: Value in the key-value pair
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/vdu_cpu_requirements/value (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value in the key-value pair
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    YANGBool,
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["-2147483648..2147483647"]},
                        int_size=32,
                    ),
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["0..4294967295"]},
                        int_size=32,
                    ),
                    six.text_type,
                ],
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="union",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with union""",
                    "defined-type": "mec-app-descriptor:union",
                    "generated-type": """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='union', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_pinning_rule_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_cpu_pinning_pinning_rule(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/virtual-cpu/cpu-pinning/pinning-rule. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: List of rules that should be considered during the allocation of the virtual CPUs to logical CPUs in case of 'STATIC' virtualCpuPinningPolicy
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "pinning-rule"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "virtual-compute",
                "virtual-cpu",
                "cpu-pinning",
                "pinning-rule",
            ]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule/key (string)

        YANG Description: Key in the key-value pair
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key in the key-value pair
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule/value (union)

        YANG Description: Value in the key-value pair
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule/value (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value in the key-value pair
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    YANGBool,
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["-2147483648..2147483647"]},
                        int_size=32,
                    ),
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["0..4294967295"]},
                        int_size=32,
                    ),
                    six.text_type,
                ],
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="union",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with union""",
                    "defined-type": "mec-app-descriptor:union",
                    "generated-type": """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='union', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_cpu_pinning_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_cpu_pinning(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/virtual-cpu/cpu-pinning. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: The virtual CPU pinning configuration for the virtualised compute resource.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__pinning_policy",
        "__pinning_rule",
    )

    _yang_name = "cpu-pinning"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__pinning_policy = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"STATIC": {}, "DYNAMIC": {}},
            ),
            is_leaf=True,
            yang_name="pinning-policy",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__pinning_rule = YANGDynClass(
            base=YANGListType(
                "key",
                yc_pinning_rule_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_cpu_pinning_pinning_rule,
                yang_name="pinning-rule",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="pinning-rule",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-compute", "virtual-cpu", "cpu-pinning"]

    def _get_pinning_policy(self):
        """
        Getter method for pinning_policy, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_pinning/pinning_policy (enumeration)

        YANG Description: Indicates the policy for CPU pinning
        """
        return self.__pinning_policy

    def _set_pinning_policy(self, v, load=False):
        """
        Setter method for pinning_policy, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_pinning/pinning_policy (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_pinning_policy is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_pinning_policy() directly.

        YANG Description: Indicates the policy for CPU pinning
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={"STATIC": {}, "DYNAMIC": {}},
                ),
                is_leaf=True,
                yang_name="pinning-policy",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """pinning_policy must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="pinning-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__pinning_policy = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_pinning_policy(self):
        self.__pinning_policy = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"STATIC": {}, "DYNAMIC": {}},
            ),
            is_leaf=True,
            yang_name="pinning-policy",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_pinning_rule(self):
        """
        Getter method for pinning_rule, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule (list)

        YANG Description: List of rules that should be considered during the allocation of the virtual CPUs to logical CPUs in case of 'STATIC' virtualCpuPinningPolicy
        """
        return self.__pinning_rule

    def _set_pinning_rule(self, v, load=False):
        """
        Setter method for pinning_rule, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_pinning_rule is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_pinning_rule() directly.

        YANG Description: List of rules that should be considered during the allocation of the virtual CPUs to logical CPUs in case of 'STATIC' virtualCpuPinningPolicy
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_pinning_rule_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_cpu_pinning_pinning_rule,
                    yang_name="pinning-rule",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="pinning-rule",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """pinning_rule must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_pinning_rule_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_cpu_pinning_pinning_rule, yang_name="pinning-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="pinning-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__pinning_rule = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_pinning_rule(self):
        self.__pinning_rule = YANGDynClass(
            base=YANGListType(
                "key",
                yc_pinning_rule_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_cpu_pinning_pinning_rule,
                yang_name="pinning-rule",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="pinning-rule",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    pinning_policy = __builtin__.property(_get_pinning_policy, _set_pinning_policy)
    pinning_rule = __builtin__.property(_get_pinning_rule, _set_pinning_rule)

    _pyangbind_elements = OrderedDict(
        [
            ("pinning_policy", pinning_policy),
            ("pinning_rule", pinning_rule),
        ]
    )


class yc_virtual_cpu_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/virtual-cpu. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: The virtual CPU(s) of the virtualised compute
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__architecture",
        "__cpu_count",
        "__cpu_clock",
        "__cpu_oversubscription_policy",
        "__vdu_cpu_requirements",
        "__cpu_pinning",
    )

    _yang_name = "virtual-cpu"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__architecture = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="architecture",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__cpu_count = YANGDynClass(
            base=RestrictedClassType(
                base_type=int, restriction_dict={"range": ["0..65535"]}, int_size=16
            ),
            is_leaf=True,
            yang_name="cpu-count",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint16",
            is_config=True,
        )
        self.__cpu_clock = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="cpu-clock",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )
        self.__cpu_oversubscription_policy = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="cpu-oversubscription-policy",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__vdu_cpu_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vdu_cpu_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_vdu_cpu_requirements,
                yang_name="vdu-cpu-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="vdu-cpu-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__cpu_pinning = YANGDynClass(
            base=yc_cpu_pinning_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_cpu_pinning,
            is_container="container",
            yang_name="cpu-pinning",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-compute", "virtual-cpu"]

    def _get_architecture(self):
        """
        Getter method for architecture, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/architecture (string)

        YANG Description: CPU architecture type. Examples are x86, ARM
        """
        return self.__architecture

    def _set_architecture(self, v, load=False):
        """
        Setter method for architecture, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/architecture (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_architecture is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_architecture() directly.

        YANG Description: CPU architecture type. Examples are x86, ARM
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="architecture",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """architecture must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="architecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__architecture = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_architecture(self):
        self.__architecture = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="architecture",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_cpu_count(self):
        """
        Getter method for cpu_count, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_count (uint16)

        YANG Description: Number of virtual CPUs
        """
        return self.__cpu_count

    def _set_cpu_count(self, v, load=False):
        """
        Setter method for cpu_count, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_count (uint16)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_cpu_count is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_cpu_count() directly.

        YANG Description: Number of virtual CPUs
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=int, restriction_dict={"range": ["0..65535"]}, int_size=16
                ),
                is_leaf=True,
                yang_name="cpu-count",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint16",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """cpu_count must be of a type compatible with uint16""",
                    "defined-type": "uint16",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="cpu-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint16', is_config=True)""",
                }
            )

        self.__cpu_count = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_cpu_count(self):
        self.__cpu_count = YANGDynClass(
            base=RestrictedClassType(
                base_type=int, restriction_dict={"range": ["0..65535"]}, int_size=16
            ),
            is_leaf=True,
            yang_name="cpu-count",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint16",
            is_config=True,
        )

    def _get_cpu_clock(self):
        """
        Getter method for cpu_clock, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_clock (uint64)

        YANG Description: Minimum virtual CPU clock rate (e.g. in MHz)
        """
        return self.__cpu_clock

    def _set_cpu_clock(self, v, load=False):
        """
        Setter method for cpu_clock, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_clock (uint64)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_cpu_clock is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_cpu_clock() directly.

        YANG Description: Minimum virtual CPU clock rate (e.g. in MHz)
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..18446744073709551615"]},
                    int_size=64,
                ),
                is_leaf=True,
                yang_name="cpu-clock",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint64",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """cpu_clock must be of a type compatible with uint64""",
                    "defined-type": "uint64",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
                }
            )

        self.__cpu_clock = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_cpu_clock(self):
        self.__cpu_clock = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="cpu-clock",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )

    def _get_cpu_oversubscription_policy(self):
        """
        Getter method for cpu_oversubscription_policy, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_oversubscription_policy (string)

        YANG Description: The CPU core oversubscription policy e.g. the relation of virtual CPU cores to physical CPU cores/threads
        """
        return self.__cpu_oversubscription_policy

    def _set_cpu_oversubscription_policy(self, v, load=False):
        """
        Setter method for cpu_oversubscription_policy, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_oversubscription_policy (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_cpu_oversubscription_policy is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_cpu_oversubscription_policy() directly.

        YANG Description: The CPU core oversubscription policy e.g. the relation of virtual CPU cores to physical CPU cores/threads
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="cpu-oversubscription-policy",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """cpu_oversubscription_policy must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu-oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__cpu_oversubscription_policy = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_cpu_oversubscription_policy(self):
        self.__cpu_oversubscription_policy = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="cpu-oversubscription-policy",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_vdu_cpu_requirements(self):
        """
        Getter method for vdu_cpu_requirements, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/vdu_cpu_requirements (list)

        YANG Description: Array of key-value pair requirements on the Compute (CPU) for the VDU.
        """
        return self.__vdu_cpu_requirements

    def _set_vdu_cpu_requirements(self, v, load=False):
        """
        Setter method for vdu_cpu_requirements, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/vdu_cpu_requirements (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_vdu_cpu_requirements is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_vdu_cpu_requirements() directly.

        YANG Description: Array of key-value pair requirements on the Compute (CPU) for the VDU.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_vdu_cpu_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_vdu_cpu_requirements,
                    yang_name="vdu-cpu-requirements",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="vdu-cpu-requirements",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """vdu_cpu_requirements must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_vdu_cpu_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_vdu_cpu_requirements, yang_name="vdu-cpu-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-cpu-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__vdu_cpu_requirements = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_vdu_cpu_requirements(self):
        self.__vdu_cpu_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vdu_cpu_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_vdu_cpu_requirements,
                yang_name="vdu-cpu-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="vdu-cpu-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_cpu_pinning(self):
        """
        Getter method for cpu_pinning, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_pinning (container)

        YANG Description: The virtual CPU pinning configuration for the virtualised compute resource.
        """
        return self.__cpu_pinning

    def _set_cpu_pinning(self, v, load=False):
        """
        Setter method for cpu_pinning, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu/cpu_pinning (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_cpu_pinning is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_cpu_pinning() directly.

        YANG Description: The virtual CPU pinning configuration for the virtualised compute resource.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_cpu_pinning_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_cpu_pinning,
                is_container="container",
                yang_name="cpu-pinning",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """cpu_pinning must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_cpu_pinning_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_cpu_pinning, is_container='container', yang_name="cpu-pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__cpu_pinning = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_cpu_pinning(self):
        self.__cpu_pinning = YANGDynClass(
            base=yc_cpu_pinning_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu_cpu_pinning,
            is_container="container",
            yang_name="cpu-pinning",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    architecture = __builtin__.property(_get_architecture, _set_architecture)
    cpu_count = __builtin__.property(_get_cpu_count, _set_cpu_count)
    cpu_clock = __builtin__.property(_get_cpu_clock, _set_cpu_clock)
    cpu_oversubscription_policy = __builtin__.property(
        _get_cpu_oversubscription_policy, _set_cpu_oversubscription_policy
    )
    vdu_cpu_requirements = __builtin__.property(
        _get_vdu_cpu_requirements, _set_vdu_cpu_requirements
    )
    cpu_pinning = __builtin__.property(_get_cpu_pinning, _set_cpu_pinning)

    _pyangbind_elements = OrderedDict(
        [
            ("architecture", architecture),
            ("cpu_count", cpu_count),
            ("cpu_clock", cpu_clock),
            ("cpu_oversubscription_policy", cpu_oversubscription_policy),
            ("vdu_cpu_requirements", vdu_cpu_requirements),
            ("cpu_pinning", cpu_pinning),
        ]
    )


class yc_vdu_storage_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_disk_vdu_storage_requirements(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/virtual-disk/vdu-storage-requirements. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: An array of key-value pairs that articulate the storage deployment requirements
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "vdu-storage-requirements"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "virtual-compute",
                "virtual-disk",
                "vdu-storage-requirements",
            ]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/vdu_storage_requirements/key (string)

        YANG Description: Key in the key-value pair
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/vdu_storage_requirements/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key in the key-value pair
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/vdu_storage_requirements/value (union)

        YANG Description: Value in the key-value pair
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/vdu_storage_requirements/value (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value in the key-value pair
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    YANGBool,
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["-2147483648..2147483647"]},
                        int_size=32,
                    ),
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["0..4294967295"]},
                        int_size=32,
                    ),
                    six.text_type,
                ],
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="union",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with union""",
                    "defined-type": "mec-app-descriptor:union",
                    "generated-type": """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='union', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_virtual_disk_mec_app_descriptor__mec_appd_virtual_compute_virtual_disk(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute/virtual-disk. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: The local or ephemeral disk(s) of the virtualised compute
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__size_of_storage",
        "__vdu_storage_requirements",
        "__rdma_enabled",
        "__sw_image_id",
    )

    _yang_name = "virtual-disk"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__size_of_storage = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="size-of-storage",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )
        self.__vdu_storage_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vdu_storage_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_disk_vdu_storage_requirements,
                yang_name="vdu-storage-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="vdu-storage-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__rdma_enabled = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="rdma-enabled",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )
        self.__sw_image_id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="sw-image-id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-compute", "virtual-disk"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/id (string)

        YANG Description: Unique identifier of the virtual disk in the VNFD
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier of the virtual disk in the VNFD
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_size_of_storage(self):
        """
        Getter method for size_of_storage, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/size_of_storage (uint64)

        YANG Description: Size of virtualised storage resource in GB.
        """
        return self.__size_of_storage

    def _set_size_of_storage(self, v, load=False):
        """
        Setter method for size_of_storage, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/size_of_storage (uint64)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_size_of_storage is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_size_of_storage() directly.

        YANG Description: Size of virtualised storage resource in GB.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..18446744073709551615"]},
                    int_size=64,
                ),
                is_leaf=True,
                yang_name="size-of-storage",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint64",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """size_of_storage must be of a type compatible with uint64""",
                    "defined-type": "uint64",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
                }
            )

        self.__size_of_storage = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_size_of_storage(self):
        self.__size_of_storage = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="size-of-storage",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )

    def _get_vdu_storage_requirements(self):
        """
        Getter method for vdu_storage_requirements, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/vdu_storage_requirements (list)

        YANG Description: An array of key-value pairs that articulate the storage deployment requirements
        """
        return self.__vdu_storage_requirements

    def _set_vdu_storage_requirements(self, v, load=False):
        """
        Setter method for vdu_storage_requirements, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/vdu_storage_requirements (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_vdu_storage_requirements is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_vdu_storage_requirements() directly.

        YANG Description: An array of key-value pairs that articulate the storage deployment requirements
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_vdu_storage_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_disk_vdu_storage_requirements,
                    yang_name="vdu-storage-requirements",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="vdu-storage-requirements",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """vdu_storage_requirements must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_vdu_storage_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_disk_vdu_storage_requirements, yang_name="vdu-storage-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-storage-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__vdu_storage_requirements = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_vdu_storage_requirements(self):
        self.__vdu_storage_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vdu_storage_requirements_mec_app_descriptor__mec_appd_virtual_compute_virtual_disk_vdu_storage_requirements,
                yang_name="vdu-storage-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="vdu-storage-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_rdma_enabled(self):
        """
        Getter method for rdma_enabled, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/rdma_enabled (boolean)

        YANG Description: Indicates if the storage support RDMA
        """
        return self.__rdma_enabled

    def _set_rdma_enabled(self, v, load=False):
        """
        Setter method for rdma_enabled, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/rdma_enabled (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_rdma_enabled is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_rdma_enabled() directly.

        YANG Description: Indicates if the storage support RDMA
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                is_leaf=True,
                yang_name="rdma-enabled",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """rdma_enabled must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rdma-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__rdma_enabled = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_rdma_enabled(self):
        self.__rdma_enabled = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="rdma-enabled",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    def _get_sw_image_id(self):
        """
        Getter method for sw_image_id, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/sw_image_id (string)

        YANG Description: References the software image to be loaded on the VirtualStorage resource created based on this VirtualStorageDesc. Shall be absent when used for virtual disks.
        """
        return self.__sw_image_id

    def _set_sw_image_id(self, v, load=False):
        """
        Setter method for sw_image_id, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk/sw_image_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_sw_image_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_sw_image_id() directly.

        YANG Description: References the software image to be loaded on the VirtualStorage resource created based on this VirtualStorageDesc. Shall be absent when used for virtual disks.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="sw-image-id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """sw_image_id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__sw_image_id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_sw_image_id(self):
        self.__sw_image_id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="sw-image-id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    size_of_storage = __builtin__.property(_get_size_of_storage, _set_size_of_storage)
    vdu_storage_requirements = __builtin__.property(
        _get_vdu_storage_requirements, _set_vdu_storage_requirements
    )
    rdma_enabled = __builtin__.property(_get_rdma_enabled, _set_rdma_enabled)
    sw_image_id = __builtin__.property(_get_sw_image_id, _set_sw_image_id)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("size_of_storage", size_of_storage),
            ("vdu_storage_requirements", vdu_storage_requirements),
            ("rdma_enabled", rdma_enabled),
            ("sw_image_id", sw_image_id),
        ]
    )


class yc_virtual_compute_mec_app_descriptor__mec_appd_virtual_compute(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-compute. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes CPU and memory requirements, as well as optional additional requirements, such as disk and acceleration related capabilities, of the virtualisation container used to realize this MEC application.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__logical_node_reqs",
        "__request_additional_capabilities",
        "__compute_requirements",
        "__virtual_memory",
        "__virtual_cpu",
        "__virtual_disk",
    )

    _yang_name = "virtual-compute"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__logical_node_reqs = YANGDynClass(
            base=YANGListType(
                "id",
                yc_logical_node_reqs_mec_app_descriptor__mec_appd_virtual_compute_logical_node_reqs,
                yang_name="logical-node-reqs",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="logical-node-reqs",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__request_additional_capabilities = YANGDynClass(
            base=YANGListType(
                "name",
                yc_request_additional_capabilities_mec_app_descriptor__mec_appd_virtual_compute_request_additional_capabilities,
                yang_name="request-additional-capabilities",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="name",
                extensions=None,
            ),
            is_container="list",
            yang_name="request-additional-capabilities",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__compute_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_compute_requirements_mec_app_descriptor__mec_appd_virtual_compute_compute_requirements,
                yang_name="compute-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="compute-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__virtual_memory = YANGDynClass(
            base=yc_virtual_memory_mec_app_descriptor__mec_appd_virtual_compute_virtual_memory,
            is_container="container",
            yang_name="virtual-memory",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__virtual_cpu = YANGDynClass(
            base=yc_virtual_cpu_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu,
            is_container="container",
            yang_name="virtual-cpu",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__virtual_disk = YANGDynClass(
            base=YANGListType(
                "id",
                yc_virtual_disk_mec_app_descriptor__mec_appd_virtual_compute_virtual_disk,
                yang_name="virtual-disk",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="virtual-disk",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-compute"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/virtual_compute/id (string)

        YANG Description: Unique identifier of this virtual-compute-descriptor in the VNFD
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/virtual_compute/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier of this virtual-compute-descriptor in the VNFD
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_logical_node_reqs(self):
        """
        Getter method for logical_node_reqs, mapped from YANG variable /mec_appd/virtual_compute/logical_node_reqs (list)

        YANG Description: The logical node requirements
        """
        return self.__logical_node_reqs

    def _set_logical_node_reqs(self, v, load=False):
        """
        Setter method for logical_node_reqs, mapped from YANG variable /mec_appd/virtual_compute/logical_node_reqs (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_logical_node_reqs is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_logical_node_reqs() directly.

        YANG Description: The logical node requirements
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_logical_node_reqs_mec_app_descriptor__mec_appd_virtual_compute_logical_node_reqs,
                    yang_name="logical-node-reqs",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="logical-node-reqs",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """logical_node_reqs must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_logical_node_reqs_mec_app_descriptor__mec_appd_virtual_compute_logical_node_reqs, yang_name="logical-node-reqs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="logical-node-reqs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__logical_node_reqs = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_logical_node_reqs(self):
        self.__logical_node_reqs = YANGDynClass(
            base=YANGListType(
                "id",
                yc_logical_node_reqs_mec_app_descriptor__mec_appd_virtual_compute_logical_node_reqs,
                yang_name="logical-node-reqs",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="logical-node-reqs",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_request_additional_capabilities(self):
        """
        Getter method for request_additional_capabilities, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities (list)

        YANG Description: Specifies requirements for additional capabilities. These may be for a range of purposes. One example is acceleration related capabilities
        """
        return self.__request_additional_capabilities

    def _set_request_additional_capabilities(self, v, load=False):
        """
        Setter method for request_additional_capabilities, mapped from YANG variable /mec_appd/virtual_compute/request_additional_capabilities (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_request_additional_capabilities is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_request_additional_capabilities() directly.

        YANG Description: Specifies requirements for additional capabilities. These may be for a range of purposes. One example is acceleration related capabilities
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "name",
                    yc_request_additional_capabilities_mec_app_descriptor__mec_appd_virtual_compute_request_additional_capabilities,
                    yang_name="request-additional-capabilities",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="name",
                    extensions=None,
                ),
                is_container="list",
                yang_name="request-additional-capabilities",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """request_additional_capabilities must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("name",yc_request_additional_capabilities_mec_app_descriptor__mec_appd_virtual_compute_request_additional_capabilities, yang_name="request-additional-capabilities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="request-additional-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__request_additional_capabilities = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_request_additional_capabilities(self):
        self.__request_additional_capabilities = YANGDynClass(
            base=YANGListType(
                "name",
                yc_request_additional_capabilities_mec_app_descriptor__mec_appd_virtual_compute_request_additional_capabilities,
                yang_name="request-additional-capabilities",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="name",
                extensions=None,
            ),
            is_container="list",
            yang_name="request-additional-capabilities",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_compute_requirements(self):
        """
        Getter method for compute_requirements, mapped from YANG variable /mec_appd/virtual_compute/compute_requirements (list)

        YANG Description: Specifies compute requirements
        """
        return self.__compute_requirements

    def _set_compute_requirements(self, v, load=False):
        """
        Setter method for compute_requirements, mapped from YANG variable /mec_appd/virtual_compute/compute_requirements (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_compute_requirements is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_compute_requirements() directly.

        YANG Description: Specifies compute requirements
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_compute_requirements_mec_app_descriptor__mec_appd_virtual_compute_compute_requirements,
                    yang_name="compute-requirements",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="compute-requirements",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """compute_requirements must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_compute_requirements_mec_app_descriptor__mec_appd_virtual_compute_compute_requirements, yang_name="compute-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="compute-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__compute_requirements = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_compute_requirements(self):
        self.__compute_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_compute_requirements_mec_app_descriptor__mec_appd_virtual_compute_compute_requirements,
                yang_name="compute-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="compute-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_virtual_memory(self):
        """
        Getter method for virtual_memory, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory (container)

        YANG Description: The virtual memory of the virtualised compute
        """
        return self.__virtual_memory

    def _set_virtual_memory(self, v, load=False):
        """
        Setter method for virtual_memory, mapped from YANG variable /mec_appd/virtual_compute/virtual_memory (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_virtual_memory is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_virtual_memory() directly.

        YANG Description: The virtual memory of the virtualised compute
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_virtual_memory_mec_app_descriptor__mec_appd_virtual_compute_virtual_memory,
                is_container="container",
                yang_name="virtual-memory",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """virtual_memory must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_virtual_memory_mec_app_descriptor__mec_appd_virtual_compute_virtual_memory, is_container='container', yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__virtual_memory = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_virtual_memory(self):
        self.__virtual_memory = YANGDynClass(
            base=yc_virtual_memory_mec_app_descriptor__mec_appd_virtual_compute_virtual_memory,
            is_container="container",
            yang_name="virtual-memory",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_virtual_cpu(self):
        """
        Getter method for virtual_cpu, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu (container)

        YANG Description: The virtual CPU(s) of the virtualised compute
        """
        return self.__virtual_cpu

    def _set_virtual_cpu(self, v, load=False):
        """
        Setter method for virtual_cpu, mapped from YANG variable /mec_appd/virtual_compute/virtual_cpu (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_virtual_cpu is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_virtual_cpu() directly.

        YANG Description: The virtual CPU(s) of the virtualised compute
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_virtual_cpu_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu,
                is_container="container",
                yang_name="virtual-cpu",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """virtual_cpu must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_virtual_cpu_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu, is_container='container', yang_name="virtual-cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__virtual_cpu = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_virtual_cpu(self):
        self.__virtual_cpu = YANGDynClass(
            base=yc_virtual_cpu_mec_app_descriptor__mec_appd_virtual_compute_virtual_cpu,
            is_container="container",
            yang_name="virtual-cpu",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_virtual_disk(self):
        """
        Getter method for virtual_disk, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk (list)

        YANG Description: The local or ephemeral disk(s) of the virtualised compute
        """
        return self.__virtual_disk

    def _set_virtual_disk(self, v, load=False):
        """
        Setter method for virtual_disk, mapped from YANG variable /mec_appd/virtual_compute/virtual_disk (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_virtual_disk is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_virtual_disk() directly.

        YANG Description: The local or ephemeral disk(s) of the virtualised compute
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_virtual_disk_mec_app_descriptor__mec_appd_virtual_compute_virtual_disk,
                    yang_name="virtual-disk",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="virtual-disk",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """virtual_disk must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_virtual_disk_mec_app_descriptor__mec_appd_virtual_compute_virtual_disk, yang_name="virtual-disk", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__virtual_disk = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_virtual_disk(self):
        self.__virtual_disk = YANGDynClass(
            base=YANGListType(
                "id",
                yc_virtual_disk_mec_app_descriptor__mec_appd_virtual_compute_virtual_disk,
                yang_name="virtual-disk",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="virtual-disk",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    logical_node_reqs = __builtin__.property(
        _get_logical_node_reqs, _set_logical_node_reqs
    )
    request_additional_capabilities = __builtin__.property(
        _get_request_additional_capabilities, _set_request_additional_capabilities
    )
    compute_requirements = __builtin__.property(
        _get_compute_requirements, _set_compute_requirements
    )
    virtual_memory = __builtin__.property(_get_virtual_memory, _set_virtual_memory)
    virtual_cpu = __builtin__.property(_get_virtual_cpu, _set_virtual_cpu)
    virtual_disk = __builtin__.property(_get_virtual_disk, _set_virtual_disk)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("logical_node_reqs", logical_node_reqs),
            ("request_additional_capabilities", request_additional_capabilities),
            ("compute_requirements", compute_requirements),
            ("virtual_memory", virtual_memory),
            ("virtual_cpu", virtual_cpu),
            ("virtual_disk", virtual_disk),
        ]
    )


class yc_sw_image_mec_app_descriptor__mec_appd_sw_image(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/sw-image. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes the descriptors of the software image to be used by the virtualisation container used to realize this MEC application.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__name",
        "__version",
        "__checksum",
        "__container_format",
        "__disk_format",
        "__min_disk",
        "__min_ram",
        "__size",
        "__sw_image",
        "__operating_system",
        "__supported_virtualisation_environment",
    )

    _yang_name = "sw-image"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__checksum = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="checksum",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__container_format = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="container-format",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__disk_format = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="disk-format",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__min_disk = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="min-disk",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )
        self.__min_ram = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="min-ram",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )
        self.__size = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="size",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )
        self.__sw_image = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="sw-image",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__operating_system = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="operating-system",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__supported_virtualisation_environment = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="supported-virtualisation-environment",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "sw-image"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/sw_image/id (string)

        YANG Description: The identifier of this software image.
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/sw_image/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: The identifier of this software image.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/sw_image/name (string)

        YANG Description: The name of this software image.
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/sw_image/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The name of this software image.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/sw_image/version (string)

        YANG Description: The version of this software image.
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/sw_image/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: The version of this software image.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_checksum(self):
        """
        Getter method for checksum, mapped from YANG variable /mec_appd/sw_image/checksum (string)

        YANG Description: The checksum of the software image file.
        """
        return self.__checksum

    def _set_checksum(self, v, load=False):
        """
        Setter method for checksum, mapped from YANG variable /mec_appd/sw_image/checksum (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_checksum is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_checksum() directly.

        YANG Description: The checksum of the software image file.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="checksum",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """checksum must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__checksum = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_checksum(self):
        self.__checksum = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="checksum",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_container_format(self):
        """
        Getter method for container_format, mapped from YANG variable /mec_appd/sw_image/container_format (string)

        YANG Description: The container format describes the container file format in which software image is provided.
        """
        return self.__container_format

    def _set_container_format(self, v, load=False):
        """
        Setter method for container_format, mapped from YANG variable /mec_appd/sw_image/container_format (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_container_format is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_container_format() directly.

        YANG Description: The container format describes the container file format in which software image is provided.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="container-format",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """container_format must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__container_format = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_container_format(self):
        self.__container_format = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="container-format",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_disk_format(self):
        """
        Getter method for disk_format, mapped from YANG variable /mec_appd/sw_image/disk_format (string)

        YANG Description: The disk format of a software image is the format of the underlying disk image.
        """
        return self.__disk_format

    def _set_disk_format(self, v, load=False):
        """
        Setter method for disk_format, mapped from YANG variable /mec_appd/sw_image/disk_format (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_disk_format is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_disk_format() directly.

        YANG Description: The disk format of a software image is the format of the underlying disk image.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="disk-format",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """disk_format must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__disk_format = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_disk_format(self):
        self.__disk_format = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="disk-format",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_min_disk(self):
        """
        Getter method for min_disk, mapped from YANG variable /mec_appd/sw_image/min_disk (uint64)

        YANG Description: The minimal disk size requirement for this software image.
        """
        return self.__min_disk

    def _set_min_disk(self, v, load=False):
        """
        Setter method for min_disk, mapped from YANG variable /mec_appd/sw_image/min_disk (uint64)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_min_disk is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_min_disk() directly.

        YANG Description: The minimal disk size requirement for this software image.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..18446744073709551615"]},
                    int_size=64,
                ),
                is_leaf=True,
                yang_name="min-disk",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint64",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """min_disk must be of a type compatible with uint64""",
                    "defined-type": "uint64",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
                }
            )

        self.__min_disk = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_min_disk(self):
        self.__min_disk = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="min-disk",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )

    def _get_min_ram(self):
        """
        Getter method for min_ram, mapped from YANG variable /mec_appd/sw_image/min_ram (uint64)

        YANG Description: The minimal RAM requirement for this software image.
        """
        return self.__min_ram

    def _set_min_ram(self, v, load=False):
        """
        Setter method for min_ram, mapped from YANG variable /mec_appd/sw_image/min_ram (uint64)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_min_ram is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_min_ram() directly.

        YANG Description: The minimal RAM requirement for this software image.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..18446744073709551615"]},
                    int_size=64,
                ),
                is_leaf=True,
                yang_name="min-ram",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint64",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """min_ram must be of a type compatible with uint64""",
                    "defined-type": "uint64",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
                }
            )

        self.__min_ram = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_min_ram(self):
        self.__min_ram = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="min-ram",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )

    def _get_size(self):
        """
        Getter method for size, mapped from YANG variable /mec_appd/sw_image/size (uint64)

        YANG Description: The size of this software image file.
        """
        return self.__size

    def _set_size(self, v, load=False):
        """
        Setter method for size, mapped from YANG variable /mec_appd/sw_image/size (uint64)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_size is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_size() directly.

        YANG Description: The size of this software image file.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..18446744073709551615"]},
                    int_size=64,
                ),
                is_leaf=True,
                yang_name="size",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint64",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """size must be of a type compatible with uint64""",
                    "defined-type": "uint64",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
                }
            )

        self.__size = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_size(self):
        self.__size = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="size",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )

    def _get_sw_image(self):
        """
        Getter method for sw_image, mapped from YANG variable /mec_appd/sw_image/sw_image (string)

        YANG Description: This is a reference to the actual software image.
        """
        return self.__sw_image

    def _set_sw_image(self, v, load=False):
        """
        Setter method for sw_image, mapped from YANG variable /mec_appd/sw_image/sw_image (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_sw_image is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_sw_image() directly.

        YANG Description: This is a reference to the actual software image.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="sw-image",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """sw_image must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__sw_image = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_sw_image(self):
        self.__sw_image = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="sw-image",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_operating_system(self):
        """
        Getter method for operating_system, mapped from YANG variable /mec_appd/sw_image/operating_system (string)

        YANG Description: Specifies the operating system used in the software image.
        """
        return self.__operating_system

    def _set_operating_system(self, v, load=False):
        """
        Setter method for operating_system, mapped from YANG variable /mec_appd/sw_image/operating_system (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_operating_system is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_operating_system() directly.

        YANG Description: Specifies the operating system used in the software image.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="operating-system",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """operating_system must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__operating_system = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_operating_system(self):
        self.__operating_system = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="operating-system",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_supported_virtualisation_environment(self):
        """
        Getter method for supported_virtualisation_environment, mapped from YANG variable /mec_appd/sw_image/supported_virtualisation_environment (string)

        YANG Description: Specifies the virtualisation environments compatible with this software image.
        """
        return self.__supported_virtualisation_environment

    def _set_supported_virtualisation_environment(self, v, load=False):
        """
        Setter method for supported_virtualisation_environment, mapped from YANG variable /mec_appd/sw_image/supported_virtualisation_environment (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_virtualisation_environment is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_virtualisation_environment() directly.

        YANG Description: Specifies the virtualisation environments compatible with this software image.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="supported-virtualisation-environment",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """supported_virtualisation_environment must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualisation-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__supported_virtualisation_environment = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_supported_virtualisation_environment(self):
        self.__supported_virtualisation_environment = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="supported-virtualisation-environment",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    version = __builtin__.property(_get_version, _set_version)
    checksum = __builtin__.property(_get_checksum, _set_checksum)
    container_format = __builtin__.property(
        _get_container_format, _set_container_format
    )
    disk_format = __builtin__.property(_get_disk_format, _set_disk_format)
    min_disk = __builtin__.property(_get_min_disk, _set_min_disk)
    min_ram = __builtin__.property(_get_min_ram, _set_min_ram)
    size = __builtin__.property(_get_size, _set_size)
    sw_image = __builtin__.property(_get_sw_image, _set_sw_image)
    operating_system = __builtin__.property(
        _get_operating_system, _set_operating_system
    )
    supported_virtualisation_environment = __builtin__.property(
        _get_supported_virtualisation_environment,
        _set_supported_virtualisation_environment,
    )

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("name", name),
            ("version", version),
            ("checksum", checksum),
            ("container_format", container_format),
            ("disk_format", disk_format),
            ("min_disk", min_disk),
            ("min_ram", min_ram),
            ("size", size),
            ("sw_image", sw_image),
            ("operating_system", operating_system),
            (
                "supported_virtualisation_environment",
                supported_virtualisation_environment,
            ),
        ]
    )


class yc_vdu_storage_requirements_mec_app_descriptor__mec_appd_virtual_storage_block_storage_vdu_storage_requirements(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-storage/block-storage/vdu-storage-requirements. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: An array of key-value pairs that articulate the storage deployment requirements
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "vdu-storage-requirements"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "virtual-storage",
                "block-storage",
                "vdu-storage-requirements",
            ]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/virtual_storage/block_storage/vdu_storage_requirements/key (string)

        YANG Description: Key in the key-value pair
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/virtual_storage/block_storage/vdu_storage_requirements/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key in the key-value pair
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                choice=("storage", "block-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/virtual_storage/block_storage/vdu_storage_requirements/value (union)

        YANG Description: Value in the key-value pair
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/virtual_storage/block_storage/vdu_storage_requirements/value (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value in the key-value pair
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    YANGBool,
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["-2147483648..2147483647"]},
                        int_size=32,
                    ),
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["0..4294967295"]},
                        int_size=32,
                    ),
                    six.text_type,
                ],
                is_leaf=True,
                yang_name="value",
                parent=self,
                choice=("storage", "block-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="union",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with union""",
                    "defined-type": "mec-app-descriptor:union",
                    "generated-type": """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="value", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='union', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    __choices__ = {"storage": {"block-storage": ["key", "value"]}}
    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_block_storage_mec_app_descriptor__mec_appd_virtual_storage_block_storage(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-storage/block-storage. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Specifies the details of block storage. Applicable only if typeOfStorage=BLOCK
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__size_of_storage",
        "__vdu_storage_requirements",
        "__rdma_enabled",
        "__sw_image_id",
    )

    _yang_name = "block-storage"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__size_of_storage = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="size-of-storage",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )
        self.__vdu_storage_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vdu_storage_requirements_mec_app_descriptor__mec_appd_virtual_storage_block_storage_vdu_storage_requirements,
                yang_name="vdu-storage-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
                choice=("storage", "block-storage"),
            ),
            is_container="list",
            yang_name="vdu-storage-requirements",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__rdma_enabled = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="rdma-enabled",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )
        self.__sw_image_id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="sw-image-id",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-storage", "block-storage"]

    def _get_size_of_storage(self):
        """
        Getter method for size_of_storage, mapped from YANG variable /mec_appd/virtual_storage/block_storage/size_of_storage (uint64)

        YANG Description: Size of virtualised storage resource in GB.
        """
        return self.__size_of_storage

    def _set_size_of_storage(self, v, load=False):
        """
        Setter method for size_of_storage, mapped from YANG variable /mec_appd/virtual_storage/block_storage/size_of_storage (uint64)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_size_of_storage is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_size_of_storage() directly.

        YANG Description: Size of virtualised storage resource in GB.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..18446744073709551615"]},
                    int_size=64,
                ),
                is_leaf=True,
                yang_name="size-of-storage",
                parent=self,
                choice=("storage", "block-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint64",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """size_of_storage must be of a type compatible with uint64""",
                    "defined-type": "uint64",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
                }
            )

        self.__size_of_storage = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_size_of_storage(self):
        self.__size_of_storage = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="size-of-storage",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )

    def _get_vdu_storage_requirements(self):
        """
        Getter method for vdu_storage_requirements, mapped from YANG variable /mec_appd/virtual_storage/block_storage/vdu_storage_requirements (list)

        YANG Description: An array of key-value pairs that articulate the storage deployment requirements
        """
        return self.__vdu_storage_requirements

    def _set_vdu_storage_requirements(self, v, load=False):
        """
        Setter method for vdu_storage_requirements, mapped from YANG variable /mec_appd/virtual_storage/block_storage/vdu_storage_requirements (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_vdu_storage_requirements is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_vdu_storage_requirements() directly.

        YANG Description: An array of key-value pairs that articulate the storage deployment requirements
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_vdu_storage_requirements_mec_app_descriptor__mec_appd_virtual_storage_block_storage_vdu_storage_requirements,
                    yang_name="vdu-storage-requirements",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                    choice=("storage", "block-storage"),
                ),
                is_container="list",
                yang_name="vdu-storage-requirements",
                parent=self,
                choice=("storage", "block-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """vdu_storage_requirements must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_vdu_storage_requirements_mec_app_descriptor__mec_appd_virtual_storage_block_storage_vdu_storage_requirements, yang_name="vdu-storage-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None, choice=('storage', 'block-storage')), is_container='list', yang_name="vdu-storage-requirements", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__vdu_storage_requirements = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_vdu_storage_requirements(self):
        self.__vdu_storage_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vdu_storage_requirements_mec_app_descriptor__mec_appd_virtual_storage_block_storage_vdu_storage_requirements,
                yang_name="vdu-storage-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
                choice=("storage", "block-storage"),
            ),
            is_container="list",
            yang_name="vdu-storage-requirements",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_rdma_enabled(self):
        """
        Getter method for rdma_enabled, mapped from YANG variable /mec_appd/virtual_storage/block_storage/rdma_enabled (boolean)

        YANG Description: Indicates if the storage support RDMA
        """
        return self.__rdma_enabled

    def _set_rdma_enabled(self, v, load=False):
        """
        Setter method for rdma_enabled, mapped from YANG variable /mec_appd/virtual_storage/block_storage/rdma_enabled (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_rdma_enabled is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_rdma_enabled() directly.

        YANG Description: Indicates if the storage support RDMA
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                is_leaf=True,
                yang_name="rdma-enabled",
                parent=self,
                choice=("storage", "block-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """rdma_enabled must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rdma-enabled", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__rdma_enabled = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_rdma_enabled(self):
        self.__rdma_enabled = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="rdma-enabled",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    def _get_sw_image_id(self):
        """
        Getter method for sw_image_id, mapped from YANG variable /mec_appd/virtual_storage/block_storage/sw_image_id (string)

        YANG Description: References the software image to be loaded on the VirtualStorage resource created based on this VirtualStorageDesc. Shall be absent when used for virtual disks.
        """
        return self.__sw_image_id

    def _set_sw_image_id(self, v, load=False):
        """
        Setter method for sw_image_id, mapped from YANG variable /mec_appd/virtual_storage/block_storage/sw_image_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_sw_image_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_sw_image_id() directly.

        YANG Description: References the software image to be loaded on the VirtualStorage resource created based on this VirtualStorageDesc. Shall be absent when used for virtual disks.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="sw-image-id",
                parent=self,
                choice=("storage", "block-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """sw_image_id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-id", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__sw_image_id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_sw_image_id(self):
        self.__sw_image_id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="sw-image-id",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    size_of_storage = __builtin__.property(_get_size_of_storage, _set_size_of_storage)
    vdu_storage_requirements = __builtin__.property(
        _get_vdu_storage_requirements, _set_vdu_storage_requirements
    )
    rdma_enabled = __builtin__.property(_get_rdma_enabled, _set_rdma_enabled)
    sw_image_id = __builtin__.property(_get_sw_image_id, _set_sw_image_id)

    __choices__ = {
        "storage": {
            "block-storage": [
                "size_of_storage",
                "vdu_storage_requirements",
                "rdma_enabled",
                "sw_image_id",
            ]
        }
    }
    _pyangbind_elements = OrderedDict(
        [
            ("size_of_storage", size_of_storage),
            ("vdu_storage_requirements", vdu_storage_requirements),
            ("rdma_enabled", rdma_enabled),
            ("sw_image_id", sw_image_id),
        ]
    )


class yc_object_storage_mec_app_descriptor__mec_appd_virtual_storage_object_storage(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-storage/object-storage. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Specifies the details of object storage. Applicable only if typeOfStorage=OBJECT
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__max_size_of_storage",
    )

    _yang_name = "object-storage"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__max_size_of_storage = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="max-size-of-storage",
            parent=self,
            choice=("storage", "object-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-storage", "object-storage"]

    def _get_max_size_of_storage(self):
        """
        Getter method for max_size_of_storage, mapped from YANG variable /mec_appd/virtual_storage/object_storage/max_size_of_storage (uint64)

        YANG Description: Max size of virtualised storage resource in GB.
        """
        return self.__max_size_of_storage

    def _set_max_size_of_storage(self, v, load=False):
        """
        Setter method for max_size_of_storage, mapped from YANG variable /mec_appd/virtual_storage/object_storage/max_size_of_storage (uint64)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_size_of_storage is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_size_of_storage() directly.

        YANG Description: Max size of virtualised storage resource in GB.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..18446744073709551615"]},
                    int_size=64,
                ),
                is_leaf=True,
                yang_name="max-size-of-storage",
                parent=self,
                choice=("storage", "object-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint64",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """max_size_of_storage must be of a type compatible with uint64""",
                    "defined-type": "uint64",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-storage", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
                }
            )

        self.__max_size_of_storage = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_max_size_of_storage(self):
        self.__max_size_of_storage = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="max-size-of-storage",
            parent=self,
            choice=("storage", "object-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )

    max_size_of_storage = __builtin__.property(
        _get_max_size_of_storage, _set_max_size_of_storage
    )

    __choices__ = {"storage": {"object-storage": ["max_size_of_storage"]}}
    _pyangbind_elements = OrderedDict(
        [
            ("max_size_of_storage", max_size_of_storage),
        ]
    )


class yc_file_storage_mec_app_descriptor__mec_appd_virtual_storage_file_storage(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-storage/file-storage. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Specifies the details of file storage. Applicable only if typeOfStorage=FILE
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__size_of_storage",
        "__file_system_protocol",
        "__int_virtual_link_id",
    )

    _yang_name = "file-storage"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__size_of_storage = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="size-of-storage",
            parent=self,
            choice=("storage", "file-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )
        self.__file_system_protocol = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="file-system-protocol",
            parent=self,
            choice=("storage", "file-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__int_virtual_link_id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="int-virtual-link-id",
            parent=self,
            choice=("storage", "file-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-storage", "file-storage"]

    def _get_size_of_storage(self):
        """
        Getter method for size_of_storage, mapped from YANG variable /mec_appd/virtual_storage/file_storage/size_of_storage (uint64)

        YANG Description: Size of virtualised storage resource in GB.
        """
        return self.__size_of_storage

    def _set_size_of_storage(self, v, load=False):
        """
        Setter method for size_of_storage, mapped from YANG variable /mec_appd/virtual_storage/file_storage/size_of_storage (uint64)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_size_of_storage is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_size_of_storage() directly.

        YANG Description: Size of virtualised storage resource in GB.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..18446744073709551615"]},
                    int_size=64,
                ),
                is_leaf=True,
                yang_name="size-of-storage",
                parent=self,
                choice=("storage", "file-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint64",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """size_of_storage must be of a type compatible with uint64""",
                    "defined-type": "uint64",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
                }
            )

        self.__size_of_storage = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_size_of_storage(self):
        self.__size_of_storage = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..18446744073709551615"]},
                int_size=64,
            ),
            is_leaf=True,
            yang_name="size-of-storage",
            parent=self,
            choice=("storage", "file-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint64",
            is_config=True,
        )

    def _get_file_system_protocol(self):
        """
        Getter method for file_system_protocol, mapped from YANG variable /mec_appd/virtual_storage/file_storage/file_system_protocol (string)

        YANG Description: The shared file system protocol (e.g. NFS, CIFS).
        """
        return self.__file_system_protocol

    def _set_file_system_protocol(self, v, load=False):
        """
        Setter method for file_system_protocol, mapped from YANG variable /mec_appd/virtual_storage/file_storage/file_system_protocol (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_file_system_protocol is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_file_system_protocol() directly.

        YANG Description: The shared file system protocol (e.g. NFS, CIFS).
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="file-system-protocol",
                parent=self,
                choice=("storage", "file-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """file_system_protocol must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file-system-protocol", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__file_system_protocol = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_file_system_protocol(self):
        self.__file_system_protocol = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="file-system-protocol",
            parent=self,
            choice=("storage", "file-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_int_virtual_link_id(self):
        """
        Getter method for int_virtual_link_id, mapped from YANG variable /mec_appd/virtual_storage/file_storage/int_virtual_link_id (string)

        YANG Description: Reference of the internal VLD which this file storage connects to. The attached VDUs shall connect to the same internal VLD.
        """
        return self.__int_virtual_link_id

    def _set_int_virtual_link_id(self, v, load=False):
        """
        Setter method for int_virtual_link_id, mapped from YANG variable /mec_appd/virtual_storage/file_storage/int_virtual_link_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_int_virtual_link_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_int_virtual_link_id() directly.

        YANG Description: Reference of the internal VLD which this file storage connects to. The attached VDUs shall connect to the same internal VLD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="int-virtual-link-id",
                parent=self,
                choice=("storage", "file-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """int_virtual_link_id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-id", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__int_virtual_link_id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_int_virtual_link_id(self):
        self.__int_virtual_link_id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="int-virtual-link-id",
            parent=self,
            choice=("storage", "file-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    size_of_storage = __builtin__.property(_get_size_of_storage, _set_size_of_storage)
    file_system_protocol = __builtin__.property(
        _get_file_system_protocol, _set_file_system_protocol
    )
    int_virtual_link_id = __builtin__.property(
        _get_int_virtual_link_id, _set_int_virtual_link_id
    )

    __choices__ = {
        "storage": {
            "file-storage": [
                "size_of_storage",
                "file_system_protocol",
                "int_virtual_link_id",
            ]
        }
    }
    _pyangbind_elements = OrderedDict(
        [
            ("size_of_storage", size_of_storage),
            ("file_system_protocol", file_system_protocol),
            ("int_virtual_link_id", int_virtual_link_id),
        ]
    )


class yc_max_number_of_impacted_instances_mec_app_descriptor__mec_appd_virtual_storage_nfvi_maintenance_info_max_number_of_impacted_instances(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-storage/nfvi-maintenance-info/max-number-of-impacted-instances. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: When present, specifies for different group sizes the maximum number of instances that can be impacted simultaneously within the group of virtualised resources without losing functionality. Zero cardinality indicates no constraint
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__group_size",
        "__max_number_of_impacted_instances",
    )

    _yang_name = "max-number-of-impacted-instances"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__group_size = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="group-size",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )
        self.__max_number_of_impacted_instances = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="max-number-of-impacted-instances",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "virtual-storage",
                "nfvi-maintenance-info",
                "max-number-of-impacted-instances",
            ]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/max_number_of_impacted_instances/id (string)

        YANG Description: Identifier of the impacted instances
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/max_number_of_impacted_instances/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Identifier of the impacted instances
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_group_size(self):
        """
        Getter method for group_size, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/max_number_of_impacted_instances/group_size (uint32)

        YANG Description: Number of impacted instances in a group
        """
        return self.__group_size

    def _set_group_size(self, v, load=False):
        """
        Setter method for group_size, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/max_number_of_impacted_instances/group_size (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_group_size is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_group_size() directly.

        YANG Description: Number of impacted instances in a group
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="group-size",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """group_size must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__group_size = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_group_size(self):
        self.__group_size = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="group-size",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    def _get_max_number_of_impacted_instances(self):
        """
        Getter method for max_number_of_impacted_instances, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/max_number_of_impacted_instances/max_number_of_impacted_instances (uint32)

        YANG Description: Maximum number of impacted instances
        """
        return self.__max_number_of_impacted_instances

    def _set_max_number_of_impacted_instances(self, v, load=False):
        """
        Setter method for max_number_of_impacted_instances, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/max_number_of_impacted_instances/max_number_of_impacted_instances (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_number_of_impacted_instances is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_number_of_impacted_instances() directly.

        YANG Description: Maximum number of impacted instances
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="max-number-of-impacted-instances",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """max_number_of_impacted_instances must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-number-of-impacted-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__max_number_of_impacted_instances = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_max_number_of_impacted_instances(self):
        self.__max_number_of_impacted_instances = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="max-number-of-impacted-instances",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    group_size = __builtin__.property(_get_group_size, _set_group_size)
    max_number_of_impacted_instances = __builtin__.property(
        _get_max_number_of_impacted_instances, _set_max_number_of_impacted_instances
    )

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("group_size", group_size),
            ("max_number_of_impacted_instances", max_number_of_impacted_instances),
        ]
    )


class yc_nfvi_maintenance_info_mec_app_descriptor__mec_appd_virtual_storage_nfvi_maintenance_info(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-storage/nfvi-maintenance-info. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description:
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__impact_notification_lead_time",
        "__is_impact_mitigation_requested",
        "__supported_migration_time",
        "__max_undetectable_interruption_time",
        "__min_recovery_time_between_impacts",
        "__max_number_of_impacted_instances",
    )

    _yang_name = "nfvi-maintenance-info"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__impact_notification_lead_time = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="impact-notification-lead-time",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )
        self.__is_impact_mitigation_requested = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="is-impact-mitigation-requested",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )
        self.__supported_migration_time = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "NO_MIGRATION": {},
                        "OFFLINE_MIGRATION": {},
                        "LIVE_MIGRATION": {},
                    },
                )
            ),
            is_leaf=False,
            yang_name="supported-migration-time",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__max_undetectable_interruption_time = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="max-undetectable-interruption-time",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )
        self.__min_recovery_time_between_impacts = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="min-recovery-time-between-impacts",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )
        self.__max_number_of_impacted_instances = YANGDynClass(
            base=YANGListType(
                "id",
                yc_max_number_of_impacted_instances_mec_app_descriptor__mec_appd_virtual_storage_nfvi_maintenance_info_max_number_of_impacted_instances,
                yang_name="max-number-of-impacted-instances",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="max-number-of-impacted-instances",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-storage", "nfvi-maintenance-info"]

    def _get_impact_notification_lead_time(self):
        """
        Getter method for impact_notification_lead_time, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/impact_notification_lead_time (uint32)

        YANG Description: The value specifies the minimum notification lead time requested for upcoming impact of the virtualised resource or their group (i.e. between the notification and the action causing the impact).
        """
        return self.__impact_notification_lead_time

    def _set_impact_notification_lead_time(self, v, load=False):
        """
        Setter method for impact_notification_lead_time, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/impact_notification_lead_time (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_impact_notification_lead_time is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_impact_notification_lead_time() directly.

        YANG Description: The value specifies the minimum notification lead time requested for upcoming impact of the virtualised resource or their group (i.e. between the notification and the action causing the impact).
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="impact-notification-lead-time",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """impact_notification_lead_time must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="impact-notification-lead-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__impact_notification_lead_time = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_impact_notification_lead_time(self):
        self.__impact_notification_lead_time = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="impact-notification-lead-time",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    def _get_is_impact_mitigation_requested(self):
        """
        Getter method for is_impact_mitigation_requested, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/is_impact_mitigation_requested (boolean)

        YANG Description: When set to True, it is requested that at the time of the notification of an upcoming change that is expected to have an impact on the VNF, virtualised resource(s) of the same characteristics as the impacted ones is/are provided to compensate for the impact. Cardinality 0 corresponds to the value False.
        """
        return self.__is_impact_mitigation_requested

    def _set_is_impact_mitigation_requested(self, v, load=False):
        """
        Setter method for is_impact_mitigation_requested, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/is_impact_mitigation_requested (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_is_impact_mitigation_requested is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_is_impact_mitigation_requested() directly.

        YANG Description: When set to True, it is requested that at the time of the notification of an upcoming change that is expected to have an impact on the VNF, virtualised resource(s) of the same characteristics as the impacted ones is/are provided to compensate for the impact. Cardinality 0 corresponds to the value False.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                is_leaf=True,
                yang_name="is-impact-mitigation-requested",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """is_impact_mitigation_requested must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-impact-mitigation-requested", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__is_impact_mitigation_requested = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_is_impact_mitigation_requested(self):
        self.__is_impact_mitigation_requested = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="is-impact-mitigation-requested",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    def _get_supported_migration_time(self):
        """
        Getter method for supported_migration_time, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/supported_migration_time (enumeration)

        YANG Description: When present, specifies the allowed migration types in the order of preference in case of an impact starting with the most preferred type
        """
        return self.__supported_migration_time

    def _set_supported_migration_time(self, v, load=False):
        """
        Setter method for supported_migration_time, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/supported_migration_time (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_migration_time is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_migration_time() directly.

        YANG Description: When present, specifies the allowed migration types in the order of preference in case of an impact starting with the most preferred type
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={
                            "NO_MIGRATION": {},
                            "OFFLINE_MIGRATION": {},
                            "LIVE_MIGRATION": {},
                        },
                    )
                ),
                is_leaf=False,
                yang_name="supported-migration-time",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """supported_migration_time must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'NO_MIGRATION': {}, 'OFFLINE_MIGRATION': {}, 'LIVE_MIGRATION': {}},)), is_leaf=False, yang_name="supported-migration-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__supported_migration_time = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_supported_migration_time(self):
        self.__supported_migration_time = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "NO_MIGRATION": {},
                        "OFFLINE_MIGRATION": {},
                        "LIVE_MIGRATION": {},
                    },
                )
            ),
            is_leaf=False,
            yang_name="supported-migration-time",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_max_undetectable_interruption_time(self):
        """
        Getter method for max_undetectable_interruption_time, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/max_undetectable_interruption_time (uint32)

        YANG Description: When present, it specifies the maximum interruption time that can go undetected at the VNF level and therefore which will not trigger VNFinternal recovery during live migration
        """
        return self.__max_undetectable_interruption_time

    def _set_max_undetectable_interruption_time(self, v, load=False):
        """
        Setter method for max_undetectable_interruption_time, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/max_undetectable_interruption_time (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_undetectable_interruption_time is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_undetectable_interruption_time() directly.

        YANG Description: When present, it specifies the maximum interruption time that can go undetected at the VNF level and therefore which will not trigger VNFinternal recovery during live migration
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="max-undetectable-interruption-time",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """max_undetectable_interruption_time must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-undetectable-interruption-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__max_undetectable_interruption_time = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_max_undetectable_interruption_time(self):
        self.__max_undetectable_interruption_time = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="max-undetectable-interruption-time",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    def _get_min_recovery_time_between_impacts(self):
        """
        Getter method for min_recovery_time_between_impacts, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/min_recovery_time_between_impacts (uint32)

        YANG Description: When present, it specifies the time required by the group to recover from an impact, thus, the minimum time requested between consecutive impacts of the group
        """
        return self.__min_recovery_time_between_impacts

    def _set_min_recovery_time_between_impacts(self, v, load=False):
        """
        Setter method for min_recovery_time_between_impacts, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/min_recovery_time_between_impacts (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_min_recovery_time_between_impacts is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_min_recovery_time_between_impacts() directly.

        YANG Description: When present, it specifies the time required by the group to recover from an impact, thus, the minimum time requested between consecutive impacts of the group
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="min-recovery-time-between-impacts",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """min_recovery_time_between_impacts must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-recovery-time-between-impacts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__min_recovery_time_between_impacts = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_min_recovery_time_between_impacts(self):
        self.__min_recovery_time_between_impacts = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="min-recovery-time-between-impacts",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    def _get_max_number_of_impacted_instances(self):
        """
        Getter method for max_number_of_impacted_instances, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/max_number_of_impacted_instances (list)

        YANG Description: When present, specifies for different group sizes the maximum number of instances that can be impacted simultaneously within the group of virtualised resources without losing functionality. Zero cardinality indicates no constraint
        """
        return self.__max_number_of_impacted_instances

    def _set_max_number_of_impacted_instances(self, v, load=False):
        """
        Setter method for max_number_of_impacted_instances, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info/max_number_of_impacted_instances (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_number_of_impacted_instances is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_number_of_impacted_instances() directly.

        YANG Description: When present, specifies for different group sizes the maximum number of instances that can be impacted simultaneously within the group of virtualised resources without losing functionality. Zero cardinality indicates no constraint
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_max_number_of_impacted_instances_mec_app_descriptor__mec_appd_virtual_storage_nfvi_maintenance_info_max_number_of_impacted_instances,
                    yang_name="max-number-of-impacted-instances",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="max-number-of-impacted-instances",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """max_number_of_impacted_instances must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_max_number_of_impacted_instances_mec_app_descriptor__mec_appd_virtual_storage_nfvi_maintenance_info_max_number_of_impacted_instances, yang_name="max-number-of-impacted-instances", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="max-number-of-impacted-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__max_number_of_impacted_instances = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_max_number_of_impacted_instances(self):
        self.__max_number_of_impacted_instances = YANGDynClass(
            base=YANGListType(
                "id",
                yc_max_number_of_impacted_instances_mec_app_descriptor__mec_appd_virtual_storage_nfvi_maintenance_info_max_number_of_impacted_instances,
                yang_name="max-number-of-impacted-instances",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="max-number-of-impacted-instances",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    impact_notification_lead_time = __builtin__.property(
        _get_impact_notification_lead_time, _set_impact_notification_lead_time
    )
    is_impact_mitigation_requested = __builtin__.property(
        _get_is_impact_mitigation_requested, _set_is_impact_mitigation_requested
    )
    supported_migration_time = __builtin__.property(
        _get_supported_migration_time, _set_supported_migration_time
    )
    max_undetectable_interruption_time = __builtin__.property(
        _get_max_undetectable_interruption_time, _set_max_undetectable_interruption_time
    )
    min_recovery_time_between_impacts = __builtin__.property(
        _get_min_recovery_time_between_impacts, _set_min_recovery_time_between_impacts
    )
    max_number_of_impacted_instances = __builtin__.property(
        _get_max_number_of_impacted_instances, _set_max_number_of_impacted_instances
    )

    _pyangbind_elements = OrderedDict(
        [
            ("impact_notification_lead_time", impact_notification_lead_time),
            ("is_impact_mitigation_requested", is_impact_mitigation_requested),
            ("supported_migration_time", supported_migration_time),
            ("max_undetectable_interruption_time", max_undetectable_interruption_time),
            ("min_recovery_time_between_impacts", min_recovery_time_between_impacts),
            ("max_number_of_impacted_instances", max_number_of_impacted_instances),
        ]
    )


class yc_virtual_storage_mec_app_descriptor__mec_appd_virtual_storage(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/virtual-storage. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Defines descriptors of virtual storage resources to be used by the MEC application.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__type_of_storage",
        "__block_storage",
        "__object_storage",
        "__file_storage",
        "__nfvi_maintenance_info",
        "__per_vnfc_instance",
    )

    _yang_name = "virtual-storage"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__type_of_storage = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"BLOCK": {}, "OBJECT": {}, "FILE": {}},
            ),
            is_leaf=True,
            yang_name="type-of-storage",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__block_storage = YANGDynClass(
            base=yc_block_storage_mec_app_descriptor__mec_appd_virtual_storage_block_storage,
            is_container="container",
            yang_name="block-storage",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__object_storage = YANGDynClass(
            base=yc_object_storage_mec_app_descriptor__mec_appd_virtual_storage_object_storage,
            is_container="container",
            yang_name="object-storage",
            parent=self,
            choice=("storage", "object-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__file_storage = YANGDynClass(
            base=yc_file_storage_mec_app_descriptor__mec_appd_virtual_storage_file_storage,
            is_container="container",
            yang_name="file-storage",
            parent=self,
            choice=("storage", "file-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__nfvi_maintenance_info = YANGDynClass(
            base=yc_nfvi_maintenance_info_mec_app_descriptor__mec_appd_virtual_storage_nfvi_maintenance_info,
            is_container="container",
            yang_name="nfvi-maintenance-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__per_vnfc_instance = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="per-vnfc-instance",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "virtual-storage"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/virtual_storage/id (string)

        YANG Description: Unique identifier for this VirtualStorageDesc
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/virtual_storage/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier for this VirtualStorageDesc
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_type_of_storage(self):
        """
        Getter method for type_of_storage, mapped from YANG variable /mec_appd/virtual_storage/type_of_storage (enumeration)

        YANG Description: Type of virtualised storage resource
        """
        return self.__type_of_storage

    def _set_type_of_storage(self, v, load=False):
        """
        Setter method for type_of_storage, mapped from YANG variable /mec_appd/virtual_storage/type_of_storage (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_type_of_storage is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_type_of_storage() directly.

        YANG Description: Type of virtualised storage resource
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={"BLOCK": {}, "OBJECT": {}, "FILE": {}},
                ),
                is_leaf=True,
                yang_name="type-of-storage",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """type_of_storage must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__type_of_storage = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_type_of_storage(self):
        self.__type_of_storage = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"BLOCK": {}, "OBJECT": {}, "FILE": {}},
            ),
            is_leaf=True,
            yang_name="type-of-storage",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_block_storage(self):
        """
        Getter method for block_storage, mapped from YANG variable /mec_appd/virtual_storage/block_storage (container)

        YANG Description: Specifies the details of block storage. Applicable only if typeOfStorage=BLOCK
        """
        return self.__block_storage

    def _set_block_storage(self, v, load=False):
        """
        Setter method for block_storage, mapped from YANG variable /mec_appd/virtual_storage/block_storage (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_block_storage is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_block_storage() directly.

        YANG Description: Specifies the details of block storage. Applicable only if typeOfStorage=BLOCK
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_block_storage_mec_app_descriptor__mec_appd_virtual_storage_block_storage,
                is_container="container",
                yang_name="block-storage",
                parent=self,
                choice=("storage", "block-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """block_storage must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_block_storage_mec_app_descriptor__mec_appd_virtual_storage_block_storage, is_container='container', yang_name="block-storage", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__block_storage = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_block_storage(self):
        self.__block_storage = YANGDynClass(
            base=yc_block_storage_mec_app_descriptor__mec_appd_virtual_storage_block_storage,
            is_container="container",
            yang_name="block-storage",
            parent=self,
            choice=("storage", "block-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_object_storage(self):
        """
        Getter method for object_storage, mapped from YANG variable /mec_appd/virtual_storage/object_storage (container)

        YANG Description: Specifies the details of object storage. Applicable only if typeOfStorage=OBJECT
        """
        return self.__object_storage

    def _set_object_storage(self, v, load=False):
        """
        Setter method for object_storage, mapped from YANG variable /mec_appd/virtual_storage/object_storage (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_object_storage is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_object_storage() directly.

        YANG Description: Specifies the details of object storage. Applicable only if typeOfStorage=OBJECT
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_object_storage_mec_app_descriptor__mec_appd_virtual_storage_object_storage,
                is_container="container",
                yang_name="object-storage",
                parent=self,
                choice=("storage", "object-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """object_storage must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_object_storage_mec_app_descriptor__mec_appd_virtual_storage_object_storage, is_container='container', yang_name="object-storage", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__object_storage = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_object_storage(self):
        self.__object_storage = YANGDynClass(
            base=yc_object_storage_mec_app_descriptor__mec_appd_virtual_storage_object_storage,
            is_container="container",
            yang_name="object-storage",
            parent=self,
            choice=("storage", "object-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_file_storage(self):
        """
        Getter method for file_storage, mapped from YANG variable /mec_appd/virtual_storage/file_storage (container)

        YANG Description: Specifies the details of file storage. Applicable only if typeOfStorage=FILE
        """
        return self.__file_storage

    def _set_file_storage(self, v, load=False):
        """
        Setter method for file_storage, mapped from YANG variable /mec_appd/virtual_storage/file_storage (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_file_storage is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_file_storage() directly.

        YANG Description: Specifies the details of file storage. Applicable only if typeOfStorage=FILE
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_file_storage_mec_app_descriptor__mec_appd_virtual_storage_file_storage,
                is_container="container",
                yang_name="file-storage",
                parent=self,
                choice=("storage", "file-storage"),
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """file_storage must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_file_storage_mec_app_descriptor__mec_appd_virtual_storage_file_storage, is_container='container', yang_name="file-storage", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__file_storage = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_file_storage(self):
        self.__file_storage = YANGDynClass(
            base=yc_file_storage_mec_app_descriptor__mec_appd_virtual_storage_file_storage,
            is_container="container",
            yang_name="file-storage",
            parent=self,
            choice=("storage", "file-storage"),
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_nfvi_maintenance_info(self):
        """
        Getter method for nfvi_maintenance_info, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info (container)
        """
        return self.__nfvi_maintenance_info

    def _set_nfvi_maintenance_info(self, v, load=False):
        """
        Setter method for nfvi_maintenance_info, mapped from YANG variable /mec_appd/virtual_storage/nfvi_maintenance_info (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_nfvi_maintenance_info is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_nfvi_maintenance_info() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_nfvi_maintenance_info_mec_app_descriptor__mec_appd_virtual_storage_nfvi_maintenance_info,
                is_container="container",
                yang_name="nfvi-maintenance-info",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """nfvi_maintenance_info must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_nfvi_maintenance_info_mec_app_descriptor__mec_appd_virtual_storage_nfvi_maintenance_info, is_container='container', yang_name="nfvi-maintenance-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__nfvi_maintenance_info = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_nfvi_maintenance_info(self):
        self.__nfvi_maintenance_info = YANGDynClass(
            base=yc_nfvi_maintenance_info_mec_app_descriptor__mec_appd_virtual_storage_nfvi_maintenance_info,
            is_container="container",
            yang_name="nfvi-maintenance-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_per_vnfc_instance(self):
        """
        Getter method for per_vnfc_instance, mapped from YANG variable /mec_appd/virtual_storage/per_vnfc_instance (boolean)

        YANG Description: Indicates if the storage resource is dedicated to a VNFC instance
        """
        return self.__per_vnfc_instance

    def _set_per_vnfc_instance(self, v, load=False):
        """
        Setter method for per_vnfc_instance, mapped from YANG variable /mec_appd/virtual_storage/per_vnfc_instance (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_per_vnfc_instance is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_per_vnfc_instance() directly.

        YANG Description: Indicates if the storage resource is dedicated to a VNFC instance
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                is_leaf=True,
                yang_name="per-vnfc-instance",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """per_vnfc_instance must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="per-vnfc-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__per_vnfc_instance = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_per_vnfc_instance(self):
        self.__per_vnfc_instance = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="per-vnfc-instance",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    type_of_storage = __builtin__.property(_get_type_of_storage, _set_type_of_storage)
    block_storage = __builtin__.property(_get_block_storage, _set_block_storage)
    object_storage = __builtin__.property(_get_object_storage, _set_object_storage)
    file_storage = __builtin__.property(_get_file_storage, _set_file_storage)
    nfvi_maintenance_info = __builtin__.property(
        _get_nfvi_maintenance_info, _set_nfvi_maintenance_info
    )
    per_vnfc_instance = __builtin__.property(
        _get_per_vnfc_instance, _set_per_vnfc_instance
    )

    __choices__ = {
        "storage": {
            "block-storage": ["block_storage"],
            "object-storage": ["object_storage"],
            "file-storage": ["file_storage"],
        }
    }
    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("type_of_storage", type_of_storage),
            ("block_storage", block_storage),
            ("object_storage", object_storage),
            ("file_storage", file_storage),
            ("nfvi_maintenance_info", nfvi_maintenance_info),
            ("per_vnfc_instance", per_vnfc_instance),
        ]
    )


class yc_network_interface_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_network_interface_requirements(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/ext-cpd/virtual-network-interface-requirements/network-interface-requirements. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description:
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "network-interface-requirements"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "ext-cpd",
                "virtual-network-interface-requirements",
                "network-interface-requirements",
            ]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/network_interface_requirements/key (string)

        YANG Description: Key in the key-value pair
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/network_interface_requirements/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key in the key-value pair
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/network_interface_requirements/value (union)

        YANG Description: Value in the key-value pair
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/network_interface_requirements/value (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value in the key-value pair
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    YANGBool,
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["-2147483648..2147483647"]},
                        int_size=32,
                    ),
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["0..4294967295"]},
                        int_size=32,
                    ),
                    six.text_type,
                ],
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="union",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with union""",
                    "defined-type": "mec-app-descriptor:union",
                    "generated-type": """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='union', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_logical_node_requirement_details_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_niclo_requirements_logical_node_requirement_details(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/ext-cpd/virtual-network-interface-requirements/niclo-requirements/logical-node-requirement-details. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements. This could include the number of CPU cores on this logical node, a memory configuration specific to a logical node (e.g. such as available in the Linux kernel via the libnuma library) or a requirement related to the association of an I/O device with the logical node.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "logical-node-requirement-details"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "ext-cpd",
                "virtual-network-interface-requirements",
                "niclo-requirements",
                "logical-node-requirement-details",
            ]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/niclo_requirements/logical_node_requirement_details/key (string)

        YANG Description: Key in the key-value pair
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/niclo_requirements/logical_node_requirement_details/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key in the key-value pair
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/niclo_requirements/logical_node_requirement_details/value (union)

        YANG Description: Value in the key-value pair
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/niclo_requirements/logical_node_requirement_details/value (union)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value in the key-value pair
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    YANGBool,
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["-2147483648..2147483647"]},
                        int_size=32,
                    ),
                    RestrictedClassType(
                        base_type=long,
                        restriction_dict={"range": ["0..4294967295"]},
                        int_size=32,
                    ),
                    six.text_type,
                ],
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="union",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with union""",
                    "defined-type": "mec-app-descriptor:union",
                    "generated-type": """YANGDynClass(base=[YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32),RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),six.text_type,], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='union', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=[
                YANGBool,
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["-2147483648..2147483647"]},
                    int_size=32,
                ),
                RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                six.text_type,
            ],
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="union",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_niclo_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_niclo_requirements(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/ext-cpd/virtual-network-interface-requirements/niclo-requirements. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: This references (couples) the CPD with any logical node I/O requirements (for network devices) that may have been created. Linking these attributes is necessary so that I/O requirements that need to be articulated at the logical node level can be associated with the network interface requirements associated with the CPD.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__logical_node_requirement_details",
    )

    _yang_name = "niclo-requirements"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__logical_node_requirement_details = YANGDynClass(
            base=YANGListType(
                "key",
                yc_logical_node_requirement_details_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_niclo_requirements_logical_node_requirement_details,
                yang_name="logical-node-requirement-details",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="logical-node-requirement-details",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "ext-cpd",
                "virtual-network-interface-requirements",
                "niclo-requirements",
            ]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/niclo_requirements/id (string)

        YANG Description: Identifier of the logical node requirement
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/niclo_requirements/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Identifier of the logical node requirement
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_logical_node_requirement_details(self):
        """
        Getter method for logical_node_requirement_details, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/niclo_requirements/logical_node_requirement_details (list)

        YANG Description: The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements. This could include the number of CPU cores on this logical node, a memory configuration specific to a logical node (e.g. such as available in the Linux kernel via the libnuma library) or a requirement related to the association of an I/O device with the logical node.
        """
        return self.__logical_node_requirement_details

    def _set_logical_node_requirement_details(self, v, load=False):
        """
        Setter method for logical_node_requirement_details, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/niclo_requirements/logical_node_requirement_details (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_logical_node_requirement_details is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_logical_node_requirement_details() directly.

        YANG Description: The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements. This could include the number of CPU cores on this logical node, a memory configuration specific to a logical node (e.g. such as available in the Linux kernel via the libnuma library) or a requirement related to the association of an I/O device with the logical node.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_logical_node_requirement_details_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_niclo_requirements_logical_node_requirement_details,
                    yang_name="logical-node-requirement-details",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="logical-node-requirement-details",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """logical_node_requirement_details must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_logical_node_requirement_details_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_niclo_requirements_logical_node_requirement_details, yang_name="logical-node-requirement-details", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="logical-node-requirement-details", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__logical_node_requirement_details = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_logical_node_requirement_details(self):
        self.__logical_node_requirement_details = YANGDynClass(
            base=YANGListType(
                "key",
                yc_logical_node_requirement_details_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_niclo_requirements_logical_node_requirement_details,
                yang_name="logical-node-requirement-details",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="logical-node-requirement-details",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    logical_node_requirement_details = __builtin__.property(
        _get_logical_node_requirement_details, _set_logical_node_requirement_details
    )

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("logical_node_requirement_details", logical_node_requirement_details),
        ]
    )


class yc_virtual_network_interface_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/ext-cpd/virtual-network-interface-requirements. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Specifies requirements on a virtual network interface realizing the CPs instantiated from this CPD.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__name",
        "__description",
        "__support_mandatory",
        "__network_interface_requirements",
        "__niclo_requirements",
    )

    _yang_name = "virtual-network-interface-requirements"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__support_mandatory = YANGDynClass(
            base=YANGBool,
            default=YANGBool("true"),
            is_leaf=True,
            yang_name="support-mandatory",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )
        self.__network_interface_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_network_interface_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_network_interface_requirements,
                yang_name="network-interface-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="network-interface-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__niclo_requirements = YANGDynClass(
            base=YANGListType(
                "id",
                yc_niclo_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_niclo_requirements,
                yang_name="niclo-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="niclo-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "ext-cpd", "virtual-network-interface-requirements"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/id (string)

        YANG Description: Identifier of the virtual network interface requirement
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Identifier of the virtual network interface requirement
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/name (string)

        YANG Description: Provides a human readable name for the requirement.
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: Provides a human readable name for the requirement.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_description(self):
        """
        Getter method for description, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/description (string)

        YANG Description: Provides a human readable description of the requirement.
        """
        return self.__description

    def _set_description(self, v, load=False):
        """
        Setter method for description, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/description (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_description is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_description() directly.

        YANG Description: Provides a human readable description of the requirement.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="description",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """description must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__description = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_support_mandatory(self):
        """
        Getter method for support_mandatory, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/support_mandatory (boolean)

        YANG Description: Indicates whether fulfilling the constraint is mandatory (true) for successful operation.
        """
        return self.__support_mandatory

    def _set_support_mandatory(self, v, load=False):
        """
        Setter method for support_mandatory, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/support_mandatory (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_support_mandatory is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_support_mandatory() directly.

        YANG Description: Indicates whether fulfilling the constraint is mandatory (true) for successful operation.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                default=YANGBool("true"),
                is_leaf=True,
                yang_name="support-mandatory",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """support_mandatory must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__support_mandatory = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_support_mandatory(self):
        self.__support_mandatory = YANGDynClass(
            base=YANGBool,
            default=YANGBool("true"),
            is_leaf=True,
            yang_name="support-mandatory",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    def _get_network_interface_requirements(self):
        """
        Getter method for network_interface_requirements, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/network_interface_requirements (list)
        """
        return self.__network_interface_requirements

    def _set_network_interface_requirements(self, v, load=False):
        """
        Setter method for network_interface_requirements, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/network_interface_requirements (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_network_interface_requirements is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_network_interface_requirements() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_network_interface_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_network_interface_requirements,
                    yang_name="network-interface-requirements",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="network-interface-requirements",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """network_interface_requirements must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_network_interface_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_network_interface_requirements, yang_name="network-interface-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="network-interface-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__network_interface_requirements = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_network_interface_requirements(self):
        self.__network_interface_requirements = YANGDynClass(
            base=YANGListType(
                "key",
                yc_network_interface_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_network_interface_requirements,
                yang_name="network-interface-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="network-interface-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_niclo_requirements(self):
        """
        Getter method for niclo_requirements, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/niclo_requirements (list)

        YANG Description: This references (couples) the CPD with any logical node I/O requirements (for network devices) that may have been created. Linking these attributes is necessary so that I/O requirements that need to be articulated at the logical node level can be associated with the network interface requirements associated with the CPD.
        """
        return self.__niclo_requirements

    def _set_niclo_requirements(self, v, load=False):
        """
        Setter method for niclo_requirements, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements/niclo_requirements (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_niclo_requirements is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_niclo_requirements() directly.

        YANG Description: This references (couples) the CPD with any logical node I/O requirements (for network devices) that may have been created. Linking these attributes is necessary so that I/O requirements that need to be articulated at the logical node level can be associated with the network interface requirements associated with the CPD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_niclo_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_niclo_requirements,
                    yang_name="niclo-requirements",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="niclo-requirements",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """niclo_requirements must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_niclo_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_niclo_requirements, yang_name="niclo-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="niclo-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__niclo_requirements = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_niclo_requirements(self):
        self.__niclo_requirements = YANGDynClass(
            base=YANGListType(
                "id",
                yc_niclo_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements_niclo_requirements,
                yang_name="niclo-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="niclo-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    support_mandatory = __builtin__.property(
        _get_support_mandatory, _set_support_mandatory
    )
    network_interface_requirements = __builtin__.property(
        _get_network_interface_requirements, _set_network_interface_requirements
    )
    niclo_requirements = __builtin__.property(
        _get_niclo_requirements, _set_niclo_requirements
    )

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("name", name),
            ("description", description),
            ("support_mandatory", support_mandatory),
            ("network_interface_requirements", network_interface_requirements),
            ("niclo_requirements", niclo_requirements),
        ]
    )


class yc_l3_address_data_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol_address_data_l3_address_data(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/ext-cpd/cp-protocol/address-data/l3-address-data. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: The L3 address data for the CP instantiated from this CPD.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__ip_address_type",
        "__number_of_ip_addresses",
        "__ip_address_assignment",
        "__floating_ip_activated",
        "__fixed_ip_address",
    )

    _yang_name = "l3-address-data"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"IPV4": {}, "IPV6": {}},
            ),
            is_leaf=True,
            yang_name="ip-address-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="number-of-ip-addresses",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )
        self.__ip_address_assignment = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={"DYNAMIC": {}, "STATIC": {}},
                )
            ),
            is_leaf=False,
            yang_name="ip-address-assignment",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__floating_ip_activated = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=YANGBool),
            is_leaf=False,
            yang_name="floating-ip-activated",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )
        self.__fixed_ip_address = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ]
            ),
            is_leaf=False,
            yang_name="fixed-ip-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "ext-cpd",
                "cp-protocol",
                "address-data",
                "l3-address-data",
            ]

    def _get_ip_address_type(self):
        """
        Getter method for ip_address_type, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data/ip_address_type (enumeration)

        YANG Description: The type of the IP address.
        """
        return self.__ip_address_type

    def _set_ip_address_type(self, v, load=False):
        """
        Setter method for ip_address_type, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data/ip_address_type (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_ip_address_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_ip_address_type() directly.

        YANG Description: The type of the IP address.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={"IPV4": {}, "IPV6": {}},
                ),
                is_leaf=True,
                yang_name="ip-address-type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """ip_address_type must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__ip_address_type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_ip_address_type(self):
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"IPV4": {}, "IPV6": {}},
            ),
            is_leaf=True,
            yang_name="ip-address-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_number_of_ip_addresses(self):
        """
        Getter method for number_of_ip_addresses, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)

        YANG Description: The number of IP addresses to assign to the CP instantiated from this CPD.
        """
        return self.__number_of_ip_addresses

    def _set_number_of_ip_addresses(self, v, load=False):
        """
        Setter method for number_of_ip_addresses, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_number_of_ip_addresses is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_number_of_ip_addresses() directly.

        YANG Description: The number of IP addresses to assign to the CP instantiated from this CPD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="number-of-ip-addresses",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """number_of_ip_addresses must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__number_of_ip_addresses = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_number_of_ip_addresses(self):
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="number-of-ip-addresses",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    def _get_ip_address_assignment(self):
        """
        Getter method for ip_address_assignment, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data/ip_address_assignment (enumeration)

        YANG Description: Specifies how the IP address(es) will be assigned.
        """
        return self.__ip_address_assignment

    def _set_ip_address_assignment(self, v, load=False):
        """
        Setter method for ip_address_assignment, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data/ip_address_assignment (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_ip_address_assignment is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_ip_address_assignment() directly.

        YANG Description: Specifies how the IP address(es) will be assigned.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={"DYNAMIC": {}, "STATIC": {}},
                    )
                ),
                is_leaf=False,
                yang_name="ip-address-assignment",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """ip_address_assignment must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DYNAMIC': {}, 'STATIC': {}},)), is_leaf=False, yang_name="ip-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__ip_address_assignment = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_ip_address_assignment(self):
        self.__ip_address_assignment = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={"DYNAMIC": {}, "STATIC": {}},
                )
            ),
            is_leaf=False,
            yang_name="ip-address-assignment",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_floating_ip_activated(self):
        """
        Getter method for floating_ip_activated, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data/floating_ip_activated (boolean)

        YANG Description: Specify if the floating IP scheme is activated on the CP instantiated from this CPD.
        """
        return self.__floating_ip_activated

    def _set_floating_ip_activated(self, v, load=False):
        """
        Setter method for floating_ip_activated, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data/floating_ip_activated (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_floating_ip_activated is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_floating_ip_activated() directly.

        YANG Description: Specify if the floating IP scheme is activated on the CP instantiated from this CPD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=YANGBool),
                is_leaf=False,
                yang_name="floating-ip-activated",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """floating_ip_activated must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=YANGBool), is_leaf=False, yang_name="floating-ip-activated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__floating_ip_activated = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_floating_ip_activated(self):
        self.__floating_ip_activated = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=YANGBool),
            is_leaf=False,
            yang_name="floating-ip-activated",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    def _get_fixed_ip_address(self):
        """
        Getter method for fixed_ip_address, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data/fixed_ip_address (inet:ip-address)

        YANG Description: Specifies the fixed IP address(es) to assign to the CP instantiated from this CPD.
        """
        return self.__fixed_ip_address

    def _set_fixed_ip_address(self, v, load=False):
        """
        Setter method for fixed_ip_address, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data/fixed_ip_address (inet:ip-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_fixed_ip_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_fixed_ip_address() directly.

        YANG Description: Specifies the fixed IP address(es) to assign to the CP instantiated from this CPD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=[
                        RestrictedClassType(
                            base_type=six.text_type,
                            restriction_dict={
                                "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                            },
                        ),
                        RestrictedClassType(
                            base_type=six.text_type,
                            restriction_dict={
                                "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                            },
                        ),
                    ]
                ),
                is_leaf=False,
                yang_name="fixed-ip-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:ip-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """fixed_ip_address must be of a type compatible with inet:ip-address""",
                    "defined-type": "inet:ip-address",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="fixed-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
                }
            )

        self.__fixed_ip_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_fixed_ip_address(self):
        self.__fixed_ip_address = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ]
            ),
            is_leaf=False,
            yang_name="fixed-ip-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

    ip_address_type = __builtin__.property(_get_ip_address_type, _set_ip_address_type)
    number_of_ip_addresses = __builtin__.property(
        _get_number_of_ip_addresses, _set_number_of_ip_addresses
    )
    ip_address_assignment = __builtin__.property(
        _get_ip_address_assignment, _set_ip_address_assignment
    )
    floating_ip_activated = __builtin__.property(
        _get_floating_ip_activated, _set_floating_ip_activated
    )
    fixed_ip_address = __builtin__.property(
        _get_fixed_ip_address, _set_fixed_ip_address
    )

    _pyangbind_elements = OrderedDict(
        [
            ("ip_address_type", ip_address_type),
            ("number_of_ip_addresses", number_of_ip_addresses),
            ("ip_address_assignment", ip_address_assignment),
            ("floating_ip_activated", floating_ip_activated),
            ("fixed_ip_address", fixed_ip_address),
        ]
    )


class yc_address_data_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol_address_data(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/ext-cpd/cp-protocol/address-data. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Provides information on the addresses to be assigned to the CP(s) instantiated from this CPD.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__address_type",
        "__l2_address_data",
        "__l3_address_data",
    )

    _yang_name = "address-data"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__address_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"MAC_ADDRESS": {}, "IP_ADDRESS": {}},
            ),
            is_leaf=True,
            yang_name="address-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__l2_address_data = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_dict={"pattern": "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}"},
            ),
            is_leaf=True,
            yang_name="l2-address-data",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="yang:mac-address",
            is_config=True,
        )
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol_address_data_l3_address_data,
            is_container="container",
            yang_name="l3-address-data",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "ext-cpd", "cp-protocol", "address-data"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/id (string)

        YANG Description: Identifier of this address data information element.
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Identifier of this address data information element.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_address_type(self):
        """
        Getter method for address_type, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/address_type (enumeration)

        YANG Description: Describes the type of the address to be assigned to the CP instantiated from this CPD.
        """
        return self.__address_type

    def _set_address_type(self, v, load=False):
        """
        Setter method for address_type, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/address_type (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_address_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_address_type() directly.

        YANG Description: Describes the type of the address to be assigned to the CP instantiated from this CPD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={"MAC_ADDRESS": {}, "IP_ADDRESS": {}},
                ),
                is_leaf=True,
                yang_name="address-type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """address_type must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MAC_ADDRESS': {}, 'IP_ADDRESS': {}},), is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__address_type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_address_type(self):
        self.__address_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"MAC_ADDRESS": {}, "IP_ADDRESS": {}},
            ),
            is_leaf=True,
            yang_name="address-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_l2_address_data(self):
        """
        Getter method for l2_address_data, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l2_address_data (yang:mac-address)

        YANG Description: Specifies the L2 address to be assigned to the CP instantiated from this CPD.
        """
        return self.__l2_address_data

    def _set_l2_address_data(self, v, load=False):
        """
        Setter method for l2_address_data, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l2_address_data (yang:mac-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_l2_address_data is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_l2_address_data() directly.

        YANG Description: Specifies the L2 address to be assigned to the CP instantiated from this CPD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={"pattern": "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}"},
                ),
                is_leaf=True,
                yang_name="l2-address-data",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="yang:mac-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """l2_address_data must be of a type compatible with yang:mac-address""",
                    "defined-type": "yang:mac-address",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="l2-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)""",
                }
            )

        self.__l2_address_data = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_l2_address_data(self):
        self.__l2_address_data = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_dict={"pattern": "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}"},
            ),
            is_leaf=True,
            yang_name="l2-address-data",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="yang:mac-address",
            is_config=True,
        )

    def _get_l3_address_data(self):
        """
        Getter method for l3_address_data, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data (container)

        YANG Description: The L3 address data for the CP instantiated from this CPD.
        """
        return self.__l3_address_data

    def _set_l3_address_data(self, v, load=False):
        """
        Setter method for l3_address_data, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data/l3_address_data (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_l3_address_data is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_l3_address_data() directly.

        YANG Description: The L3 address data for the CP instantiated from this CPD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_l3_address_data_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol_address_data_l3_address_data,
                is_container="container",
                yang_name="l3-address-data",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """l3_address_data must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_l3_address_data_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol_address_data_l3_address_data, is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__l3_address_data = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_l3_address_data(self):
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol_address_data_l3_address_data,
            is_container="container",
            yang_name="l3-address-data",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    address_type = __builtin__.property(_get_address_type, _set_address_type)
    l2_address_data = __builtin__.property(_get_l2_address_data, _set_l2_address_data)
    l3_address_data = __builtin__.property(_get_l3_address_data, _set_l3_address_data)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("address_type", address_type),
            ("l2_address_data", l2_address_data),
            ("l3_address_data", l3_address_data),
        ]
    )


class yc_cp_protocol_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/ext-cpd/cp-protocol. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__associated_layer_protocol",
        "__address_data",
    )

    _yang_name = "cp-protocol"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "ETHERNET": {"value": 0},
                    "MPLS": {"value": 1},
                    "ODU2": {"value": 2},
                    "IPV4": {"value": 3},
                    "IPV6": {"value": 4},
                    "PSEUDO_WIRE": {"value": 5},
                },
            ),
            is_leaf=True,
            yang_name="associated-layer-protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="layer-protocol-type",
            is_config=True,
        )
        self.__address_data = YANGDynClass(
            base=YANGListType(
                "id",
                yc_address_data_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol_address_data,
                yang_name="address-data",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="address-data",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "ext-cpd", "cp-protocol"]

    def _get_associated_layer_protocol(self):
        """
        Getter method for associated_layer_protocol, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/associated_layer_protocol (layer-protocol-type)

        YANG Description: Identifies the layer protocol associated with the CP.
        """
        return self.__associated_layer_protocol

    def _set_associated_layer_protocol(self, v, load=False):
        """
        Setter method for associated_layer_protocol, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/associated_layer_protocol (layer-protocol-type)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_associated_layer_protocol is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_associated_layer_protocol() directly.

        YANG Description: Identifies the layer protocol associated with the CP.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "ETHERNET": {"value": 0},
                        "MPLS": {"value": 1},
                        "ODU2": {"value": 2},
                        "IPV4": {"value": 3},
                        "IPV6": {"value": 4},
                        "PSEUDO_WIRE": {"value": 5},
                    },
                ),
                is_leaf=True,
                yang_name="associated-layer-protocol",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="layer-protocol-type",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """associated_layer_protocol must be of a type compatible with layer-protocol-type""",
                    "defined-type": "mec-app-descriptor:layer-protocol-type",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ETHERNET': {'value': 0}, 'MPLS': {'value': 1}, 'ODU2': {'value': 2}, 'IPV4': {'value': 3}, 'IPV6': {'value': 4}, 'PSEUDO_WIRE': {'value': 5}},), is_leaf=True, yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='layer-protocol-type', is_config=True)""",
                }
            )

        self.__associated_layer_protocol = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_associated_layer_protocol(self):
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "ETHERNET": {"value": 0},
                    "MPLS": {"value": 1},
                    "ODU2": {"value": 2},
                    "IPV4": {"value": 3},
                    "IPV6": {"value": 4},
                    "PSEUDO_WIRE": {"value": 5},
                },
            ),
            is_leaf=True,
            yang_name="associated-layer-protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="layer-protocol-type",
            is_config=True,
        )

    def _get_address_data(self):
        """
        Getter method for address_data, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data (list)

        YANG Description: Provides information on the addresses to be assigned to the CP(s) instantiated from this CPD.
        """
        return self.__address_data

    def _set_address_data(self, v, load=False):
        """
        Setter method for address_data, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol/address_data (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_address_data is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_address_data() directly.

        YANG Description: Provides information on the addresses to be assigned to the CP(s) instantiated from this CPD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_address_data_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol_address_data,
                    yang_name="address-data",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="address-data",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """address_data must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_address_data_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol_address_data, yang_name="address-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__address_data = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_address_data(self):
        self.__address_data = YANGDynClass(
            base=YANGListType(
                "id",
                yc_address_data_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol_address_data,
                yang_name="address-data",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="address-data",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    associated_layer_protocol = __builtin__.property(
        _get_associated_layer_protocol, _set_associated_layer_protocol
    )
    address_data = __builtin__.property(_get_address_data, _set_address_data)

    _pyangbind_elements = OrderedDict(
        [
            ("associated_layer_protocol", associated_layer_protocol),
            ("address_data", address_data),
        ]
    )


class yc_ext_cpd_mec_app_descriptor__mec_appd_ext_cpd(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/ext-cpd. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes external interface(s) exposed by this MEC application.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__virtual_network_interface_requirements",
        "__id",
        "__k8s_cluster_net",
        "__layer_protocol",
        "__cp_role",
        "__description",
        "__trunk_mode",
        "__security_group_rule_id",
        "__cp_protocol",
    )

    _yang_name = "ext-cpd"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__virtual_network_interface_requirements = YANGDynClass(
            base=YANGListType(
                "id",
                yc_virtual_network_interface_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements,
                yang_name="virtual-network-interface-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="virtual-network-interface-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__k8s_cluster_net = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="k8s-cluster-net",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__layer_protocol = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "ETHERNET": {"value": 0},
                        "MPLS": {"value": 1},
                        "ODU2": {"value": 2},
                        "IPV4": {"value": 3},
                        "IPV6": {"value": 4},
                        "PSEUDO_WIRE": {"value": 5},
                    },
                )
            ),
            is_leaf=False,
            yang_name="layer-protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="layer-protocol-type",
            is_config=True,
        )
        self.__cp_role = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="cp-role",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__trunk_mode = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="trunk-mode",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )
        self.__security_group_rule_id = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="security-group-rule-id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__cp_protocol = YANGDynClass(
            base=YANGListType(
                "associated_layer_protocol",
                yc_cp_protocol_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol,
                yang_name="cp-protocol",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="associated-layer-protocol",
                extensions=None,
            ),
            is_container="list",
            yang_name="cp-protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "ext-cpd"]

    def _get_virtual_network_interface_requirements(self):
        """
        Getter method for virtual_network_interface_requirements, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements (list)

        YANG Description: Specifies requirements on a virtual network interface realizing the CPs instantiated from this CPD.
        """
        return self.__virtual_network_interface_requirements

    def _set_virtual_network_interface_requirements(self, v, load=False):
        """
        Setter method for virtual_network_interface_requirements, mapped from YANG variable /mec_appd/ext_cpd/virtual_network_interface_requirements (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_virtual_network_interface_requirements is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_virtual_network_interface_requirements() directly.

        YANG Description: Specifies requirements on a virtual network interface realizing the CPs instantiated from this CPD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_virtual_network_interface_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements,
                    yang_name="virtual-network-interface-requirements",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="virtual-network-interface-requirements",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """virtual_network_interface_requirements must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_virtual_network_interface_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements, yang_name="virtual-network-interface-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-network-interface-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__virtual_network_interface_requirements = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_virtual_network_interface_requirements(self):
        self.__virtual_network_interface_requirements = YANGDynClass(
            base=YANGListType(
                "id",
                yc_virtual_network_interface_requirements_mec_app_descriptor__mec_appd_ext_cpd_virtual_network_interface_requirements,
                yang_name="virtual-network-interface-requirements",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="virtual-network-interface-requirements",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/ext_cpd/id (string)

        YANG Description: Identifier of this Cpd information element.
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/ext_cpd/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Identifier of this Cpd information element.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_k8s_cluster_net(self):
        """
        Getter method for k8s_cluster_net, mapped from YANG variable /mec_appd/ext_cpd/k8s_cluster_net (string)

        YANG Description: K8s cluster network
        """
        return self.__k8s_cluster_net

    def _set_k8s_cluster_net(self, v, load=False):
        """
        Setter method for k8s_cluster_net, mapped from YANG variable /mec_appd/ext_cpd/k8s_cluster_net (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_k8s_cluster_net is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_k8s_cluster_net() directly.

        YANG Description: K8s cluster network
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="k8s-cluster-net",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """k8s_cluster_net must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="k8s-cluster-net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__k8s_cluster_net = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_k8s_cluster_net(self):
        self.__k8s_cluster_net = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="k8s-cluster-net",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_layer_protocol(self):
        """
        Getter method for layer_protocol, mapped from YANG variable /mec_appd/ext_cpd/layer_protocol (layer-protocol-type)

        YANG Description: Identifies which protocol the CP uses for connectivity purposes.
        """
        return self.__layer_protocol

    def _set_layer_protocol(self, v, load=False):
        """
        Setter method for layer_protocol, mapped from YANG variable /mec_appd/ext_cpd/layer_protocol (layer-protocol-type)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_layer_protocol is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_layer_protocol() directly.

        YANG Description: Identifies which protocol the CP uses for connectivity purposes.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={
                            "ETHERNET": {"value": 0},
                            "MPLS": {"value": 1},
                            "ODU2": {"value": 2},
                            "IPV4": {"value": 3},
                            "IPV6": {"value": 4},
                            "PSEUDO_WIRE": {"value": 5},
                        },
                    )
                ),
                is_leaf=False,
                yang_name="layer-protocol",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="layer-protocol-type",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """layer_protocol must be of a type compatible with layer-protocol-type""",
                    "defined-type": "mec-app-descriptor:layer-protocol-type",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ETHERNET': {'value': 0}, 'MPLS': {'value': 1}, 'ODU2': {'value': 2}, 'IPV4': {'value': 3}, 'IPV6': {'value': 4}, 'PSEUDO_WIRE': {'value': 5}},)), is_leaf=False, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='layer-protocol-type', is_config=True)""",
                }
            )

        self.__layer_protocol = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_layer_protocol(self):
        self.__layer_protocol = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "ETHERNET": {"value": 0},
                        "MPLS": {"value": 1},
                        "ODU2": {"value": 2},
                        "IPV4": {"value": 3},
                        "IPV6": {"value": 4},
                        "PSEUDO_WIRE": {"value": 5},
                    },
                )
            ),
            is_leaf=False,
            yang_name="layer-protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="layer-protocol-type",
            is_config=True,
        )

    def _get_cp_role(self):
        """
        Getter method for cp_role, mapped from YANG variable /mec_appd/ext_cpd/cp_role (string)

        YANG Description: Identifies the role of the CP in the context of the traffic flow patterns in the VNF or parent NS.
        """
        return self.__cp_role

    def _set_cp_role(self, v, load=False):
        """
        Setter method for cp_role, mapped from YANG variable /mec_appd/ext_cpd/cp_role (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_cp_role is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_cp_role() directly.

        YANG Description: Identifies the role of the CP in the context of the traffic flow patterns in the VNF or parent NS.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="cp-role",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """cp_role must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__cp_role = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_cp_role(self):
        self.__cp_role = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="cp-role",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_description(self):
        """
        Getter method for description, mapped from YANG variable /mec_appd/ext_cpd/description (string)

        YANG Description: Provides human-readable information on the purpose of the CP.
        """
        return self.__description

    def _set_description(self, v, load=False):
        """
        Setter method for description, mapped from YANG variable /mec_appd/ext_cpd/description (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_description is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_description() directly.

        YANG Description: Provides human-readable information on the purpose of the CP.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="description",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """description must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__description = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_trunk_mode(self):
        """
        Getter method for trunk_mode, mapped from YANG variable /mec_appd/ext_cpd/trunk_mode (boolean)

        YANG Description: Specifies whether the CP is a trunk port (true) or not (false).
        """
        return self.__trunk_mode

    def _set_trunk_mode(self, v, load=False):
        """
        Setter method for trunk_mode, mapped from YANG variable /mec_appd/ext_cpd/trunk_mode (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_trunk_mode is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_trunk_mode() directly.

        YANG Description: Specifies whether the CP is a trunk port (true) or not (false).
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                is_leaf=True,
                yang_name="trunk-mode",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """trunk_mode must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__trunk_mode = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_trunk_mode(self):
        self.__trunk_mode = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="trunk-mode",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    def _get_security_group_rule_id(self):
        """
        Getter method for security_group_rule_id, mapped from YANG variable /mec_appd/ext_cpd/security_group_rule_id (string)

        YANG Description: Identifies the security group rules bound to the CP.
        """
        return self.__security_group_rule_id

    def _set_security_group_rule_id(self, v, load=False):
        """
        Setter method for security_group_rule_id, mapped from YANG variable /mec_appd/ext_cpd/security_group_rule_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_security_group_rule_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_security_group_rule_id() directly.

        YANG Description: Identifies the security group rules bound to the CP.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="security-group-rule-id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """security_group_rule_id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="security-group-rule-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__security_group_rule_id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_security_group_rule_id(self):
        self.__security_group_rule_id = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="security-group-rule-id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_cp_protocol(self):
        """
        Getter method for cp_protocol, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol (list)
        """
        return self.__cp_protocol

    def _set_cp_protocol(self, v, load=False):
        """
        Setter method for cp_protocol, mapped from YANG variable /mec_appd/ext_cpd/cp_protocol (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_cp_protocol is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_cp_protocol() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "associated_layer_protocol",
                    yc_cp_protocol_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol,
                    yang_name="cp-protocol",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="associated-layer-protocol",
                    extensions=None,
                ),
                is_container="list",
                yang_name="cp-protocol",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """cp_protocol must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("associated_layer_protocol",yc_cp_protocol_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol, yang_name="cp-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None), is_container='list', yang_name="cp-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__cp_protocol = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_cp_protocol(self):
        self.__cp_protocol = YANGDynClass(
            base=YANGListType(
                "associated_layer_protocol",
                yc_cp_protocol_mec_app_descriptor__mec_appd_ext_cpd_cp_protocol,
                yang_name="cp-protocol",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="associated-layer-protocol",
                extensions=None,
            ),
            is_container="list",
            yang_name="cp-protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    virtual_network_interface_requirements = __builtin__.property(
        _get_virtual_network_interface_requirements,
        _set_virtual_network_interface_requirements,
    )
    id = __builtin__.property(_get_id, _set_id)
    k8s_cluster_net = __builtin__.property(_get_k8s_cluster_net, _set_k8s_cluster_net)
    layer_protocol = __builtin__.property(_get_layer_protocol, _set_layer_protocol)
    cp_role = __builtin__.property(_get_cp_role, _set_cp_role)
    description = __builtin__.property(_get_description, _set_description)
    trunk_mode = __builtin__.property(_get_trunk_mode, _set_trunk_mode)
    security_group_rule_id = __builtin__.property(
        _get_security_group_rule_id, _set_security_group_rule_id
    )
    cp_protocol = __builtin__.property(_get_cp_protocol, _set_cp_protocol)

    _pyangbind_elements = OrderedDict(
        [
            (
                "virtual_network_interface_requirements",
                virtual_network_interface_requirements,
            ),
            ("id", id),
            ("k8s_cluster_net", k8s_cluster_net),
            ("layer_protocol", layer_protocol),
            ("cp_role", cp_role),
            ("description", description),
            ("trunk_mode", trunk_mode),
            ("security_group_rule_id", security_group_rule_id),
            ("cp_protocol", cp_protocol),
        ]
    )


class yc_oauth2_info_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport_security_oauth2_info(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-required/transport-dependencies/transport/security/oauth2-info. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about OAuth2 based security
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__grant_types",
        "__token_endpoint",
    )

    _yang_name = "oauth2-info"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__grant_types = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "OAUTH2_AUTHORIZATION_CODE": {},
                        "OAUTH2_IMPLICIT_GRANT": {},
                        "OAUTH2_RESOURCE_OWNER": {},
                        "OAUTH2_CLIENT_CREDENTIALS": {},
                    },
                )
            ),
            is_leaf=False,
            yang_name="grant-types",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__token_endpoint = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="token-endpoint",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:uri",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "service-required",
                "transport-dependencies",
                "transport",
                "security",
                "oauth2-info",
            ]

    def _get_grant_types(self):
        """
        Getter method for grant_types, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)

        YANG Description: Supported OAuth2 grant types
        """
        return self.__grant_types

    def _set_grant_types(self, v, load=False):
        """
        Setter method for grant_types, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_grant_types is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_grant_types() directly.

        YANG Description: Supported OAuth2 grant types
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={
                            "OAUTH2_AUTHORIZATION_CODE": {},
                            "OAUTH2_IMPLICIT_GRANT": {},
                            "OAUTH2_RESOURCE_OWNER": {},
                            "OAUTH2_CLIENT_CREDENTIALS": {},
                        },
                    )
                ),
                is_leaf=False,
                yang_name="grant-types",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """grant_types must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__grant_types = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_grant_types(self):
        self.__grant_types = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "OAUTH2_AUTHORIZATION_CODE": {},
                        "OAUTH2_IMPLICIT_GRANT": {},
                        "OAUTH2_RESOURCE_OWNER": {},
                        "OAUTH2_CLIENT_CREDENTIALS": {},
                    },
                )
            ),
            is_leaf=False,
            yang_name="grant-types",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_token_endpoint(self):
        """
        Getter method for token_endpoint, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)

        YANG Description: The token endpoint
        """
        return self.__token_endpoint

    def _set_token_endpoint(self, v, load=False):
        """
        Setter method for token_endpoint, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_token_endpoint is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_token_endpoint() directly.

        YANG Description: The token endpoint
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="token-endpoint",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:uri",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """token_endpoint must be of a type compatible with inet:uri""",
                    "defined-type": "inet:uri",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
                }
            )

        self.__token_endpoint = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_token_endpoint(self):
        self.__token_endpoint = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="token-endpoint",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:uri",
            is_config=True,
        )

    grant_types = __builtin__.property(_get_grant_types, _set_grant_types)
    token_endpoint = __builtin__.property(_get_token_endpoint, _set_token_endpoint)

    _pyangbind_elements = OrderedDict(
        [
            ("grant_types", grant_types),
            ("token_endpoint", token_endpoint),
        ]
    )


class yc_security_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport_security(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-required/transport-dependencies/transport/security. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about the security used by the transport
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__oauth2_info",
    )

    _yang_name = "security"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__oauth2_info = YANGDynClass(
            base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport_security_oauth2_info,
            is_container="container",
            yang_name="oauth2-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "service-required",
                "transport-dependencies",
                "transport",
                "security",
            ]

    def _get_oauth2_info(self):
        """
        Getter method for oauth2_info, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/security/oauth2_info (container)

        YANG Description: Information about OAuth2 based security
        """
        return self.__oauth2_info

    def _set_oauth2_info(self, v, load=False):
        """
        Setter method for oauth2_info, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/security/oauth2_info (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_oauth2_info is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_oauth2_info() directly.

        YANG Description: Information about OAuth2 based security
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport_security_oauth2_info,
                is_container="container",
                yang_name="oauth2-info",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """oauth2_info must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__oauth2_info = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_oauth2_info(self):
        self.__oauth2_info = YANGDynClass(
            base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport_security_oauth2_info,
            is_container="container",
            yang_name="oauth2-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    oauth2_info = __builtin__.property(_get_oauth2_info, _set_oauth2_info)

    _pyangbind_elements = OrderedDict(
        [
            ("oauth2_info", oauth2_info),
        ]
    )


class yc_transport_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-required/transport-dependencies/transport. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about the transport in this transport binding
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__name",
        "__description",
        "__type",
        "__protocol",
        "__version",
        "__security",
    )

    _yang_name = "transport"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "REST_HTTP": {},
                    "MB_TOPIC_BASED": {},
                    "MB_ROUTING": {},
                    "MB_PUBSUB": {},
                    "RPC": {},
                    "RPC_STREAMING": {},
                    "WEBSOCKET": {},
                },
            ),
            is_leaf=True,
            yang_name="type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="transport-type",
            is_config=True,
        )
        self.__protocol = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__security = YANGDynClass(
            base=yc_security_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport_security,
            is_container="container",
            yang_name="security",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "service-required",
                "transport-dependencies",
                "transport",
            ]

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/name (string)

        YANG Description: The name of this transport
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The name of this transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_description(self):
        """
        Getter method for description, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/description (string)

        YANG Description: Human-readable description of this transport
        """
        return self.__description

    def _set_description(self, v, load=False):
        """
        Setter method for description, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/description (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_description is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_description() directly.

        YANG Description: Human-readable description of this transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="description",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """description must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__description = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_type(self):
        """
        Getter method for type, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/type (transport-type)

        YANG Description: Type of the transport
        """
        return self.__type

    def _set_type(self, v, load=False):
        """
        Setter method for type, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/type (transport-type)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_type() directly.

        YANG Description: Type of the transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "REST_HTTP": {},
                        "MB_TOPIC_BASED": {},
                        "MB_ROUTING": {},
                        "MB_PUBSUB": {},
                        "RPC": {},
                        "RPC_STREAMING": {},
                        "WEBSOCKET": {},
                    },
                ),
                is_leaf=True,
                yang_name="type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="transport-type",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """type must be of a type compatible with transport-type""",
                    "defined-type": "mec-app-descriptor:transport-type",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)""",
                }
            )

        self.__type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "REST_HTTP": {},
                    "MB_TOPIC_BASED": {},
                    "MB_ROUTING": {},
                    "MB_PUBSUB": {},
                    "RPC": {},
                    "RPC_STREAMING": {},
                    "WEBSOCKET": {},
                },
            ),
            is_leaf=True,
            yang_name="type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="transport-type",
            is_config=True,
        )

    def _get_protocol(self):
        """
        Getter method for protocol, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/protocol (string)

        YANG Description: The name of the protocol used
        """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
        Setter method for protocol, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/protocol (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_protocol is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_protocol() directly.

        YANG Description: The name of the protocol used
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="protocol",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """protocol must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__protocol = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/version (string)

        YANG Description: The version of the protocol used
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: The version of the protocol used
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_security(self):
        """
        Getter method for security, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/security (container)

        YANG Description: Information about the security used by the transport
        """
        return self.__security

    def _set_security(self, v, load=False):
        """
        Setter method for security, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport/security (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_security is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_security() directly.

        YANG Description: Information about the security used by the transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_security_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport_security,
                is_container="container",
                yang_name="security",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """security must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_security_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__security = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_security(self):
        self.__security = YANGDynClass(
            base=yc_security_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport_security,
            is_container="container",
            yang_name="security",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    type = __builtin__.property(_get_type, _set_type)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    version = __builtin__.property(_get_version, _set_version)
    security = __builtin__.property(_get_security, _set_security)

    _pyangbind_elements = OrderedDict(
        [
            ("name", name),
            ("description", description),
            ("type", type),
            ("protocol", protocol),
            ("version", version),
            ("security", security),
        ]
    )


class yc_transport_dependencies_mec_app_descriptor__mec_appd_service_required_transport_dependencies(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-required/transport-dependencies. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__transport",
        "__serializers",
        "__labels",
    )

    _yang_name = "transport-dependencies"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__transport = YANGDynClass(
            base=yc_transport_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport,
            is_container="container",
            yang_name="transport",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__serializers = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "JSON": {"value": 0},
                        "XML": {"value": 1},
                        "PROTOBUF3": {"value": 2},
                    },
                )
            ),
            is_leaf=False,
            yang_name="serializers",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="serializer-type",
            is_config=True,
        )
        self.__labels = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="labels",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "service-required", "transport-dependencies"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/service_required/transport_dependencies/id (string)

        YANG Description: Unique identifier for the transport dependency
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/service_required/transport_dependencies/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier for the transport dependency
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_transport(self):
        """
        Getter method for transport, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport (container)

        YANG Description: Information about the transport in this transport binding
        """
        return self.__transport

    def _set_transport(self, v, load=False):
        """
        Setter method for transport, mapped from YANG variable /mec_appd/service_required/transport_dependencies/transport (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transport is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transport() directly.

        YANG Description: Information about the transport in this transport binding
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_transport_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport,
                is_container="container",
                yang_name="transport",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """transport must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_transport_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__transport = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_transport(self):
        self.__transport = YANGDynClass(
            base=yc_transport_mec_app_descriptor__mec_appd_service_required_transport_dependencies_transport,
            is_container="container",
            yang_name="transport",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_serializers(self):
        """
        Getter method for serializers, mapped from YANG variable /mec_appd/service_required/transport_dependencies/serializers (serializer-type)

        YANG Description: Type of serializers used in this transport binding
        """
        return self.__serializers

    def _set_serializers(self, v, load=False):
        """
        Setter method for serializers, mapped from YANG variable /mec_appd/service_required/transport_dependencies/serializers (serializer-type)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_serializers is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_serializers() directly.

        YANG Description: Type of serializers used in this transport binding
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={
                            "JSON": {"value": 0},
                            "XML": {"value": 1},
                            "PROTOBUF3": {"value": 2},
                        },
                    )
                ),
                is_leaf=False,
                yang_name="serializers",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="serializer-type",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """serializers must be of a type compatible with serializer-type""",
                    "defined-type": "mec-app-descriptor:serializer-type",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)""",
                }
            )

        self.__serializers = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_serializers(self):
        self.__serializers = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "JSON": {"value": 0},
                        "XML": {"value": 1},
                        "PROTOBUF3": {"value": 2},
                    },
                )
            ),
            is_leaf=False,
            yang_name="serializers",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="serializer-type",
            is_config=True,
        )

    def _get_labels(self):
        """
        Getter method for labels, mapped from YANG variable /mec_appd/service_required/transport_dependencies/labels (string)

        YANG Description: Set of labels that allow to define groups of transport bindings
        """
        return self.__labels

    def _set_labels(self, v, load=False):
        """
        Setter method for labels, mapped from YANG variable /mec_appd/service_required/transport_dependencies/labels (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_labels is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_labels() directly.

        YANG Description: Set of labels that allow to define groups of transport bindings
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="labels",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """labels must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__labels = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_labels(self):
        self.__labels = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="labels",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    transport = __builtin__.property(_get_transport, _set_transport)
    serializers = __builtin__.property(_get_serializers, _set_serializers)
    labels = __builtin__.property(_get_labels, _set_labels)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("transport", transport),
            ("serializers", serializers),
            ("labels", labels),
        ]
    )


class yc_category_mec_app_descriptor__mec_appd_service_required_category(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-required/category. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: A Category reference of the service
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__href",
        "__id",
        "__name",
        "__version",
    )

    _yang_name = "category"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__href = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="href",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "service-required", "category"]

    def _get_href(self):
        """
        Getter method for href, mapped from YANG variable /mec_appd/service_required/category/href (string)

        YANG Description: Reference of the catalogue
        """
        return self.__href

    def _set_href(self, v, load=False):
        """
        Setter method for href, mapped from YANG variable /mec_appd/service_required/category/href (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_href is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_href() directly.

        YANG Description: Reference of the catalogue
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="href",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """href must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__href = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_href(self):
        self.__href = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="href",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/service_required/category/id (string)

        YANG Description: Unique identifier of the category
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/service_required/category/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier of the category
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/service_required/category/name (string)

        YANG Description: Name of the category
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/service_required/category/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: Name of the category
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/service_required/category/version (string)

        YANG Description: Category version
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/service_required/category/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: Category version
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    href = __builtin__.property(_get_href, _set_href)
    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    version = __builtin__.property(_get_version, _set_version)

    _pyangbind_elements = OrderedDict(
        [
            ("href", href),
            ("id", id),
            ("name", name),
            ("version", version),
        ]
    )


class yc_service_required_mec_app_descriptor__mec_appd_service_required(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-required. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes services a MEC application requires to run
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__transport_dependencies",
        "__requested_permissions",
        "__name",
        "__category",
        "__version",
    )

    _yang_name = "service-required"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__transport_dependencies = YANGDynClass(
            base=YANGListType(
                "id",
                yc_transport_dependencies_mec_app_descriptor__mec_appd_service_required_transport_dependencies,
                yang_name="transport-dependencies",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="transport-dependencies",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__requested_permissions = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="requested-permissions",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__category = YANGDynClass(
            base=yc_category_mec_app_descriptor__mec_appd_service_required_category,
            is_container="container",
            yang_name="category",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "service-required"]

    def _get_transport_dependencies(self):
        """
        Getter method for transport_dependencies, mapped from YANG variable /mec_appd/service_required/transport_dependencies (list)

        YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
        """
        return self.__transport_dependencies

    def _set_transport_dependencies(self, v, load=False):
        """
        Setter method for transport_dependencies, mapped from YANG variable /mec_appd/service_required/transport_dependencies (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transport_dependencies is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transport_dependencies() directly.

        YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_transport_dependencies_mec_app_descriptor__mec_appd_service_required_transport_dependencies,
                    yang_name="transport-dependencies",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="transport-dependencies",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """transport_dependencies must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__mec_appd_service_required_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__transport_dependencies = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_transport_dependencies(self):
        self.__transport_dependencies = YANGDynClass(
            base=YANGListType(
                "id",
                yc_transport_dependencies_mec_app_descriptor__mec_appd_service_required_transport_dependencies,
                yang_name="transport-dependencies",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="transport-dependencies",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_requested_permissions(self):
        """
        Getter method for requested_permissions, mapped from YANG variable /mec_appd/service_required/requested_permissions (string)

        YANG Description: Requested permissions regarding the access of the application to the service. The format is left for the data model design stage.
        """
        return self.__requested_permissions

    def _set_requested_permissions(self, v, load=False):
        """
        Setter method for requested_permissions, mapped from YANG variable /mec_appd/service_required/requested_permissions (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_requested_permissions is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_requested_permissions() directly.

        YANG Description: Requested permissions regarding the access of the application to the service. The format is left for the data model design stage.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="requested-permissions",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """requested_permissions must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requested-permissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__requested_permissions = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_requested_permissions(self):
        self.__requested_permissions = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="requested-permissions",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/service_required/name (string)

        YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/service_required/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_category(self):
        """
        Getter method for category, mapped from YANG variable /mec_appd/service_required/category (container)

        YANG Description: A Category reference of the service
        """
        return self.__category

    def _set_category(self, v, load=False):
        """
        Setter method for category, mapped from YANG variable /mec_appd/service_required/category (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_category is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_category() directly.

        YANG Description: A Category reference of the service
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_category_mec_app_descriptor__mec_appd_service_required_category,
                is_container="container",
                yang_name="category",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """category must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_category_mec_app_descriptor__mec_appd_service_required_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__category = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_category(self):
        self.__category = YANGDynClass(
            base=yc_category_mec_app_descriptor__mec_appd_service_required_category,
            is_container="container",
            yang_name="category",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/service_required/version (string)

        YANG Description: The version of the service
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/service_required/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: The version of the service
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    transport_dependencies = __builtin__.property(
        _get_transport_dependencies, _set_transport_dependencies
    )
    requested_permissions = __builtin__.property(
        _get_requested_permissions, _set_requested_permissions
    )
    name = __builtin__.property(_get_name, _set_name)
    category = __builtin__.property(_get_category, _set_category)
    version = __builtin__.property(_get_version, _set_version)

    _pyangbind_elements = OrderedDict(
        [
            ("transport_dependencies", transport_dependencies),
            ("requested_permissions", requested_permissions),
            ("name", name),
            ("category", category),
            ("version", version),
        ]
    )


class yc_oauth2_info_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport_security_oauth2_info(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-optional/transport-dependencies/transport/security/oauth2-info. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about OAuth2 based security
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__grant_types",
        "__token_endpoint",
    )

    _yang_name = "oauth2-info"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__grant_types = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "OAUTH2_AUTHORIZATION_CODE": {},
                        "OAUTH2_IMPLICIT_GRANT": {},
                        "OAUTH2_RESOURCE_OWNER": {},
                        "OAUTH2_CLIENT_CREDENTIALS": {},
                    },
                )
            ),
            is_leaf=False,
            yang_name="grant-types",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__token_endpoint = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="token-endpoint",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:uri",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "service-optional",
                "transport-dependencies",
                "transport",
                "security",
                "oauth2-info",
            ]

    def _get_grant_types(self):
        """
        Getter method for grant_types, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)

        YANG Description: Supported OAuth2 grant types
        """
        return self.__grant_types

    def _set_grant_types(self, v, load=False):
        """
        Setter method for grant_types, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_grant_types is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_grant_types() directly.

        YANG Description: Supported OAuth2 grant types
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={
                            "OAUTH2_AUTHORIZATION_CODE": {},
                            "OAUTH2_IMPLICIT_GRANT": {},
                            "OAUTH2_RESOURCE_OWNER": {},
                            "OAUTH2_CLIENT_CREDENTIALS": {},
                        },
                    )
                ),
                is_leaf=False,
                yang_name="grant-types",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """grant_types must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__grant_types = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_grant_types(self):
        self.__grant_types = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "OAUTH2_AUTHORIZATION_CODE": {},
                        "OAUTH2_IMPLICIT_GRANT": {},
                        "OAUTH2_RESOURCE_OWNER": {},
                        "OAUTH2_CLIENT_CREDENTIALS": {},
                    },
                )
            ),
            is_leaf=False,
            yang_name="grant-types",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_token_endpoint(self):
        """
        Getter method for token_endpoint, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)

        YANG Description: The token endpoint
        """
        return self.__token_endpoint

    def _set_token_endpoint(self, v, load=False):
        """
        Setter method for token_endpoint, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_token_endpoint is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_token_endpoint() directly.

        YANG Description: The token endpoint
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="token-endpoint",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:uri",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """token_endpoint must be of a type compatible with inet:uri""",
                    "defined-type": "inet:uri",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
                }
            )

        self.__token_endpoint = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_token_endpoint(self):
        self.__token_endpoint = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="token-endpoint",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:uri",
            is_config=True,
        )

    grant_types = __builtin__.property(_get_grant_types, _set_grant_types)
    token_endpoint = __builtin__.property(_get_token_endpoint, _set_token_endpoint)

    _pyangbind_elements = OrderedDict(
        [
            ("grant_types", grant_types),
            ("token_endpoint", token_endpoint),
        ]
    )


class yc_security_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport_security(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-optional/transport-dependencies/transport/security. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about the security used by the transport
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__oauth2_info",
    )

    _yang_name = "security"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__oauth2_info = YANGDynClass(
            base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport_security_oauth2_info,
            is_container="container",
            yang_name="oauth2-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "service-optional",
                "transport-dependencies",
                "transport",
                "security",
            ]

    def _get_oauth2_info(self):
        """
        Getter method for oauth2_info, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/security/oauth2_info (container)

        YANG Description: Information about OAuth2 based security
        """
        return self.__oauth2_info

    def _set_oauth2_info(self, v, load=False):
        """
        Setter method for oauth2_info, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/security/oauth2_info (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_oauth2_info is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_oauth2_info() directly.

        YANG Description: Information about OAuth2 based security
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport_security_oauth2_info,
                is_container="container",
                yang_name="oauth2-info",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """oauth2_info must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__oauth2_info = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_oauth2_info(self):
        self.__oauth2_info = YANGDynClass(
            base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport_security_oauth2_info,
            is_container="container",
            yang_name="oauth2-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    oauth2_info = __builtin__.property(_get_oauth2_info, _set_oauth2_info)

    _pyangbind_elements = OrderedDict(
        [
            ("oauth2_info", oauth2_info),
        ]
    )


class yc_transport_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-optional/transport-dependencies/transport. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about the transport in this transport binding
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__name",
        "__description",
        "__type",
        "__protocol",
        "__version",
        "__security",
    )

    _yang_name = "transport"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "REST_HTTP": {},
                    "MB_TOPIC_BASED": {},
                    "MB_ROUTING": {},
                    "MB_PUBSUB": {},
                    "RPC": {},
                    "RPC_STREAMING": {},
                    "WEBSOCKET": {},
                },
            ),
            is_leaf=True,
            yang_name="type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="transport-type",
            is_config=True,
        )
        self.__protocol = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__security = YANGDynClass(
            base=yc_security_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport_security,
            is_container="container",
            yang_name="security",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "service-optional",
                "transport-dependencies",
                "transport",
            ]

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/name (string)

        YANG Description: The name of this transport
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The name of this transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_description(self):
        """
        Getter method for description, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/description (string)

        YANG Description: Human-readable description of this transport
        """
        return self.__description

    def _set_description(self, v, load=False):
        """
        Setter method for description, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/description (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_description is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_description() directly.

        YANG Description: Human-readable description of this transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="description",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """description must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__description = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_type(self):
        """
        Getter method for type, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/type (transport-type)

        YANG Description: Type of the transport
        """
        return self.__type

    def _set_type(self, v, load=False):
        """
        Setter method for type, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/type (transport-type)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_type() directly.

        YANG Description: Type of the transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "REST_HTTP": {},
                        "MB_TOPIC_BASED": {},
                        "MB_ROUTING": {},
                        "MB_PUBSUB": {},
                        "RPC": {},
                        "RPC_STREAMING": {},
                        "WEBSOCKET": {},
                    },
                ),
                is_leaf=True,
                yang_name="type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="transport-type",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """type must be of a type compatible with transport-type""",
                    "defined-type": "mec-app-descriptor:transport-type",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)""",
                }
            )

        self.__type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "REST_HTTP": {},
                    "MB_TOPIC_BASED": {},
                    "MB_ROUTING": {},
                    "MB_PUBSUB": {},
                    "RPC": {},
                    "RPC_STREAMING": {},
                    "WEBSOCKET": {},
                },
            ),
            is_leaf=True,
            yang_name="type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="transport-type",
            is_config=True,
        )

    def _get_protocol(self):
        """
        Getter method for protocol, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/protocol (string)

        YANG Description: The name of the protocol used
        """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
        Setter method for protocol, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/protocol (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_protocol is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_protocol() directly.

        YANG Description: The name of the protocol used
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="protocol",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """protocol must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__protocol = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/version (string)

        YANG Description: The version of the protocol used
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: The version of the protocol used
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_security(self):
        """
        Getter method for security, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/security (container)

        YANG Description: Information about the security used by the transport
        """
        return self.__security

    def _set_security(self, v, load=False):
        """
        Setter method for security, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport/security (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_security is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_security() directly.

        YANG Description: Information about the security used by the transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_security_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport_security,
                is_container="container",
                yang_name="security",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """security must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_security_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__security = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_security(self):
        self.__security = YANGDynClass(
            base=yc_security_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport_security,
            is_container="container",
            yang_name="security",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    type = __builtin__.property(_get_type, _set_type)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    version = __builtin__.property(_get_version, _set_version)
    security = __builtin__.property(_get_security, _set_security)

    _pyangbind_elements = OrderedDict(
        [
            ("name", name),
            ("description", description),
            ("type", type),
            ("protocol", protocol),
            ("version", version),
            ("security", security),
        ]
    )


class yc_transport_dependencies_mec_app_descriptor__mec_appd_service_optional_transport_dependencies(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-optional/transport-dependencies. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__transport",
        "__serializers",
        "__labels",
    )

    _yang_name = "transport-dependencies"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__transport = YANGDynClass(
            base=yc_transport_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport,
            is_container="container",
            yang_name="transport",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__serializers = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "JSON": {"value": 0},
                        "XML": {"value": 1},
                        "PROTOBUF3": {"value": 2},
                    },
                )
            ),
            is_leaf=False,
            yang_name="serializers",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="serializer-type",
            is_config=True,
        )
        self.__labels = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="labels",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "service-optional", "transport-dependencies"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/id (string)

        YANG Description: Unique identifier for the transport dependency
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier for the transport dependency
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_transport(self):
        """
        Getter method for transport, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport (container)

        YANG Description: Information about the transport in this transport binding
        """
        return self.__transport

    def _set_transport(self, v, load=False):
        """
        Setter method for transport, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/transport (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transport is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transport() directly.

        YANG Description: Information about the transport in this transport binding
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_transport_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport,
                is_container="container",
                yang_name="transport",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """transport must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_transport_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__transport = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_transport(self):
        self.__transport = YANGDynClass(
            base=yc_transport_mec_app_descriptor__mec_appd_service_optional_transport_dependencies_transport,
            is_container="container",
            yang_name="transport",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_serializers(self):
        """
        Getter method for serializers, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/serializers (serializer-type)

        YANG Description: Type of serializers used in this transport binding
        """
        return self.__serializers

    def _set_serializers(self, v, load=False):
        """
        Setter method for serializers, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/serializers (serializer-type)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_serializers is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_serializers() directly.

        YANG Description: Type of serializers used in this transport binding
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={
                            "JSON": {"value": 0},
                            "XML": {"value": 1},
                            "PROTOBUF3": {"value": 2},
                        },
                    )
                ),
                is_leaf=False,
                yang_name="serializers",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="serializer-type",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """serializers must be of a type compatible with serializer-type""",
                    "defined-type": "mec-app-descriptor:serializer-type",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)""",
                }
            )

        self.__serializers = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_serializers(self):
        self.__serializers = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "JSON": {"value": 0},
                        "XML": {"value": 1},
                        "PROTOBUF3": {"value": 2},
                    },
                )
            ),
            is_leaf=False,
            yang_name="serializers",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="serializer-type",
            is_config=True,
        )

    def _get_labels(self):
        """
        Getter method for labels, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/labels (string)

        YANG Description: Set of labels that allow to define groups of transport bindings
        """
        return self.__labels

    def _set_labels(self, v, load=False):
        """
        Setter method for labels, mapped from YANG variable /mec_appd/service_optional/transport_dependencies/labels (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_labels is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_labels() directly.

        YANG Description: Set of labels that allow to define groups of transport bindings
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="labels",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """labels must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__labels = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_labels(self):
        self.__labels = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="labels",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    transport = __builtin__.property(_get_transport, _set_transport)
    serializers = __builtin__.property(_get_serializers, _set_serializers)
    labels = __builtin__.property(_get_labels, _set_labels)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("transport", transport),
            ("serializers", serializers),
            ("labels", labels),
        ]
    )


class yc_category_mec_app_descriptor__mec_appd_service_optional_category(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-optional/category. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: A Category reference of the service
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__href",
        "__id",
        "__name",
        "__version",
    )

    _yang_name = "category"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__href = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="href",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "service-optional", "category"]

    def _get_href(self):
        """
        Getter method for href, mapped from YANG variable /mec_appd/service_optional/category/href (string)

        YANG Description: Reference of the catalogue
        """
        return self.__href

    def _set_href(self, v, load=False):
        """
        Setter method for href, mapped from YANG variable /mec_appd/service_optional/category/href (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_href is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_href() directly.

        YANG Description: Reference of the catalogue
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="href",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """href must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__href = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_href(self):
        self.__href = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="href",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/service_optional/category/id (string)

        YANG Description: Unique identifier of the category
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/service_optional/category/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier of the category
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/service_optional/category/name (string)

        YANG Description: Name of the category
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/service_optional/category/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: Name of the category
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/service_optional/category/version (string)

        YANG Description: Category version
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/service_optional/category/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: Category version
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    href = __builtin__.property(_get_href, _set_href)
    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    version = __builtin__.property(_get_version, _set_version)

    _pyangbind_elements = OrderedDict(
        [
            ("href", href),
            ("id", id),
            ("name", name),
            ("version", version),
        ]
    )


class yc_service_optional_mec_app_descriptor__mec_appd_service_optional(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-optional. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes services a MEC application may use if available.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__transport_dependencies",
        "__requested_permissions",
        "__name",
        "__category",
        "__version",
    )

    _yang_name = "service-optional"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__transport_dependencies = YANGDynClass(
            base=YANGListType(
                "id",
                yc_transport_dependencies_mec_app_descriptor__mec_appd_service_optional_transport_dependencies,
                yang_name="transport-dependencies",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="transport-dependencies",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__requested_permissions = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="requested-permissions",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__category = YANGDynClass(
            base=yc_category_mec_app_descriptor__mec_appd_service_optional_category,
            is_container="container",
            yang_name="category",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "service-optional"]

    def _get_transport_dependencies(self):
        """
        Getter method for transport_dependencies, mapped from YANG variable /mec_appd/service_optional/transport_dependencies (list)

        YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
        """
        return self.__transport_dependencies

    def _set_transport_dependencies(self, v, load=False):
        """
        Setter method for transport_dependencies, mapped from YANG variable /mec_appd/service_optional/transport_dependencies (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transport_dependencies is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transport_dependencies() directly.

        YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_transport_dependencies_mec_app_descriptor__mec_appd_service_optional_transport_dependencies,
                    yang_name="transport-dependencies",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="transport-dependencies",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """transport_dependencies must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__mec_appd_service_optional_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__transport_dependencies = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_transport_dependencies(self):
        self.__transport_dependencies = YANGDynClass(
            base=YANGListType(
                "id",
                yc_transport_dependencies_mec_app_descriptor__mec_appd_service_optional_transport_dependencies,
                yang_name="transport-dependencies",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="transport-dependencies",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_requested_permissions(self):
        """
        Getter method for requested_permissions, mapped from YANG variable /mec_appd/service_optional/requested_permissions (string)

        YANG Description: Requested permissions regarding the access of the application to the service. The format is left for the data model design stage.
        """
        return self.__requested_permissions

    def _set_requested_permissions(self, v, load=False):
        """
        Setter method for requested_permissions, mapped from YANG variable /mec_appd/service_optional/requested_permissions (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_requested_permissions is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_requested_permissions() directly.

        YANG Description: Requested permissions regarding the access of the application to the service. The format is left for the data model design stage.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="requested-permissions",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """requested_permissions must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requested-permissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__requested_permissions = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_requested_permissions(self):
        self.__requested_permissions = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="requested-permissions",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/service_optional/name (string)

        YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/service_optional/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_category(self):
        """
        Getter method for category, mapped from YANG variable /mec_appd/service_optional/category (container)

        YANG Description: A Category reference of the service
        """
        return self.__category

    def _set_category(self, v, load=False):
        """
        Setter method for category, mapped from YANG variable /mec_appd/service_optional/category (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_category is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_category() directly.

        YANG Description: A Category reference of the service
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_category_mec_app_descriptor__mec_appd_service_optional_category,
                is_container="container",
                yang_name="category",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """category must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_category_mec_app_descriptor__mec_appd_service_optional_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__category = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_category(self):
        self.__category = YANGDynClass(
            base=yc_category_mec_app_descriptor__mec_appd_service_optional_category,
            is_container="container",
            yang_name="category",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/service_optional/version (string)

        YANG Description: The version of the service
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/service_optional/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: The version of the service
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    transport_dependencies = __builtin__.property(
        _get_transport_dependencies, _set_transport_dependencies
    )
    requested_permissions = __builtin__.property(
        _get_requested_permissions, _set_requested_permissions
    )
    name = __builtin__.property(_get_name, _set_name)
    category = __builtin__.property(_get_category, _set_category)
    version = __builtin__.property(_get_version, _set_version)

    _pyangbind_elements = OrderedDict(
        [
            ("transport_dependencies", transport_dependencies),
            ("requested_permissions", requested_permissions),
            ("name", name),
            ("category", category),
            ("version", version),
        ]
    )


class yc_oauth2_info_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport_security_oauth2_info(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-produced/transports-supported/transport/security/oauth2-info. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about OAuth2 based security
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__grant_types",
        "__token_endpoint",
    )

    _yang_name = "oauth2-info"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__grant_types = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "OAUTH2_AUTHORIZATION_CODE": {},
                        "OAUTH2_IMPLICIT_GRANT": {},
                        "OAUTH2_RESOURCE_OWNER": {},
                        "OAUTH2_CLIENT_CREDENTIALS": {},
                    },
                )
            ),
            is_leaf=False,
            yang_name="grant-types",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__token_endpoint = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="token-endpoint",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:uri",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "service-produced",
                "transports-supported",
                "transport",
                "security",
                "oauth2-info",
            ]

    def _get_grant_types(self):
        """
        Getter method for grant_types, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/security/oauth2_info/grant_types (enumeration)

        YANG Description: Supported OAuth2 grant types
        """
        return self.__grant_types

    def _set_grant_types(self, v, load=False):
        """
        Setter method for grant_types, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/security/oauth2_info/grant_types (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_grant_types is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_grant_types() directly.

        YANG Description: Supported OAuth2 grant types
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={
                            "OAUTH2_AUTHORIZATION_CODE": {},
                            "OAUTH2_IMPLICIT_GRANT": {},
                            "OAUTH2_RESOURCE_OWNER": {},
                            "OAUTH2_CLIENT_CREDENTIALS": {},
                        },
                    )
                ),
                is_leaf=False,
                yang_name="grant-types",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """grant_types must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__grant_types = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_grant_types(self):
        self.__grant_types = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "OAUTH2_AUTHORIZATION_CODE": {},
                        "OAUTH2_IMPLICIT_GRANT": {},
                        "OAUTH2_RESOURCE_OWNER": {},
                        "OAUTH2_CLIENT_CREDENTIALS": {},
                    },
                )
            ),
            is_leaf=False,
            yang_name="grant-types",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_token_endpoint(self):
        """
        Getter method for token_endpoint, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/security/oauth2_info/token_endpoint (inet:uri)

        YANG Description: The token endpoint
        """
        return self.__token_endpoint

    def _set_token_endpoint(self, v, load=False):
        """
        Setter method for token_endpoint, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/security/oauth2_info/token_endpoint (inet:uri)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_token_endpoint is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_token_endpoint() directly.

        YANG Description: The token endpoint
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="token-endpoint",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:uri",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """token_endpoint must be of a type compatible with inet:uri""",
                    "defined-type": "inet:uri",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
                }
            )

        self.__token_endpoint = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_token_endpoint(self):
        self.__token_endpoint = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="token-endpoint",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:uri",
            is_config=True,
        )

    grant_types = __builtin__.property(_get_grant_types, _set_grant_types)
    token_endpoint = __builtin__.property(_get_token_endpoint, _set_token_endpoint)

    _pyangbind_elements = OrderedDict(
        [
            ("grant_types", grant_types),
            ("token_endpoint", token_endpoint),
        ]
    )


class yc_security_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport_security(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-produced/transports-supported/transport/security. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about the security used by the transport
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__oauth2_info",
    )

    _yang_name = "security"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__oauth2_info = YANGDynClass(
            base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport_security_oauth2_info,
            is_container="container",
            yang_name="oauth2-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "service-produced",
                "transports-supported",
                "transport",
                "security",
            ]

    def _get_oauth2_info(self):
        """
        Getter method for oauth2_info, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/security/oauth2_info (container)

        YANG Description: Information about OAuth2 based security
        """
        return self.__oauth2_info

    def _set_oauth2_info(self, v, load=False):
        """
        Setter method for oauth2_info, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/security/oauth2_info (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_oauth2_info is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_oauth2_info() directly.

        YANG Description: Information about OAuth2 based security
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport_security_oauth2_info,
                is_container="container",
                yang_name="oauth2-info",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """oauth2_info must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__oauth2_info = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_oauth2_info(self):
        self.__oauth2_info = YANGDynClass(
            base=yc_oauth2_info_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport_security_oauth2_info,
            is_container="container",
            yang_name="oauth2-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    oauth2_info = __builtin__.property(_get_oauth2_info, _set_oauth2_info)

    _pyangbind_elements = OrderedDict(
        [
            ("oauth2_info", oauth2_info),
        ]
    )


class yc_transport_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-produced/transports-supported/transport. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about the transport in this transport binding
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__name",
        "__description",
        "__type",
        "__protocol",
        "__version",
        "__security",
    )

    _yang_name = "transport"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "REST_HTTP": {},
                    "MB_TOPIC_BASED": {},
                    "MB_ROUTING": {},
                    "MB_PUBSUB": {},
                    "RPC": {},
                    "RPC_STREAMING": {},
                    "WEBSOCKET": {},
                },
            ),
            is_leaf=True,
            yang_name="type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="transport-type",
            is_config=True,
        )
        self.__protocol = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__security = YANGDynClass(
            base=yc_security_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport_security,
            is_container="container",
            yang_name="security",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "service-produced", "transports-supported", "transport"]

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/name (string)

        YANG Description: The name of this transport
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The name of this transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_description(self):
        """
        Getter method for description, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/description (string)

        YANG Description: Human-readable description of this transport
        """
        return self.__description

    def _set_description(self, v, load=False):
        """
        Setter method for description, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/description (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_description is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_description() directly.

        YANG Description: Human-readable description of this transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="description",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """description must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__description = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_type(self):
        """
        Getter method for type, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/type (transport-type)

        YANG Description: Type of the transport
        """
        return self.__type

    def _set_type(self, v, load=False):
        """
        Setter method for type, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/type (transport-type)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_type() directly.

        YANG Description: Type of the transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "REST_HTTP": {},
                        "MB_TOPIC_BASED": {},
                        "MB_ROUTING": {},
                        "MB_PUBSUB": {},
                        "RPC": {},
                        "RPC_STREAMING": {},
                        "WEBSOCKET": {},
                    },
                ),
                is_leaf=True,
                yang_name="type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="transport-type",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """type must be of a type compatible with transport-type""",
                    "defined-type": "mec-app-descriptor:transport-type",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)""",
                }
            )

        self.__type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "REST_HTTP": {},
                    "MB_TOPIC_BASED": {},
                    "MB_ROUTING": {},
                    "MB_PUBSUB": {},
                    "RPC": {},
                    "RPC_STREAMING": {},
                    "WEBSOCKET": {},
                },
            ),
            is_leaf=True,
            yang_name="type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="transport-type",
            is_config=True,
        )

    def _get_protocol(self):
        """
        Getter method for protocol, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/protocol (string)

        YANG Description: The name of the protocol used
        """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
        Setter method for protocol, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/protocol (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_protocol is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_protocol() directly.

        YANG Description: The name of the protocol used
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="protocol",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """protocol must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__protocol = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/version (string)

        YANG Description: The version of the protocol used
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: The version of the protocol used
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_security(self):
        """
        Getter method for security, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/security (container)

        YANG Description: Information about the security used by the transport
        """
        return self.__security

    def _set_security(self, v, load=False):
        """
        Setter method for security, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport/security (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_security is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_security() directly.

        YANG Description: Information about the security used by the transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_security_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport_security,
                is_container="container",
                yang_name="security",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """security must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_security_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__security = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_security(self):
        self.__security = YANGDynClass(
            base=yc_security_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport_security,
            is_container="container",
            yang_name="security",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    type = __builtin__.property(_get_type, _set_type)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    version = __builtin__.property(_get_version, _set_version)
    security = __builtin__.property(_get_security, _set_security)

    _pyangbind_elements = OrderedDict(
        [
            ("name", name),
            ("description", description),
            ("type", type),
            ("protocol", protocol),
            ("version", version),
            ("security", security),
        ]
    )


class yc_transports_supported_mec_app_descriptor__mec_appd_service_produced_transports_supported(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-produced/transports-supported. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Transports and serializers supported by the service
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__transport",
        "__serializers",
    )

    _yang_name = "transports-supported"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__transport = YANGDynClass(
            base=yc_transport_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport,
            is_container="container",
            yang_name="transport",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__serializers = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "JSON": {"value": 0},
                        "XML": {"value": 1},
                        "PROTOBUF3": {"value": 2},
                    },
                )
            ),
            is_leaf=False,
            yang_name="serializers",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="td:serializer-type",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "service-produced", "transports-supported"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/service_produced/transports_supported/id (string)

        YANG Description: Unique identifier for the transport binding
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/service_produced/transports_supported/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier for the transport binding
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_transport(self):
        """
        Getter method for transport, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport (container)

        YANG Description: Information about the transport in this transport binding
        """
        return self.__transport

    def _set_transport(self, v, load=False):
        """
        Setter method for transport, mapped from YANG variable /mec_appd/service_produced/transports_supported/transport (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transport is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transport() directly.

        YANG Description: Information about the transport in this transport binding
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_transport_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport,
                is_container="container",
                yang_name="transport",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """transport must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_transport_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__transport = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_transport(self):
        self.__transport = YANGDynClass(
            base=yc_transport_mec_app_descriptor__mec_appd_service_produced_transports_supported_transport,
            is_container="container",
            yang_name="transport",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_serializers(self):
        """
        Getter method for serializers, mapped from YANG variable /mec_appd/service_produced/transports_supported/serializers (td:serializer-type)

        YANG Description: Type of serializers used in this transport binding
        """
        return self.__serializers

    def _set_serializers(self, v, load=False):
        """
        Setter method for serializers, mapped from YANG variable /mec_appd/service_produced/transports_supported/serializers (td:serializer-type)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_serializers is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_serializers() directly.

        YANG Description: Type of serializers used in this transport binding
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={
                            "JSON": {"value": 0},
                            "XML": {"value": 1},
                            "PROTOBUF3": {"value": 2},
                        },
                    )
                ),
                is_leaf=False,
                yang_name="serializers",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="td:serializer-type",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """serializers must be of a type compatible with td:serializer-type""",
                    "defined-type": "td:serializer-type",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='td:serializer-type', is_config=True)""",
                }
            )

        self.__serializers = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_serializers(self):
        self.__serializers = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "JSON": {"value": 0},
                        "XML": {"value": 1},
                        "PROTOBUF3": {"value": 2},
                    },
                )
            ),
            is_leaf=False,
            yang_name="serializers",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="td:serializer-type",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    transport = __builtin__.property(_get_transport, _set_transport)
    serializers = __builtin__.property(_get_serializers, _set_serializers)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("transport", transport),
            ("serializers", serializers),
        ]
    )


class yc_category_mec_app_descriptor__mec_appd_service_produced_category(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-produced/category. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: A Category reference of the service
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__href",
        "__id",
        "__name",
        "__version",
    )

    _yang_name = "category"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__href = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="href",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "service-produced", "category"]

    def _get_href(self):
        """
        Getter method for href, mapped from YANG variable /mec_appd/service_produced/category/href (string)

        YANG Description: Reference of the catalogue
        """
        return self.__href

    def _set_href(self, v, load=False):
        """
        Setter method for href, mapped from YANG variable /mec_appd/service_produced/category/href (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_href is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_href() directly.

        YANG Description: Reference of the catalogue
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="href",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """href must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__href = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_href(self):
        self.__href = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="href",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/service_produced/category/id (string)

        YANG Description: Unique identifier of the category
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/service_produced/category/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier of the category
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/service_produced/category/name (string)

        YANG Description: Name of the category
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/service_produced/category/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: Name of the category
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/service_produced/category/version (string)

        YANG Description: Category version
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/service_produced/category/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: Category version
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    href = __builtin__.property(_get_href, _set_href)
    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    version = __builtin__.property(_get_version, _set_version)

    _pyangbind_elements = OrderedDict(
        [
            ("href", href),
            ("id", id),
            ("name", name),
            ("version", version),
        ]
    )


class yc_service_produced_mec_app_descriptor__mec_appd_service_produced(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/service-produced. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes services a MEC application is able to produce to the platform or other MEC applications. Only relevant for serviceproducing apps.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__transports_supported",
        "__name",
        "__category",
        "__version",
    )

    _yang_name = "service-produced"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__transports_supported = YANGDynClass(
            base=YANGListType(
                "id",
                yc_transports_supported_mec_app_descriptor__mec_appd_service_produced_transports_supported,
                yang_name="transports-supported",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="transports-supported",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__category = YANGDynClass(
            base=yc_category_mec_app_descriptor__mec_appd_service_produced_category,
            is_container="container",
            yang_name="category",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "service-produced"]

    def _get_transports_supported(self):
        """
        Getter method for transports_supported, mapped from YANG variable /mec_appd/service_produced/transports_supported (list)

        YANG Description: Transports and serializers supported by the service
        """
        return self.__transports_supported

    def _set_transports_supported(self, v, load=False):
        """
        Setter method for transports_supported, mapped from YANG variable /mec_appd/service_produced/transports_supported (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transports_supported is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transports_supported() directly.

        YANG Description: Transports and serializers supported by the service
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_transports_supported_mec_app_descriptor__mec_appd_service_produced_transports_supported,
                    yang_name="transports-supported",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="transports-supported",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """transports_supported must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_transports_supported_mec_app_descriptor__mec_appd_service_produced_transports_supported, yang_name="transports-supported", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transports-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__transports_supported = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_transports_supported(self):
        self.__transports_supported = YANGDynClass(
            base=YANGListType(
                "id",
                yc_transports_supported_mec_app_descriptor__mec_appd_service_produced_transports_supported,
                yang_name="transports-supported",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="transports-supported",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/service_produced/name (string)

        YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/service_produced/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_category(self):
        """
        Getter method for category, mapped from YANG variable /mec_appd/service_produced/category (container)

        YANG Description: A Category reference of the service
        """
        return self.__category

    def _set_category(self, v, load=False):
        """
        Setter method for category, mapped from YANG variable /mec_appd/service_produced/category (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_category is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_category() directly.

        YANG Description: A Category reference of the service
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_category_mec_app_descriptor__mec_appd_service_produced_category,
                is_container="container",
                yang_name="category",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """category must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_category_mec_app_descriptor__mec_appd_service_produced_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__category = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_category(self):
        self.__category = YANGDynClass(
            base=yc_category_mec_app_descriptor__mec_appd_service_produced_category,
            is_container="container",
            yang_name="category",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/service_produced/version (string)

        YANG Description: The version of the service
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/service_produced/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: The version of the service
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    transports_supported = __builtin__.property(
        _get_transports_supported, _set_transports_supported
    )
    name = __builtin__.property(_get_name, _set_name)
    category = __builtin__.property(_get_category, _set_category)
    version = __builtin__.property(_get_version, _set_version)

    _pyangbind_elements = OrderedDict(
        [
            ("transports_supported", transports_supported),
            ("name", name),
            ("category", category),
            ("version", version),
        ]
    )


class yc_feature_required_mec_app_descriptor__mec_appd_feature_required(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/feature-required. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes features a MEC application requires to run
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__name",
        "__version",
    )

    _yang_name = "feature-required"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "feature-required"]

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/feature_required/name (string)

        YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/feature_required/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/feature_required/version (string)

        YANG Description: The version of the feature.
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/feature_required/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: The version of the feature.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    name = __builtin__.property(_get_name, _set_name)
    version = __builtin__.property(_get_version, _set_version)

    _pyangbind_elements = OrderedDict(
        [
            ("name", name),
            ("version", version),
        ]
    )


class yc_feature_optional_mec_app_descriptor__mec_appd_feature_optional(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/feature-optional. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes features a MEC application may use if available.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__name",
        "__version",
    )

    _yang_name = "feature-optional"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "feature-optional"]

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/feature_optional/name (string)

        YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/feature_optional/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/feature_optional/version (string)

        YANG Description: The version of the feature.
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/feature_optional/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: The version of the feature.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    name = __builtin__.property(_get_name, _set_name)
    version = __builtin__.property(_get_version, _set_version)

    _pyangbind_elements = OrderedDict(
        [
            ("name", name),
            ("version", version),
        ]
    )


class yc_oauth2_info_mec_app_descriptor__mec_appd_transport_dependencies_transport_security_oauth2_info(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/transport-dependencies/transport/security/oauth2-info. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about OAuth2 based security
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__grant_types",
        "__token_endpoint",
    )

    _yang_name = "oauth2-info"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__grant_types = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "OAUTH2_AUTHORIZATION_CODE": {},
                        "OAUTH2_IMPLICIT_GRANT": {},
                        "OAUTH2_RESOURCE_OWNER": {},
                        "OAUTH2_CLIENT_CREDENTIALS": {},
                    },
                )
            ),
            is_leaf=False,
            yang_name="grant-types",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__token_endpoint = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="token-endpoint",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:uri",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [
                "mec-appd",
                "transport-dependencies",
                "transport",
                "security",
                "oauth2-info",
            ]

    def _get_grant_types(self):
        """
        Getter method for grant_types, mapped from YANG variable /mec_appd/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)

        YANG Description: Supported OAuth2 grant types
        """
        return self.__grant_types

    def _set_grant_types(self, v, load=False):
        """
        Setter method for grant_types, mapped from YANG variable /mec_appd/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_grant_types is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_grant_types() directly.

        YANG Description: Supported OAuth2 grant types
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={
                            "OAUTH2_AUTHORIZATION_CODE": {},
                            "OAUTH2_IMPLICIT_GRANT": {},
                            "OAUTH2_RESOURCE_OWNER": {},
                            "OAUTH2_CLIENT_CREDENTIALS": {},
                        },
                    )
                ),
                is_leaf=False,
                yang_name="grant-types",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """grant_types must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__grant_types = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_grant_types(self):
        self.__grant_types = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "OAUTH2_AUTHORIZATION_CODE": {},
                        "OAUTH2_IMPLICIT_GRANT": {},
                        "OAUTH2_RESOURCE_OWNER": {},
                        "OAUTH2_CLIENT_CREDENTIALS": {},
                    },
                )
            ),
            is_leaf=False,
            yang_name="grant-types",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_token_endpoint(self):
        """
        Getter method for token_endpoint, mapped from YANG variable /mec_appd/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)

        YANG Description: The token endpoint
        """
        return self.__token_endpoint

    def _set_token_endpoint(self, v, load=False):
        """
        Setter method for token_endpoint, mapped from YANG variable /mec_appd/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_token_endpoint is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_token_endpoint() directly.

        YANG Description: The token endpoint
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="token-endpoint",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:uri",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """token_endpoint must be of a type compatible with inet:uri""",
                    "defined-type": "inet:uri",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
                }
            )

        self.__token_endpoint = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_token_endpoint(self):
        self.__token_endpoint = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="token-endpoint",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:uri",
            is_config=True,
        )

    grant_types = __builtin__.property(_get_grant_types, _set_grant_types)
    token_endpoint = __builtin__.property(_get_token_endpoint, _set_token_endpoint)

    _pyangbind_elements = OrderedDict(
        [
            ("grant_types", grant_types),
            ("token_endpoint", token_endpoint),
        ]
    )


class yc_security_mec_app_descriptor__mec_appd_transport_dependencies_transport_security(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/transport-dependencies/transport/security. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about the security used by the transport
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__oauth2_info",
    )

    _yang_name = "security"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__oauth2_info = YANGDynClass(
            base=yc_oauth2_info_mec_app_descriptor__mec_appd_transport_dependencies_transport_security_oauth2_info,
            is_container="container",
            yang_name="oauth2-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "transport-dependencies", "transport", "security"]

    def _get_oauth2_info(self):
        """
        Getter method for oauth2_info, mapped from YANG variable /mec_appd/transport_dependencies/transport/security/oauth2_info (container)

        YANG Description: Information about OAuth2 based security
        """
        return self.__oauth2_info

    def _set_oauth2_info(self, v, load=False):
        """
        Setter method for oauth2_info, mapped from YANG variable /mec_appd/transport_dependencies/transport/security/oauth2_info (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_oauth2_info is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_oauth2_info() directly.

        YANG Description: Information about OAuth2 based security
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_oauth2_info_mec_app_descriptor__mec_appd_transport_dependencies_transport_security_oauth2_info,
                is_container="container",
                yang_name="oauth2-info",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """oauth2_info must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__mec_appd_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__oauth2_info = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_oauth2_info(self):
        self.__oauth2_info = YANGDynClass(
            base=yc_oauth2_info_mec_app_descriptor__mec_appd_transport_dependencies_transport_security_oauth2_info,
            is_container="container",
            yang_name="oauth2-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    oauth2_info = __builtin__.property(_get_oauth2_info, _set_oauth2_info)

    _pyangbind_elements = OrderedDict(
        [
            ("oauth2_info", oauth2_info),
        ]
    )


class yc_transport_mec_app_descriptor__mec_appd_transport_dependencies_transport(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/transport-dependencies/transport. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Information about the transport in this transport binding
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__name",
        "__description",
        "__type",
        "__protocol",
        "__version",
        "__security",
    )

    _yang_name = "transport"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "REST_HTTP": {},
                    "MB_TOPIC_BASED": {},
                    "MB_ROUTING": {},
                    "MB_PUBSUB": {},
                    "RPC": {},
                    "RPC_STREAMING": {},
                    "WEBSOCKET": {},
                },
            ),
            is_leaf=True,
            yang_name="type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="transport-type",
            is_config=True,
        )
        self.__protocol = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__security = YANGDynClass(
            base=yc_security_mec_app_descriptor__mec_appd_transport_dependencies_transport_security,
            is_container="container",
            yang_name="security",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "transport-dependencies", "transport"]

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/transport_dependencies/transport/name (string)

        YANG Description: The name of this transport
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/transport_dependencies/transport/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: The name of this transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_description(self):
        """
        Getter method for description, mapped from YANG variable /mec_appd/transport_dependencies/transport/description (string)

        YANG Description: Human-readable description of this transport
        """
        return self.__description

    def _set_description(self, v, load=False):
        """
        Setter method for description, mapped from YANG variable /mec_appd/transport_dependencies/transport/description (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_description is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_description() directly.

        YANG Description: Human-readable description of this transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="description",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """description must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__description = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_type(self):
        """
        Getter method for type, mapped from YANG variable /mec_appd/transport_dependencies/transport/type (transport-type)

        YANG Description: Type of the transport
        """
        return self.__type

    def _set_type(self, v, load=False):
        """
        Setter method for type, mapped from YANG variable /mec_appd/transport_dependencies/transport/type (transport-type)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_type() directly.

        YANG Description: Type of the transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "REST_HTTP": {},
                        "MB_TOPIC_BASED": {},
                        "MB_ROUTING": {},
                        "MB_PUBSUB": {},
                        "RPC": {},
                        "RPC_STREAMING": {},
                        "WEBSOCKET": {},
                    },
                ),
                is_leaf=True,
                yang_name="type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="transport-type",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """type must be of a type compatible with transport-type""",
                    "defined-type": "mec-app-descriptor:transport-type",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)""",
                }
            )

        self.__type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "REST_HTTP": {},
                    "MB_TOPIC_BASED": {},
                    "MB_ROUTING": {},
                    "MB_PUBSUB": {},
                    "RPC": {},
                    "RPC_STREAMING": {},
                    "WEBSOCKET": {},
                },
            ),
            is_leaf=True,
            yang_name="type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="transport-type",
            is_config=True,
        )

    def _get_protocol(self):
        """
        Getter method for protocol, mapped from YANG variable /mec_appd/transport_dependencies/transport/protocol (string)

        YANG Description: The name of the protocol used
        """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
        Setter method for protocol, mapped from YANG variable /mec_appd/transport_dependencies/transport/protocol (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_protocol is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_protocol() directly.

        YANG Description: The name of the protocol used
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="protocol",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """protocol must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__protocol = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/transport_dependencies/transport/version (string)

        YANG Description: The version of the protocol used
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/transport_dependencies/transport/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: The version of the protocol used
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_security(self):
        """
        Getter method for security, mapped from YANG variable /mec_appd/transport_dependencies/transport/security (container)

        YANG Description: Information about the security used by the transport
        """
        return self.__security

    def _set_security(self, v, load=False):
        """
        Setter method for security, mapped from YANG variable /mec_appd/transport_dependencies/transport/security (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_security is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_security() directly.

        YANG Description: Information about the security used by the transport
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_security_mec_app_descriptor__mec_appd_transport_dependencies_transport_security,
                is_container="container",
                yang_name="security",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """security must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_security_mec_app_descriptor__mec_appd_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__security = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_security(self):
        self.__security = YANGDynClass(
            base=yc_security_mec_app_descriptor__mec_appd_transport_dependencies_transport_security,
            is_container="container",
            yang_name="security",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    type = __builtin__.property(_get_type, _set_type)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    version = __builtin__.property(_get_version, _set_version)
    security = __builtin__.property(_get_security, _set_security)

    _pyangbind_elements = OrderedDict(
        [
            ("name", name),
            ("description", description),
            ("type", type),
            ("protocol", protocol),
            ("version", version),
            ("security", security),
        ]
    )


class yc_transport_dependencies_mec_app_descriptor__mec_appd_transport_dependencies(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/transport-dependencies. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Transports, if any, that this application requires to be provided by the platform. These transports will be used by the application to deliver services provided by this application. Only relevant for service-producing apps. See note 2.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__transport",
        "__serializers",
        "__labels",
    )

    _yang_name = "transport-dependencies"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__transport = YANGDynClass(
            base=yc_transport_mec_app_descriptor__mec_appd_transport_dependencies_transport,
            is_container="container",
            yang_name="transport",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__serializers = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "JSON": {"value": 0},
                        "XML": {"value": 1},
                        "PROTOBUF3": {"value": 2},
                    },
                )
            ),
            is_leaf=False,
            yang_name="serializers",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="serializer-type",
            is_config=True,
        )
        self.__labels = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="labels",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "transport-dependencies"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/transport_dependencies/id (string)

        YANG Description: Unique identifier for the transport dependency
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/transport_dependencies/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier for the transport dependency
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_transport(self):
        """
        Getter method for transport, mapped from YANG variable /mec_appd/transport_dependencies/transport (container)

        YANG Description: Information about the transport in this transport binding
        """
        return self.__transport

    def _set_transport(self, v, load=False):
        """
        Setter method for transport, mapped from YANG variable /mec_appd/transport_dependencies/transport (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transport is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transport() directly.

        YANG Description: Information about the transport in this transport binding
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_transport_mec_app_descriptor__mec_appd_transport_dependencies_transport,
                is_container="container",
                yang_name="transport",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """transport must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_transport_mec_app_descriptor__mec_appd_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__transport = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_transport(self):
        self.__transport = YANGDynClass(
            base=yc_transport_mec_app_descriptor__mec_appd_transport_dependencies_transport,
            is_container="container",
            yang_name="transport",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_serializers(self):
        """
        Getter method for serializers, mapped from YANG variable /mec_appd/transport_dependencies/serializers (serializer-type)

        YANG Description: Type of serializers used in this transport binding
        """
        return self.__serializers

    def _set_serializers(self, v, load=False):
        """
        Setter method for serializers, mapped from YANG variable /mec_appd/transport_dependencies/serializers (serializer-type)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_serializers is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_serializers() directly.

        YANG Description: Type of serializers used in this transport binding
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=six.text_type,
                        restriction_type="dict_key",
                        restriction_arg={
                            "JSON": {"value": 0},
                            "XML": {"value": 1},
                            "PROTOBUF3": {"value": 2},
                        },
                    )
                ),
                is_leaf=False,
                yang_name="serializers",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="serializer-type",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """serializers must be of a type compatible with serializer-type""",
                    "defined-type": "mec-app-descriptor:serializer-type",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)""",
                }
            )

        self.__serializers = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_serializers(self):
        self.__serializers = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "JSON": {"value": 0},
                        "XML": {"value": 1},
                        "PROTOBUF3": {"value": 2},
                    },
                )
            ),
            is_leaf=False,
            yang_name="serializers",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="serializer-type",
            is_config=True,
        )

    def _get_labels(self):
        """
        Getter method for labels, mapped from YANG variable /mec_appd/transport_dependencies/labels (string)

        YANG Description: Set of labels that allow to define groups of transport bindings
        """
        return self.__labels

    def _set_labels(self, v, load=False):
        """
        Setter method for labels, mapped from YANG variable /mec_appd/transport_dependencies/labels (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_labels is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_labels() directly.

        YANG Description: Set of labels that allow to define groups of transport bindings
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="labels",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """labels must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__labels = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_labels(self):
        self.__labels = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="labels",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    transport = __builtin__.property(_get_transport, _set_transport)
    serializers = __builtin__.property(_get_serializers, _set_serializers)
    labels = __builtin__.property(_get_labels, _set_labels)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("transport", transport),
            ("serializers", serializers),
            ("labels", labels),
        ]
    )


class yc_traffic_filter_mec_app_descriptor__mec_appd_traffic_rule_traffic_filter(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/traffic-rule/traffic-filter. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Filter to identify specific flow/packets
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__src_address",
        "__dst_address",
        "__src_port",
        "__dst_port",
        "__protocol",
        "__tag",
        "__uri",
        "__packet_label",
        "__src_tunnel_address",
        "__tgt_tunnel_address",
        "__src_tunnel_port",
        "__dst_tunnel_port",
        "__qci",
        "__dscp",
        "__tc",
    )

    _yang_name = "traffic-filter"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__src_address = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ]
            ),
            is_leaf=False,
            yang_name="src-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )
        self.__dst_address = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ]
            ),
            is_leaf=False,
            yang_name="dst-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )
        self.__src_port = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=RestrictedClassType(
                        base_type=int,
                        restriction_dict={"range": ["0..65535"]},
                        int_size=16,
                    ),
                    restriction_dict={"range": ["0..65535"]},
                )
            ),
            is_leaf=False,
            yang_name="src-port",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:port-number",
            is_config=True,
        )
        self.__dst_port = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=RestrictedClassType(
                        base_type=int,
                        restriction_dict={"range": ["0..65535"]},
                        int_size=16,
                    ),
                    restriction_dict={"range": ["0..65535"]},
                )
            ),
            is_leaf=False,
            yang_name="dst-port",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:port-number",
            is_config=True,
        )
        self.__protocol = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__tag = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="tag",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__uri = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="uri",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__packet_label = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="packet-label",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__src_tunnel_address = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ]
            ),
            is_leaf=False,
            yang_name="src-tunnel-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )
        self.__tgt_tunnel_address = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ]
            ),
            is_leaf=False,
            yang_name="tgt-tunnel-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )
        self.__src_tunnel_port = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=RestrictedClassType(
                        base_type=int,
                        restriction_dict={"range": ["0..65535"]},
                        int_size=16,
                    ),
                    restriction_dict={"range": ["0..65535"]},
                )
            ),
            is_leaf=False,
            yang_name="src-tunnel-port",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:port-number",
            is_config=True,
        )
        self.__dst_tunnel_port = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=RestrictedClassType(
                        base_type=int,
                        restriction_dict={"range": ["0..65535"]},
                        int_size=16,
                    ),
                    restriction_dict={"range": ["0..65535"]},
                )
            ),
            is_leaf=False,
            yang_name="dst-tunnel-port",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:port-number",
            is_config=True,
        )
        self.__qci = YANGDynClass(
            base=RestrictedClassType(
                base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
            ),
            is_leaf=True,
            yang_name="qci",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint8",
            is_config=True,
        )
        self.__dscp = YANGDynClass(
            base=RestrictedClassType(
                base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
            ),
            is_leaf=True,
            yang_name="dscp",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint8",
            is_config=True,
        )
        self.__tc = YANGDynClass(
            base=RestrictedClassType(
                base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
            ),
            is_leaf=True,
            yang_name="tc",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint8",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "traffic-rule", "traffic-filter"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/id (string)

        YANG Description: Unique identifier for the traffic filter
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier for the traffic filter
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_src_address(self):
        """
        Getter method for src_address, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/src_address (inet:ip-address)

        YANG Description: An IP address or a range of IP addresses
        """
        return self.__src_address

    def _set_src_address(self, v, load=False):
        """
        Setter method for src_address, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/src_address (inet:ip-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_src_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_src_address() directly.

        YANG Description: An IP address or a range of IP addresses
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=[
                        RestrictedClassType(
                            base_type=six.text_type,
                            restriction_dict={
                                "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                            },
                        ),
                        RestrictedClassType(
                            base_type=six.text_type,
                            restriction_dict={
                                "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                            },
                        ),
                    ]
                ),
                is_leaf=False,
                yang_name="src-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:ip-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """src_address must be of a type compatible with inet:ip-address""",
                    "defined-type": "inet:ip-address",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="src-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
                }
            )

        self.__src_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_src_address(self):
        self.__src_address = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ]
            ),
            is_leaf=False,
            yang_name="src-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

    def _get_dst_address(self):
        """
        Getter method for dst_address, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/dst_address (inet:ip-address)

        YANG Description: An IP address or a range of IP addresses
        """
        return self.__dst_address

    def _set_dst_address(self, v, load=False):
        """
        Setter method for dst_address, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/dst_address (inet:ip-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_dst_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_dst_address() directly.

        YANG Description: An IP address or a range of IP addresses
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=[
                        RestrictedClassType(
                            base_type=six.text_type,
                            restriction_dict={
                                "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                            },
                        ),
                        RestrictedClassType(
                            base_type=six.text_type,
                            restriction_dict={
                                "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                            },
                        ),
                    ]
                ),
                is_leaf=False,
                yang_name="dst-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:ip-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """dst_address must be of a type compatible with inet:ip-address""",
                    "defined-type": "inet:ip-address",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="dst-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
                }
            )

        self.__dst_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_dst_address(self):
        self.__dst_address = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ]
            ),
            is_leaf=False,
            yang_name="dst-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

    def _get_src_port(self):
        """
        Getter method for src_port, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/src_port (inet:port-number)

        YANG Description: A port or a range of ports
        """
        return self.__src_port

    def _set_src_port(self, v, load=False):
        """
        Setter method for src_port, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/src_port (inet:port-number)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_src_port is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_src_port() directly.

        YANG Description: A port or a range of ports
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=RestrictedClassType(
                            base_type=int,
                            restriction_dict={"range": ["0..65535"]},
                            int_size=16,
                        ),
                        restriction_dict={"range": ["0..65535"]},
                    )
                ),
                is_leaf=False,
                yang_name="src-port",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:port-number",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """src_port must be of a type compatible with inet:port-number""",
                    "defined-type": "inet:port-number",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
                }
            )

        self.__src_port = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_src_port(self):
        self.__src_port = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=RestrictedClassType(
                        base_type=int,
                        restriction_dict={"range": ["0..65535"]},
                        int_size=16,
                    ),
                    restriction_dict={"range": ["0..65535"]},
                )
            ),
            is_leaf=False,
            yang_name="src-port",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:port-number",
            is_config=True,
        )

    def _get_dst_port(self):
        """
        Getter method for dst_port, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/dst_port (inet:port-number)

        YANG Description: A port or a range of ports
        """
        return self.__dst_port

    def _set_dst_port(self, v, load=False):
        """
        Setter method for dst_port, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/dst_port (inet:port-number)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_dst_port is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_dst_port() directly.

        YANG Description: A port or a range of ports
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=RestrictedClassType(
                            base_type=int,
                            restriction_dict={"range": ["0..65535"]},
                            int_size=16,
                        ),
                        restriction_dict={"range": ["0..65535"]},
                    )
                ),
                is_leaf=False,
                yang_name="dst-port",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:port-number",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """dst_port must be of a type compatible with inet:port-number""",
                    "defined-type": "inet:port-number",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
                }
            )

        self.__dst_port = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_dst_port(self):
        self.__dst_port = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=RestrictedClassType(
                        base_type=int,
                        restriction_dict={"range": ["0..65535"]},
                        int_size=16,
                    ),
                    restriction_dict={"range": ["0..65535"]},
                )
            ),
            is_leaf=False,
            yang_name="dst-port",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:port-number",
            is_config=True,
        )

    def _get_protocol(self):
        """
        Getter method for protocol, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/protocol (string)

        YANG Description: Specify the protocol of the traffic filter
        """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
        Setter method for protocol, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/protocol (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_protocol is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_protocol() directly.

        YANG Description: Specify the protocol of the traffic filter
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="protocol",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """protocol must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__protocol = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="protocol",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_tag(self):
        """
        Getter method for tag, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/tag (string)

        YANG Description: Used for tag based traffic rule
        """
        return self.__tag

    def _set_tag(self, v, load=False):
        """
        Setter method for tag, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/tag (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_tag is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_tag() directly.

        YANG Description: Used for tag based traffic rule
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="tag",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """tag must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__tag = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_tag(self):
        self.__tag = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="tag",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_uri(self):
        """
        Getter method for uri, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/uri (string)

        YANG Description: An URI label used to filter the traffic
        """
        return self.__uri

    def _set_uri(self, v, load=False):
        """
        Setter method for uri, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/uri (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_uri is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_uri() directly.

        YANG Description: An URI label used to filter the traffic
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="uri",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """uri must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__uri = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_uri(self):
        self.__uri = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="uri",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_packet_label(self):
        """
        Getter method for packet_label, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/packet_label (string)

        YANG Description: A customized packet label used to filter traffic
        """
        return self.__packet_label

    def _set_packet_label(self, v, load=False):
        """
        Setter method for packet_label, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/packet_label (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_packet_label is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_packet_label() directly.

        YANG Description: A customized packet label used to filter traffic
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(allowed_type=six.text_type),
                is_leaf=False,
                yang_name="packet-label",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """packet_label must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="packet-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__packet_label = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_packet_label(self):
        self.__packet_label = YANGDynClass(
            unique=True,
            base=TypedListType(allowed_type=six.text_type),
            is_leaf=False,
            yang_name="packet-label",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_src_tunnel_address(self):
        """
        Getter method for src_tunnel_address, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/src_tunnel_address (inet:ip-address)

        YANG Description: Used for GTP tunnel based traffic rule
        """
        return self.__src_tunnel_address

    def _set_src_tunnel_address(self, v, load=False):
        """
        Setter method for src_tunnel_address, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/src_tunnel_address (inet:ip-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_src_tunnel_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_src_tunnel_address() directly.

        YANG Description: Used for GTP tunnel based traffic rule
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=[
                        RestrictedClassType(
                            base_type=six.text_type,
                            restriction_dict={
                                "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                            },
                        ),
                        RestrictedClassType(
                            base_type=six.text_type,
                            restriction_dict={
                                "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                            },
                        ),
                    ]
                ),
                is_leaf=False,
                yang_name="src-tunnel-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:ip-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """src_tunnel_address must be of a type compatible with inet:ip-address""",
                    "defined-type": "inet:ip-address",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="src-tunnel-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
                }
            )

        self.__src_tunnel_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_src_tunnel_address(self):
        self.__src_tunnel_address = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ]
            ),
            is_leaf=False,
            yang_name="src-tunnel-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

    def _get_tgt_tunnel_address(self):
        """
        Getter method for tgt_tunnel_address, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/tgt_tunnel_address (inet:ip-address)

        YANG Description: Used for GTP tunnel based traffic rule
        """
        return self.__tgt_tunnel_address

    def _set_tgt_tunnel_address(self, v, load=False):
        """
        Setter method for tgt_tunnel_address, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/tgt_tunnel_address (inet:ip-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_tgt_tunnel_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_tgt_tunnel_address() directly.

        YANG Description: Used for GTP tunnel based traffic rule
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=[
                        RestrictedClassType(
                            base_type=six.text_type,
                            restriction_dict={
                                "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                            },
                        ),
                        RestrictedClassType(
                            base_type=six.text_type,
                            restriction_dict={
                                "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                            },
                        ),
                    ]
                ),
                is_leaf=False,
                yang_name="tgt-tunnel-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:ip-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """tgt_tunnel_address must be of a type compatible with inet:ip-address""",
                    "defined-type": "inet:ip-address",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="tgt-tunnel-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
                }
            )

        self.__tgt_tunnel_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_tgt_tunnel_address(self):
        self.__tgt_tunnel_address = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ]
            ),
            is_leaf=False,
            yang_name="tgt-tunnel-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

    def _get_src_tunnel_port(self):
        """
        Getter method for src_tunnel_port, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/src_tunnel_port (inet:port-number)

        YANG Description: Used for GTP tunnel based traffic rule
        """
        return self.__src_tunnel_port

    def _set_src_tunnel_port(self, v, load=False):
        """
        Setter method for src_tunnel_port, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/src_tunnel_port (inet:port-number)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_src_tunnel_port is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_src_tunnel_port() directly.

        YANG Description: Used for GTP tunnel based traffic rule
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=RestrictedClassType(
                            base_type=int,
                            restriction_dict={"range": ["0..65535"]},
                            int_size=16,
                        ),
                        restriction_dict={"range": ["0..65535"]},
                    )
                ),
                is_leaf=False,
                yang_name="src-tunnel-port",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:port-number",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """src_tunnel_port must be of a type compatible with inet:port-number""",
                    "defined-type": "inet:port-number",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="src-tunnel-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
                }
            )

        self.__src_tunnel_port = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_src_tunnel_port(self):
        self.__src_tunnel_port = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=RestrictedClassType(
                        base_type=int,
                        restriction_dict={"range": ["0..65535"]},
                        int_size=16,
                    ),
                    restriction_dict={"range": ["0..65535"]},
                )
            ),
            is_leaf=False,
            yang_name="src-tunnel-port",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:port-number",
            is_config=True,
        )

    def _get_dst_tunnel_port(self):
        """
        Getter method for dst_tunnel_port, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/dst_tunnel_port (inet:port-number)

        YANG Description: Used for GTP tunnel based traffic rule
        """
        return self.__dst_tunnel_port

    def _set_dst_tunnel_port(self, v, load=False):
        """
        Setter method for dst_tunnel_port, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/dst_tunnel_port (inet:port-number)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_dst_tunnel_port is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_dst_tunnel_port() directly.

        YANG Description: Used for GTP tunnel based traffic rule
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                unique=True,
                base=TypedListType(
                    allowed_type=RestrictedClassType(
                        base_type=RestrictedClassType(
                            base_type=int,
                            restriction_dict={"range": ["0..65535"]},
                            int_size=16,
                        ),
                        restriction_dict={"range": ["0..65535"]},
                    )
                ),
                is_leaf=False,
                yang_name="dst-tunnel-port",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:port-number",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """dst_tunnel_port must be of a type compatible with inet:port-number""",
                    "defined-type": "inet:port-number",
                    "generated-type": """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dst-tunnel-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
                }
            )

        self.__dst_tunnel_port = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_dst_tunnel_port(self):
        self.__dst_tunnel_port = YANGDynClass(
            unique=True,
            base=TypedListType(
                allowed_type=RestrictedClassType(
                    base_type=RestrictedClassType(
                        base_type=int,
                        restriction_dict={"range": ["0..65535"]},
                        int_size=16,
                    ),
                    restriction_dict={"range": ["0..65535"]},
                )
            ),
            is_leaf=False,
            yang_name="dst-tunnel-port",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:port-number",
            is_config=True,
        )

    def _get_qci(self):
        """
        Getter method for qci, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/qci (uint8)

        YANG Description: Used to match all packets that have the same QCI
        """
        return self.__qci

    def _set_qci(self, v, load=False):
        """
        Setter method for qci, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/qci (uint8)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_qci is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_qci() directly.

        YANG Description: Used to match all packets that have the same QCI
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
                ),
                is_leaf=True,
                yang_name="qci",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint8",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """qci must be of a type compatible with uint8""",
                    "defined-type": "uint8",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="qci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
                }
            )

        self.__qci = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_qci(self):
        self.__qci = YANGDynClass(
            base=RestrictedClassType(
                base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
            ),
            is_leaf=True,
            yang_name="qci",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint8",
            is_config=True,
        )

    def _get_dscp(self):
        """
        Getter method for dscp, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/dscp (uint8)

        YANG Description: Used to match all IPv4 packets with same DSCP
        """
        return self.__dscp

    def _set_dscp(self, v, load=False):
        """
        Setter method for dscp, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/dscp (uint8)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_dscp is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_dscp() directly.

        YANG Description: Used to match all IPv4 packets with same DSCP
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
                ),
                is_leaf=True,
                yang_name="dscp",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint8",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """dscp must be of a type compatible with uint8""",
                    "defined-type": "uint8",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
                }
            )

        self.__dscp = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_dscp(self):
        self.__dscp = YANGDynClass(
            base=RestrictedClassType(
                base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
            ),
            is_leaf=True,
            yang_name="dscp",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint8",
            is_config=True,
        )

    def _get_tc(self):
        """
        Getter method for tc, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/tc (uint8)

        YANG Description: Used to match all IPv6 packets with same TC
        """
        return self.__tc

    def _set_tc(self, v, load=False):
        """
        Setter method for tc, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter/tc (uint8)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_tc is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_tc() directly.

        YANG Description: Used to match all IPv6 packets with same TC
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
                ),
                is_leaf=True,
                yang_name="tc",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint8",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """tc must be of a type compatible with uint8""",
                    "defined-type": "uint8",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
                }
            )

        self.__tc = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_tc(self):
        self.__tc = YANGDynClass(
            base=RestrictedClassType(
                base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
            ),
            is_leaf=True,
            yang_name="tc",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint8",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    src_address = __builtin__.property(_get_src_address, _set_src_address)
    dst_address = __builtin__.property(_get_dst_address, _set_dst_address)
    src_port = __builtin__.property(_get_src_port, _set_src_port)
    dst_port = __builtin__.property(_get_dst_port, _set_dst_port)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    tag = __builtin__.property(_get_tag, _set_tag)
    uri = __builtin__.property(_get_uri, _set_uri)
    packet_label = __builtin__.property(_get_packet_label, _set_packet_label)
    src_tunnel_address = __builtin__.property(
        _get_src_tunnel_address, _set_src_tunnel_address
    )
    tgt_tunnel_address = __builtin__.property(
        _get_tgt_tunnel_address, _set_tgt_tunnel_address
    )
    src_tunnel_port = __builtin__.property(_get_src_tunnel_port, _set_src_tunnel_port)
    dst_tunnel_port = __builtin__.property(_get_dst_tunnel_port, _set_dst_tunnel_port)
    qci = __builtin__.property(_get_qci, _set_qci)
    dscp = __builtin__.property(_get_dscp, _set_dscp)
    tc = __builtin__.property(_get_tc, _set_tc)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("src_address", src_address),
            ("dst_address", dst_address),
            ("src_port", src_port),
            ("dst_port", dst_port),
            ("protocol", protocol),
            ("tag", tag),
            ("uri", uri),
            ("packet_label", packet_label),
            ("src_tunnel_address", src_tunnel_address),
            ("tgt_tunnel_address", tgt_tunnel_address),
            ("src_tunnel_port", src_tunnel_port),
            ("dst_tunnel_port", dst_tunnel_port),
            ("qci", qci),
            ("dscp", dscp),
            ("tc", tc),
        ]
    )


class yc_tunnel_info_mec_app_descriptor__mec_appd_traffic_rule_dst_interface_tunnel_info(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/traffic-rule/dst-interface/tunnel-info. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Included only if interfaceType is TUNNEL
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__tunnel_type",
        "__tunnel_dst_address",
        "__tunnel_src_address",
    )

    _yang_name = "tunnel-info"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__tunnel_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"GTP-U": {}, "GRE": {}},
            ),
            is_leaf=True,
            yang_name="tunnel-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__tunnel_dst_address = YANGDynClass(
            base=[
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                    },
                ),
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                    },
                ),
            ],
            is_leaf=True,
            yang_name="tunnel-dst-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )
        self.__tunnel_src_address = YANGDynClass(
            base=[
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                    },
                ),
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                    },
                ),
            ],
            is_leaf=True,
            yang_name="tunnel-src-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "traffic-rule", "dst-interface", "tunnel-info"]

    def _get_tunnel_type(self):
        """
        Getter method for tunnel_type, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/tunnel_info/tunnel_type (enumeration)

        YANG Description: Type of tunnel: GTP-U, GRE, etc
        """
        return self.__tunnel_type

    def _set_tunnel_type(self, v, load=False):
        """
        Setter method for tunnel_type, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/tunnel_info/tunnel_type (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_tunnel_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_tunnel_type() directly.

        YANG Description: Type of tunnel: GTP-U, GRE, etc
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={"GTP-U": {}, "GRE": {}},
                ),
                is_leaf=True,
                yang_name="tunnel-type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """tunnel_type must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GTP-U': {}, 'GRE': {}},), is_leaf=True, yang_name="tunnel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__tunnel_type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_tunnel_type(self):
        self.__tunnel_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"GTP-U": {}, "GRE": {}},
            ),
            is_leaf=True,
            yang_name="tunnel-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_tunnel_dst_address(self):
        """
        Getter method for tunnel_dst_address, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/tunnel_info/tunnel_dst_address (inet:ip-address)

        YANG Description: Destination address of the tunnel
        """
        return self.__tunnel_dst_address

    def _set_tunnel_dst_address(self, v, load=False):
        """
        Setter method for tunnel_dst_address, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/tunnel_info/tunnel_dst_address (inet:ip-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_tunnel_dst_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_tunnel_dst_address() directly.

        YANG Description: Destination address of the tunnel
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ],
                is_leaf=True,
                yang_name="tunnel-dst-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:ip-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """tunnel_dst_address must be of a type compatible with inet:ip-address""",
                    "defined-type": "inet:ip-address",
                    "generated-type": """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnel-dst-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
                }
            )

        self.__tunnel_dst_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_tunnel_dst_address(self):
        self.__tunnel_dst_address = YANGDynClass(
            base=[
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                    },
                ),
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                    },
                ),
            ],
            is_leaf=True,
            yang_name="tunnel-dst-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

    def _get_tunnel_src_address(self):
        """
        Getter method for tunnel_src_address, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/tunnel_info/tunnel_src_address (inet:ip-address)

        YANG Description: Source address of the tunnel
        """
        return self.__tunnel_src_address

    def _set_tunnel_src_address(self, v, load=False):
        """
        Setter method for tunnel_src_address, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/tunnel_info/tunnel_src_address (inet:ip-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_tunnel_src_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_tunnel_src_address() directly.

        YANG Description: Source address of the tunnel
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ],
                is_leaf=True,
                yang_name="tunnel-src-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:ip-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """tunnel_src_address must be of a type compatible with inet:ip-address""",
                    "defined-type": "inet:ip-address",
                    "generated-type": """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnel-src-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
                }
            )

        self.__tunnel_src_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_tunnel_src_address(self):
        self.__tunnel_src_address = YANGDynClass(
            base=[
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                    },
                ),
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                    },
                ),
            ],
            is_leaf=True,
            yang_name="tunnel-src-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

    tunnel_type = __builtin__.property(_get_tunnel_type, _set_tunnel_type)
    tunnel_dst_address = __builtin__.property(
        _get_tunnel_dst_address, _set_tunnel_dst_address
    )
    tunnel_src_address = __builtin__.property(
        _get_tunnel_src_address, _set_tunnel_src_address
    )

    _pyangbind_elements = OrderedDict(
        [
            ("tunnel_type", tunnel_type),
            ("tunnel_dst_address", tunnel_dst_address),
            ("tunnel_src_address", tunnel_src_address),
        ]
    )


class yc_dst_interface_mec_app_descriptor__mec_appd_traffic_rule_dst_interface(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/traffic-rule/dst-interface. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Destination interface if action is FORWARD
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__interface_type",
        "__tunnel_info",
        "__src_mac_address",
        "__dst_mac_address",
        "__dst_ip_address",
    )

    _yang_name = "dst-interface"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__interface_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"TUNNEL": {}, "MAC": {}, "IP": {}},
            ),
            is_leaf=True,
            yang_name="interface-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__tunnel_info = YANGDynClass(
            base=yc_tunnel_info_mec_app_descriptor__mec_appd_traffic_rule_dst_interface_tunnel_info,
            is_container="container",
            yang_name="tunnel-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__src_mac_address = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_dict={"pattern": "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}"},
            ),
            is_leaf=True,
            yang_name="src-mac-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="yang:mac-address",
            is_config=True,
        )
        self.__dst_mac_address = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_dict={"pattern": "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}"},
            ),
            is_leaf=True,
            yang_name="dst-mac-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="yang:mac-address",
            is_config=True,
        )
        self.__dst_ip_address = YANGDynClass(
            base=[
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                    },
                ),
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                    },
                ),
            ],
            is_leaf=True,
            yang_name="dst-ip-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "traffic-rule", "dst-interface"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/id (string)

        YANG Description: Unique identifier for the interface
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Unique identifier for the interface
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_interface_type(self):
        """
        Getter method for interface_type, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/interface_type (enumeration)

        YANG Description: Type of interface: TUNNEL, MAC, IP, etc
        """
        return self.__interface_type

    def _set_interface_type(self, v, load=False):
        """
        Setter method for interface_type, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/interface_type (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_interface_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_interface_type() directly.

        YANG Description: Type of interface: TUNNEL, MAC, IP, etc
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={"TUNNEL": {}, "MAC": {}, "IP": {}},
                ),
                is_leaf=True,
                yang_name="interface-type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """interface_type must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'TUNNEL': {}, 'MAC': {}, 'IP': {}},), is_leaf=True, yang_name="interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__interface_type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_interface_type(self):
        self.__interface_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"TUNNEL": {}, "MAC": {}, "IP": {}},
            ),
            is_leaf=True,
            yang_name="interface-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_tunnel_info(self):
        """
        Getter method for tunnel_info, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/tunnel_info (container)

        YANG Description: Included only if interfaceType is TUNNEL
        """
        return self.__tunnel_info

    def _set_tunnel_info(self, v, load=False):
        """
        Setter method for tunnel_info, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/tunnel_info (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_tunnel_info is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_tunnel_info() directly.

        YANG Description: Included only if interfaceType is TUNNEL
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_tunnel_info_mec_app_descriptor__mec_appd_traffic_rule_dst_interface_tunnel_info,
                is_container="container",
                yang_name="tunnel-info",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """tunnel_info must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_tunnel_info_mec_app_descriptor__mec_appd_traffic_rule_dst_interface_tunnel_info, is_container='container', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__tunnel_info = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_tunnel_info(self):
        self.__tunnel_info = YANGDynClass(
            base=yc_tunnel_info_mec_app_descriptor__mec_appd_traffic_rule_dst_interface_tunnel_info,
            is_container="container",
            yang_name="tunnel-info",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_src_mac_address(self):
        """
        Getter method for src_mac_address, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/src_mac_address (yang:mac-address)

        YANG Description: Source MAC address if interfaceType is MAC
        """
        return self.__src_mac_address

    def _set_src_mac_address(self, v, load=False):
        """
        Setter method for src_mac_address, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/src_mac_address (yang:mac-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_src_mac_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_src_mac_address() directly.

        YANG Description: Source MAC address if interfaceType is MAC
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={"pattern": "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}"},
                ),
                is_leaf=True,
                yang_name="src-mac-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="yang:mac-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """src_mac_address must be of a type compatible with yang:mac-address""",
                    "defined-type": "yang:mac-address",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="src-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)""",
                }
            )

        self.__src_mac_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_src_mac_address(self):
        self.__src_mac_address = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_dict={"pattern": "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}"},
            ),
            is_leaf=True,
            yang_name="src-mac-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="yang:mac-address",
            is_config=True,
        )

    def _get_dst_mac_address(self):
        """
        Getter method for dst_mac_address, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/dst_mac_address (yang:mac-address)

        YANG Description: Destination MAC address if interfaceType is MAC
        """
        return self.__dst_mac_address

    def _set_dst_mac_address(self, v, load=False):
        """
        Setter method for dst_mac_address, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/dst_mac_address (yang:mac-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_dst_mac_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_dst_mac_address() directly.

        YANG Description: Destination MAC address if interfaceType is MAC
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={"pattern": "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}"},
                ),
                is_leaf=True,
                yang_name="dst-mac-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="yang:mac-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """dst_mac_address must be of a type compatible with yang:mac-address""",
                    "defined-type": "yang:mac-address",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="dst-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)""",
                }
            )

        self.__dst_mac_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_dst_mac_address(self):
        self.__dst_mac_address = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_dict={"pattern": "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}"},
            ),
            is_leaf=True,
            yang_name="dst-mac-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="yang:mac-address",
            is_config=True,
        )

    def _get_dst_ip_address(self):
        """
        Getter method for dst_ip_address, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/dst_ip_address (inet:ip-address)

        YANG Description: Destination IP address if interfaceType is IP
        """
        return self.__dst_ip_address

    def _set_dst_ip_address(self, v, load=False):
        """
        Setter method for dst_ip_address, mapped from YANG variable /mec_appd/traffic_rule/dst_interface/dst_ip_address (inet:ip-address)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_dst_ip_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_dst_ip_address() directly.

        YANG Description: Destination IP address if interfaceType is IP
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=[
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                    RestrictedClassType(
                        base_type=six.text_type,
                        restriction_dict={
                            "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                        },
                    ),
                ],
                is_leaf=True,
                yang_name="dst-ip-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="inet:ip-address",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """dst_ip_address must be of a type compatible with inet:ip-address""",
                    "defined-type": "inet:ip-address",
                    "generated-type": """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="dst-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
                }
            )

        self.__dst_ip_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_dst_ip_address(self):
        self.__dst_ip_address = YANGDynClass(
            base=[
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?"
                    },
                ),
                RestrictedClassType(
                    base_type=six.text_type,
                    restriction_dict={
                        "pattern": "((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?"
                    },
                ),
            ],
            is_leaf=True,
            yang_name="dst-ip-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="inet:ip-address",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    interface_type = __builtin__.property(_get_interface_type, _set_interface_type)
    tunnel_info = __builtin__.property(_get_tunnel_info, _set_tunnel_info)
    src_mac_address = __builtin__.property(_get_src_mac_address, _set_src_mac_address)
    dst_mac_address = __builtin__.property(_get_dst_mac_address, _set_dst_mac_address)
    dst_ip_address = __builtin__.property(_get_dst_ip_address, _set_dst_ip_address)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("interface_type", interface_type),
            ("tunnel_info", tunnel_info),
            ("src_mac_address", src_mac_address),
            ("dst_mac_address", dst_mac_address),
            ("dst_ip_address", dst_ip_address),
        ]
    )


class yc_traffic_rule_mec_app_descriptor__mec_appd_traffic_rule(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/traffic-rule. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes traffic rules the MEC application requires.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__filter_type",
        "__priority",
        "__action",
        "__traffic_filter",
        "__dst_interface",
    )

    _yang_name = "traffic-rule"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__filter_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"FLOW": {}, "PACKET": {}},
            ),
            is_leaf=True,
            yang_name="filter-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__priority = YANGDynClass(
            base=RestrictedClassType(
                base_type=RestrictedClassType(
                    base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
                ),
                restriction_dict={"range": ["0..255"]},
            ),
            is_leaf=True,
            yang_name="priority",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint8",
            is_config=True,
        )
        self.__action = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "DROP": {},
                    "FORWARD_DECAPSULATED": {},
                    "FORWARD_AS_IS": {},
                    "PASSTHROUGH": {},
                    "DUPLICATED_DECAPSULATED": {},
                    "DUPLICATE_AS_IS": {},
                },
            ),
            is_leaf=True,
            yang_name="action",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__traffic_filter = YANGDynClass(
            base=YANGListType(
                "id",
                yc_traffic_filter_mec_app_descriptor__mec_appd_traffic_rule_traffic_filter,
                yang_name="traffic-filter",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="traffic-filter",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__dst_interface = YANGDynClass(
            base=YANGListType(
                "id",
                yc_dst_interface_mec_app_descriptor__mec_appd_traffic_rule_dst_interface,
                yang_name="dst-interface",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="dst-interface",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "traffic-rule"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/traffic_rule/id (string)

        YANG Description: Identifies the traffic rule
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/traffic_rule/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Identifies the traffic rule
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_filter_type(self):
        """
        Getter method for filter_type, mapped from YANG variable /mec_appd/traffic_rule/filter_type (enumeration)

        YANG Description: Filter type: per FLOW or PACKET
        """
        return self.__filter_type

    def _set_filter_type(self, v, load=False):
        """
        Setter method for filter_type, mapped from YANG variable /mec_appd/traffic_rule/filter_type (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_filter_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_filter_type() directly.

        YANG Description: Filter type: per FLOW or PACKET
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={"FLOW": {}, "PACKET": {}},
                ),
                is_leaf=True,
                yang_name="filter-type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """filter_type must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FLOW': {}, 'PACKET': {}},), is_leaf=True, yang_name="filter-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__filter_type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_filter_type(self):
        self.__filter_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"FLOW": {}, "PACKET": {}},
            ),
            is_leaf=True,
            yang_name="filter-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_priority(self):
        """
        Getter method for priority, mapped from YANG variable /mec_appd/traffic_rule/priority (uint8)

        YANG Description: Priority of traffic rule from 0 to 255
        """
        return self.__priority

    def _set_priority(self, v, load=False):
        """
        Setter method for priority, mapped from YANG variable /mec_appd/traffic_rule/priority (uint8)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_priority is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_priority() directly.

        YANG Description: Priority of traffic rule from 0 to 255
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=RestrictedClassType(
                        base_type=int,
                        restriction_dict={"range": ["0..255"]},
                        int_size=8,
                    ),
                    restriction_dict={"range": ["0..255"]},
                ),
                is_leaf=True,
                yang_name="priority",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint8",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """priority must be of a type compatible with uint8""",
                    "defined-type": "uint8",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
                }
            )

        self.__priority = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_priority(self):
        self.__priority = YANGDynClass(
            base=RestrictedClassType(
                base_type=RestrictedClassType(
                    base_type=int, restriction_dict={"range": ["0..255"]}, int_size=8
                ),
                restriction_dict={"range": ["0..255"]},
            ),
            is_leaf=True,
            yang_name="priority",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint8",
            is_config=True,
        )

    def _get_action(self):
        """
        Getter method for action, mapped from YANG variable /mec_appd/traffic_rule/action (enumeration)

        YANG Description: Action when packet matches traffic filter
        """
        return self.__action

    def _set_action(self, v, load=False):
        """
        Setter method for action, mapped from YANG variable /mec_appd/traffic_rule/action (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_action is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_action() directly.

        YANG Description: Action when packet matches traffic filter
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={
                        "DROP": {},
                        "FORWARD_DECAPSULATED": {},
                        "FORWARD_AS_IS": {},
                        "PASSTHROUGH": {},
                        "DUPLICATED_DECAPSULATED": {},
                        "DUPLICATE_AS_IS": {},
                    },
                ),
                is_leaf=True,
                yang_name="action",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """action must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DROP': {}, 'FORWARD_DECAPSULATED': {}, 'FORWARD_AS_IS': {}, 'PASSTHROUGH': {}, 'DUPLICATED_DECAPSULATED': {}, 'DUPLICATE_AS_IS': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__action = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_action(self):
        self.__action = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={
                    "DROP": {},
                    "FORWARD_DECAPSULATED": {},
                    "FORWARD_AS_IS": {},
                    "PASSTHROUGH": {},
                    "DUPLICATED_DECAPSULATED": {},
                    "DUPLICATE_AS_IS": {},
                },
            ),
            is_leaf=True,
            yang_name="action",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_traffic_filter(self):
        """
        Getter method for traffic_filter, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter (list)

        YANG Description: Filter to identify specific flow/packets
        """
        return self.__traffic_filter

    def _set_traffic_filter(self, v, load=False):
        """
        Setter method for traffic_filter, mapped from YANG variable /mec_appd/traffic_rule/traffic_filter (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_traffic_filter is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_traffic_filter() directly.

        YANG Description: Filter to identify specific flow/packets
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_traffic_filter_mec_app_descriptor__mec_appd_traffic_rule_traffic_filter,
                    yang_name="traffic-filter",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="traffic-filter",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """traffic_filter must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_traffic_filter_mec_app_descriptor__mec_appd_traffic_rule_traffic_filter, yang_name="traffic-filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="traffic-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__traffic_filter = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_traffic_filter(self):
        self.__traffic_filter = YANGDynClass(
            base=YANGListType(
                "id",
                yc_traffic_filter_mec_app_descriptor__mec_appd_traffic_rule_traffic_filter,
                yang_name="traffic-filter",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="traffic-filter",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_dst_interface(self):
        """
        Getter method for dst_interface, mapped from YANG variable /mec_appd/traffic_rule/dst_interface (list)

        YANG Description: Destination interface if action is FORWARD
        """
        return self.__dst_interface

    def _set_dst_interface(self, v, load=False):
        """
        Setter method for dst_interface, mapped from YANG variable /mec_appd/traffic_rule/dst_interface (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_dst_interface is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_dst_interface() directly.

        YANG Description: Destination interface if action is FORWARD
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_dst_interface_mec_app_descriptor__mec_appd_traffic_rule_dst_interface,
                    yang_name="dst-interface",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="dst-interface",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """dst_interface must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_dst_interface_mec_app_descriptor__mec_appd_traffic_rule_dst_interface, yang_name="dst-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dst-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__dst_interface = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_dst_interface(self):
        self.__dst_interface = YANGDynClass(
            base=YANGListType(
                "id",
                yc_dst_interface_mec_app_descriptor__mec_appd_traffic_rule_dst_interface,
                yang_name="dst-interface",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="dst-interface",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    filter_type = __builtin__.property(_get_filter_type, _set_filter_type)
    priority = __builtin__.property(_get_priority, _set_priority)
    action = __builtin__.property(_get_action, _set_action)
    traffic_filter = __builtin__.property(_get_traffic_filter, _set_traffic_filter)
    dst_interface = __builtin__.property(_get_dst_interface, _set_dst_interface)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("filter_type", filter_type),
            ("priority", priority),
            ("action", action),
            ("traffic_filter", traffic_filter),
            ("dst_interface", dst_interface),
        ]
    )


class yc_dns_rule_mec_app_descriptor__mec_appd_dns_rule(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/dns-rule. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes DNS rules the MEC application requires.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__domain_name",
        "__ip_address_type",
        "__ip_address",
        "__ttl",
    )

    _yang_name = "dns-rule"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__domain_name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="domain-name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"IP_V4": {}, "IP_V6": {}},
            ),
            is_leaf=True,
            yang_name="ip-address-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )
        self.__ip_address = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="ip-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__ttl = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="ttl",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "dns-rule"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/dns_rule/id (string)

        YANG Description: Identifies the DNS Rule.
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/dns_rule/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Identifies the DNS Rule.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_domain_name(self):
        """
        Getter method for domain_name, mapped from YANG variable /mec_appd/dns_rule/domain_name (string)

        YANG Description: FQDN of the DNS rule.
        """
        return self.__domain_name

    def _set_domain_name(self, v, load=False):
        """
        Setter method for domain_name, mapped from YANG variable /mec_appd/dns_rule/domain_name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_domain_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_domain_name() directly.

        YANG Description: FQDN of the DNS rule.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="domain-name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """domain_name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__domain_name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_domain_name(self):
        self.__domain_name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="domain-name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_ip_address_type(self):
        """
        Getter method for ip_address_type, mapped from YANG variable /mec_appd/dns_rule/ip_address_type (enumeration)

        YANG Description: Specifies the IP address type, value: IP_V6, IP_V4.
        """
        return self.__ip_address_type

    def _set_ip_address_type(self, v, load=False):
        """
        Setter method for ip_address_type, mapped from YANG variable /mec_appd/dns_rule/ip_address_type (enumeration)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_ip_address_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_ip_address_type() directly.

        YANG Description: Specifies the IP address type, value: IP_V6, IP_V4.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=six.text_type,
                    restriction_type="dict_key",
                    restriction_arg={"IP_V4": {}, "IP_V6": {}},
                ),
                is_leaf=True,
                yang_name="ip-address-type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="enumeration",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """ip_address_type must be of a type compatible with enumeration""",
                    "defined-type": "mec-app-descriptor:enumeration",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
                }
            )

        self.__ip_address_type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_ip_address_type(self):
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(
                base_type=six.text_type,
                restriction_type="dict_key",
                restriction_arg={"IP_V4": {}, "IP_V6": {}},
            ),
            is_leaf=True,
            yang_name="ip-address-type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="enumeration",
            is_config=True,
        )

    def _get_ip_address(self):
        """
        Getter method for ip_address, mapped from YANG variable /mec_appd/dns_rule/ip_address (string)

        YANG Description: IP address given by the DNS rule.
        """
        return self.__ip_address

    def _set_ip_address(self, v, load=False):
        """
        Setter method for ip_address, mapped from YANG variable /mec_appd/dns_rule/ip_address (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_ip_address is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_ip_address() directly.

        YANG Description: IP address given by the DNS rule.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="ip-address",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """ip_address must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__ip_address = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_ip_address(self):
        self.__ip_address = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="ip-address",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_ttl(self):
        """
        Getter method for ttl, mapped from YANG variable /mec_appd/dns_rule/ttl (uint32)

        YANG Description: Time-to-live value.
        """
        return self.__ttl

    def _set_ttl(self, v, load=False):
        """
        Setter method for ttl, mapped from YANG variable /mec_appd/dns_rule/ttl (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_ttl is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_ttl() directly.

        YANG Description: Time-to-live value.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="ttl",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """ttl must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__ttl = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_ttl(self):
        self.__ttl = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="ttl",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    domain_name = __builtin__.property(_get_domain_name, _set_domain_name)
    ip_address_type = __builtin__.property(_get_ip_address_type, _set_ip_address_type)
    ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
    ttl = __builtin__.property(_get_ttl, _set_ttl)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("domain_name", domain_name),
            ("ip_address_type", ip_address_type),
            ("ip_address", ip_address),
            ("ttl", ttl),
        ]
    )


class yc_latency_mec_app_descriptor__mec_appd_latency(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/latency. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Describes the maximum latency tolerated by the MEC application.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__max_latency",
    )

    _yang_name = "latency"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__max_latency = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="max-latency",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "latency"]

    def _get_max_latency(self):
        """
        Getter method for max_latency, mapped from YANG variable /mec_appd/latency/max_latency (uint32)

        YANG Description: The value of the maximum latency in nano seconds tolerated by the MEC application.
        """
        return self.__max_latency

    def _set_max_latency(self, v, load=False):
        """
        Setter method for max_latency, mapped from YANG variable /mec_appd/latency/max_latency (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_latency is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_latency() directly.

        YANG Description: The value of the maximum latency in nano seconds tolerated by the MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="max-latency",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """max_latency must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__max_latency = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_max_latency(self):
        self.__max_latency = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="max-latency",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    max_latency = __builtin__.property(_get_max_latency, _set_max_latency)

    _pyangbind_elements = OrderedDict(
        [
            ("max_latency", max_latency),
        ]
    )


class yc_vnf_parameters_mec_app_descriptor__mec_appd_terminate_app_instance_op_config_vnf_parameters(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/terminate-app-instance-op-config/vnf-parameters. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "vnf-parameters"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "terminate-app-instance-op-config", "vnf-parameters"]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/terminate_app_instance_op_config/vnf_parameters/key (string)

        YANG Description: Key of the VNF-specific parameter.
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/terminate_app_instance_op_config/vnf_parameters/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key of the VNF-specific parameter.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/terminate_app_instance_op_config/vnf_parameters/value (string)

        YANG Description: Value of the VNF-specific parameter.
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/terminate_app_instance_op_config/vnf_parameters/value (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value of the VNF-specific parameter.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_terminate_app_instance_op_config_mec_app_descriptor__mec_appd_terminate_app_instance_op_config(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/terminate-app-instance-op-config. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Configuration parameters for the Terminate application instance operation.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__min_graceful_termination_timeout",
        "__max_recommended_graceful_termination_timeout",
        "__vnf_parameters",
    )

    _yang_name = "terminate-app-instance-op-config"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__min_graceful_termination_timeout = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="min-graceful-termination-timeout",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )
        self.__max_recommended_graceful_termination_timeout = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="max-recommended-graceful-termination-timeout",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )
        self.__vnf_parameters = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vnf_parameters_mec_app_descriptor__mec_appd_terminate_app_instance_op_config_vnf_parameters,
                yang_name="vnf-parameters",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="vnf-parameters",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "terminate-app-instance-op-config"]

    def _get_min_graceful_termination_timeout(self):
        """
        Getter method for min_graceful_termination_timeout, mapped from YANG variable /mec_appd/terminate_app_instance_op_config/min_graceful_termination_timeout (uint32)

        YANG Description: Minimum timeout value for graceful termination of a VNF instance.
        """
        return self.__min_graceful_termination_timeout

    def _set_min_graceful_termination_timeout(self, v, load=False):
        """
        Setter method for min_graceful_termination_timeout, mapped from YANG variable /mec_appd/terminate_app_instance_op_config/min_graceful_termination_timeout (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_min_graceful_termination_timeout is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_min_graceful_termination_timeout() directly.

        YANG Description: Minimum timeout value for graceful termination of a VNF instance.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="min-graceful-termination-timeout",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """min_graceful_termination_timeout must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-graceful-termination-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__min_graceful_termination_timeout = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_min_graceful_termination_timeout(self):
        self.__min_graceful_termination_timeout = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="min-graceful-termination-timeout",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    def _get_max_recommended_graceful_termination_timeout(self):
        """
        Getter method for max_recommended_graceful_termination_timeout, mapped from YANG variable /mec_appd/terminate_app_instance_op_config/max_recommended_graceful_termination_timeout (uint32)

        YANG Description: Maximum recommended timeout value that can be needed to gracefully terminate a VNF instance of a particular type under certain conditions, such as maximum load condition.
        """
        return self.__max_recommended_graceful_termination_timeout

    def _set_max_recommended_graceful_termination_timeout(self, v, load=False):
        """
        Setter method for max_recommended_graceful_termination_timeout, mapped from YANG variable /mec_appd/terminate_app_instance_op_config/max_recommended_graceful_termination_timeout (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_recommended_graceful_termination_timeout is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_recommended_graceful_termination_timeout() directly.

        YANG Description: Maximum recommended timeout value that can be needed to gracefully terminate a VNF instance of a particular type under certain conditions, such as maximum load condition.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="max-recommended-graceful-termination-timeout",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """max_recommended_graceful_termination_timeout must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-termination-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__max_recommended_graceful_termination_timeout = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_max_recommended_graceful_termination_timeout(self):
        self.__max_recommended_graceful_termination_timeout = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="max-recommended-graceful-termination-timeout",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    def _get_vnf_parameters(self):
        """
        Getter method for vnf_parameters, mapped from YANG variable /mec_appd/terminate_app_instance_op_config/vnf_parameters (list)

        YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
        """
        return self.__vnf_parameters

    def _set_vnf_parameters(self, v, load=False):
        """
        Setter method for vnf_parameters, mapped from YANG variable /mec_appd/terminate_app_instance_op_config/vnf_parameters (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_vnf_parameters is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_vnf_parameters() directly.

        YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_vnf_parameters_mec_app_descriptor__mec_appd_terminate_app_instance_op_config_vnf_parameters,
                    yang_name="vnf-parameters",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="vnf-parameters",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """vnf_parameters must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_vnf_parameters_mec_app_descriptor__mec_appd_terminate_app_instance_op_config_vnf_parameters, yang_name="vnf-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vnf-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__vnf_parameters = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_vnf_parameters(self):
        self.__vnf_parameters = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vnf_parameters_mec_app_descriptor__mec_appd_terminate_app_instance_op_config_vnf_parameters,
                yang_name="vnf-parameters",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="vnf-parameters",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    min_graceful_termination_timeout = __builtin__.property(
        _get_min_graceful_termination_timeout, _set_min_graceful_termination_timeout
    )
    max_recommended_graceful_termination_timeout = __builtin__.property(
        _get_max_recommended_graceful_termination_timeout,
        _set_max_recommended_graceful_termination_timeout,
    )
    vnf_parameters = __builtin__.property(_get_vnf_parameters, _set_vnf_parameters)

    _pyangbind_elements = OrderedDict(
        [
            ("min_graceful_termination_timeout", min_graceful_termination_timeout),
            (
                "max_recommended_graceful_termination_timeout",
                max_recommended_graceful_termination_timeout,
            ),
            ("vnf_parameters", vnf_parameters),
        ]
    )


class yc_vnf_parameters_mec_app_descriptor__mec_appd_change_app_instance_state_op_config_vnf_parameters(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/change-app-instance-state-op-config/vnf-parameters. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__key",
        "__value",
    )

    _yang_name = "vnf-parameters"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__value = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "change-app-instance-state-op-config", "vnf-parameters"]

    def _get_key(self):
        """
        Getter method for key, mapped from YANG variable /mec_appd/change_app_instance_state_op_config/vnf_parameters/key (string)

        YANG Description: Key of the VNF-specific parameter.
        """
        return self.__key

    def _set_key(self, v, load=False):
        """
        Setter method for key, mapped from YANG variable /mec_appd/change_app_instance_state_op_config/vnf_parameters/key (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_key is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_key() directly.

        YANG Description: Key of the VNF-specific parameter.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="key",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """key must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__key = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="key",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_value(self):
        """
        Getter method for value, mapped from YANG variable /mec_appd/change_app_instance_state_op_config/vnf_parameters/value (string)

        YANG Description: Value of the VNF-specific parameter.
        """
        return self.__value

    def _set_value(self, v, load=False):
        """
        Setter method for value, mapped from YANG variable /mec_appd/change_app_instance_state_op_config/vnf_parameters/value (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_value is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_value() directly.

        YANG Description: Value of the VNF-specific parameter.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="value",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """value must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__value = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="value",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict(
        [
            ("key", key),
            ("value", value),
        ]
    )


class yc_change_app_instance_state_op_config_mec_app_descriptor__mec_appd_change_app_instance_state_op_config(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/change-app-instance-state-op-config. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Configuration parameters for the change application instance state operation.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__min_graceful_stop_timeout",
        "__max_recommended_graceful_stop_timeout",
        "__vnf_parameters",
    )

    _yang_name = "change-app-instance-state-op-config"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__min_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="min-graceful-stop-timeout",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )
        self.__max_recommended_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="max-recommended-graceful-stop-timeout",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )
        self.__vnf_parameters = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vnf_parameters_mec_app_descriptor__mec_appd_change_app_instance_state_op_config_vnf_parameters,
                yang_name="vnf-parameters",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="vnf-parameters",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "change-app-instance-state-op-config"]

    def _get_min_graceful_stop_timeout(self):
        """
        Getter method for min_graceful_stop_timeout, mapped from YANG variable /mec_appd/change_app_instance_state_op_config/min_graceful_stop_timeout (uint32)

        YANG Description: Minimum timeout value for graceful stop of a VNF instance.
        """
        return self.__min_graceful_stop_timeout

    def _set_min_graceful_stop_timeout(self, v, load=False):
        """
        Setter method for min_graceful_stop_timeout, mapped from YANG variable /mec_appd/change_app_instance_state_op_config/min_graceful_stop_timeout (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_min_graceful_stop_timeout is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_min_graceful_stop_timeout() directly.

        YANG Description: Minimum timeout value for graceful stop of a VNF instance.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="min-graceful-stop-timeout",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """min_graceful_stop_timeout must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__min_graceful_stop_timeout = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_min_graceful_stop_timeout(self):
        self.__min_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="min-graceful-stop-timeout",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    def _get_max_recommended_graceful_stop_timeout(self):
        """
        Getter method for max_recommended_graceful_stop_timeout, mapped from YANG variable /mec_appd/change_app_instance_state_op_config/max_recommended_graceful_stop_timeout (uint32)

        YANG Description: Maximum recommended timeout value that can be needed to gracefully stop a VNF instance of a particular type under certain conditions, such as maximum load condition.
        """
        return self.__max_recommended_graceful_stop_timeout

    def _set_max_recommended_graceful_stop_timeout(self, v, load=False):
        """
        Setter method for max_recommended_graceful_stop_timeout, mapped from YANG variable /mec_appd/change_app_instance_state_op_config/max_recommended_graceful_stop_timeout (uint32)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_recommended_graceful_stop_timeout is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_recommended_graceful_stop_timeout() directly.

        YANG Description: Maximum recommended timeout value that can be needed to gracefully stop a VNF instance of a particular type under certain conditions, such as maximum load condition.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=RestrictedClassType(
                    base_type=long,
                    restriction_dict={"range": ["0..4294967295"]},
                    int_size=32,
                ),
                is_leaf=True,
                yang_name="max-recommended-graceful-stop-timeout",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="uint32",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """max_recommended_graceful_stop_timeout must be of a type compatible with uint32""",
                    "defined-type": "uint32",
                    "generated-type": """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
                }
            )

        self.__max_recommended_graceful_stop_timeout = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_max_recommended_graceful_stop_timeout(self):
        self.__max_recommended_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(
                base_type=long,
                restriction_dict={"range": ["0..4294967295"]},
                int_size=32,
            ),
            is_leaf=True,
            yang_name="max-recommended-graceful-stop-timeout",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="uint32",
            is_config=True,
        )

    def _get_vnf_parameters(self):
        """
        Getter method for vnf_parameters, mapped from YANG variable /mec_appd/change_app_instance_state_op_config/vnf_parameters (list)

        YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
        """
        return self.__vnf_parameters

    def _set_vnf_parameters(self, v, load=False):
        """
        Setter method for vnf_parameters, mapped from YANG variable /mec_appd/change_app_instance_state_op_config/vnf_parameters (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_vnf_parameters is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_vnf_parameters() directly.

        YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "key",
                    yc_vnf_parameters_mec_app_descriptor__mec_appd_change_app_instance_state_op_config_vnf_parameters,
                    yang_name="vnf-parameters",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="key",
                    extensions=None,
                ),
                is_container="list",
                yang_name="vnf-parameters",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """vnf_parameters must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("key",yc_vnf_parameters_mec_app_descriptor__mec_appd_change_app_instance_state_op_config_vnf_parameters, yang_name="vnf-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vnf-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__vnf_parameters = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_vnf_parameters(self):
        self.__vnf_parameters = YANGDynClass(
            base=YANGListType(
                "key",
                yc_vnf_parameters_mec_app_descriptor__mec_appd_change_app_instance_state_op_config_vnf_parameters,
                yang_name="vnf-parameters",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="key",
                extensions=None,
            ),
            is_container="list",
            yang_name="vnf-parameters",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    min_graceful_stop_timeout = __builtin__.property(
        _get_min_graceful_stop_timeout, _set_min_graceful_stop_timeout
    )
    max_recommended_graceful_stop_timeout = __builtin__.property(
        _get_max_recommended_graceful_stop_timeout,
        _set_max_recommended_graceful_stop_timeout,
    )
    vnf_parameters = __builtin__.property(_get_vnf_parameters, _set_vnf_parameters)

    _pyangbind_elements = OrderedDict(
        [
            ("min_graceful_stop_timeout", min_graceful_stop_timeout),
            (
                "max_recommended_graceful_stop_timeout",
                max_recommended_graceful_stop_timeout,
            ),
            ("vnf_parameters", vnf_parameters),
        ]
    )


class yc_user_context_transfer_capability_mec_app_descriptor__mec_appd_user_context_transfer_capability(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/user-context-transfer-capability. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: If the application supports the user context transfer capability, this attribute shall be included.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__stateful_application",
        "__user_context_transfer_support",
    )

    _yang_name = "user-context-transfer-capability"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__stateful_application = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="stateful-application",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )
        self.__user_context_transfer_support = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="user-context-transfer-support",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "user-context-transfer-capability"]

    def _get_stateful_application(self):
        """
        Getter method for stateful_application, mapped from YANG variable /mec_appd/user_context_transfer_capability/stateful_application (boolean)

        YANG Description: If the application is stateful, this attribute shall be set to true. Otherwise, this attribute shall be set to false.
        """
        return self.__stateful_application

    def _set_stateful_application(self, v, load=False):
        """
        Setter method for stateful_application, mapped from YANG variable /mec_appd/user_context_transfer_capability/stateful_application (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_stateful_application is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_stateful_application() directly.

        YANG Description: If the application is stateful, this attribute shall be set to true. Otherwise, this attribute shall be set to false.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                is_leaf=True,
                yang_name="stateful-application",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """stateful_application must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stateful-application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__stateful_application = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_stateful_application(self):
        self.__stateful_application = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="stateful-application",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    def _get_user_context_transfer_support(self):
        """
        Getter method for user_context_transfer_support, mapped from YANG variable /mec_appd/user_context_transfer_capability/user_context_transfer_support (boolean)

        YANG Description: This attribute shall be present if the application is stateful and supports the user context transfer. Otherwise, this attribute shall be set to false or be absent.
        """
        return self.__user_context_transfer_support

    def _set_user_context_transfer_support(self, v, load=False):
        """
        Setter method for user_context_transfer_support, mapped from YANG variable /mec_appd/user_context_transfer_capability/user_context_transfer_support (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_user_context_transfer_support is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_user_context_transfer_support() directly.

        YANG Description: This attribute shall be present if the application is stateful and supports the user context transfer. Otherwise, this attribute shall be set to false or be absent.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                is_leaf=True,
                yang_name="user-context-transfer-support",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """user_context_transfer_support must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="user-context-transfer-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__user_context_transfer_support = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_user_context_transfer_support(self):
        self.__user_context_transfer_support = YANGDynClass(
            base=YANGBool,
            is_leaf=True,
            yang_name="user-context-transfer-support",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    stateful_application = __builtin__.property(
        _get_stateful_application, _set_stateful_application
    )
    user_context_transfer_support = __builtin__.property(
        _get_user_context_transfer_support, _set_user_context_transfer_support
    )

    _pyangbind_elements = OrderedDict(
        [
            ("stateful_application", stateful_application),
            ("user_context_transfer_support", user_context_transfer_support),
        ]
    )


class yc_steered_network_mec_app_descriptor__mec_appd_network_policy_steered_network(
    PybindBase
):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/network-policy/steered-network. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__cellular_network",
        "__wifi_network",
        "__fixed_access_network",
    )

    _yang_name = "steered-network"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__cellular_network = YANGDynClass(
            base=YANGBool,
            default=YANGBool("false"),
            is_leaf=True,
            yang_name="cellular-network",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )
        self.__wifi_network = YANGDynClass(
            base=YANGBool,
            default=YANGBool("false"),
            is_leaf=True,
            yang_name="wifi-network",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )
        self.__fixed_access_network = YANGDynClass(
            base=YANGBool,
            default=YANGBool("false"),
            is_leaf=True,
            yang_name="fixed-access-network",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "network-policy", "steered-network"]

    def _get_cellular_network(self):
        """
        Getter method for cellular_network, mapped from YANG variable /mec_appd/network_policy/steered_network/cellular_network (boolean)

        YANG Description: If present, and the application prefers to a cellular network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
        """
        return self.__cellular_network

    def _set_cellular_network(self, v, load=False):
        """
        Setter method for cellular_network, mapped from YANG variable /mec_appd/network_policy/steered_network/cellular_network (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_cellular_network is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_cellular_network() directly.

        YANG Description: If present, and the application prefers to a cellular network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                default=YANGBool("false"),
                is_leaf=True,
                yang_name="cellular-network",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """cellular_network must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellular-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__cellular_network = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_cellular_network(self):
        self.__cellular_network = YANGDynClass(
            base=YANGBool,
            default=YANGBool("false"),
            is_leaf=True,
            yang_name="cellular-network",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    def _get_wifi_network(self):
        """
        Getter method for wifi_network, mapped from YANG variable /mec_appd/network_policy/steered_network/wifi_network (boolean)

        YANG Description: If present, and the application prefers to a Wi-Fi network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
        """
        return self.__wifi_network

    def _set_wifi_network(self, v, load=False):
        """
        Setter method for wifi_network, mapped from YANG variable /mec_appd/network_policy/steered_network/wifi_network (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_wifi_network is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_wifi_network() directly.

        YANG Description: If present, and the application prefers to a Wi-Fi network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                default=YANGBool("false"),
                is_leaf=True,
                yang_name="wifi-network",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """wifi_network must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wifi-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__wifi_network = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_wifi_network(self):
        self.__wifi_network = YANGDynClass(
            base=YANGBool,
            default=YANGBool("false"),
            is_leaf=True,
            yang_name="wifi-network",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    def _get_fixed_access_network(self):
        """
        Getter method for fixed_access_network, mapped from YANG variable /mec_appd/network_policy/steered_network/fixed_access_network (boolean)

        YANG Description: If present, and the application prefers to a fixed access network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
        """
        return self.__fixed_access_network

    def _set_fixed_access_network(self, v, load=False):
        """
        Setter method for fixed_access_network, mapped from YANG variable /mec_appd/network_policy/steered_network/fixed_access_network (boolean)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_fixed_access_network is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_fixed_access_network() directly.

        YANG Description: If present, and the application prefers to a fixed access network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGBool,
                default=YANGBool("false"),
                is_leaf=True,
                yang_name="fixed-access-network",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="boolean",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """fixed_access_network must be of a type compatible with boolean""",
                    "defined-type": "boolean",
                    "generated-type": """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixed-access-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
                }
            )

        self.__fixed_access_network = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_fixed_access_network(self):
        self.__fixed_access_network = YANGDynClass(
            base=YANGBool,
            default=YANGBool("false"),
            is_leaf=True,
            yang_name="fixed-access-network",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="boolean",
            is_config=True,
        )

    cellular_network = __builtin__.property(
        _get_cellular_network, _set_cellular_network
    )
    wifi_network = __builtin__.property(_get_wifi_network, _set_wifi_network)
    fixed_access_network = __builtin__.property(
        _get_fixed_access_network, _set_fixed_access_network
    )

    _pyangbind_elements = OrderedDict(
        [
            ("cellular_network", cellular_network),
            ("wifi_network", wifi_network),
            ("fixed_access_network", fixed_access_network),
        ]
    )


class yc_network_policy_mec_app_descriptor__mec_appd_network_policy(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/network-policy. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: If present, it represents the application network policy of carrying the application traffic.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__steered_network",
    )

    _yang_name = "network-policy"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__steered_network = YANGDynClass(
            base=yc_steered_network_mec_app_descriptor__mec_appd_network_policy_steered_network,
            is_container="container",
            yang_name="steered-network",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "network-policy"]

    def _get_steered_network(self):
        """
        Getter method for steered_network, mapped from YANG variable /mec_appd/network_policy/steered_network (container)
        """
        return self.__steered_network

    def _set_steered_network(self, v, load=False):
        """
        Setter method for steered_network, mapped from YANG variable /mec_appd/network_policy/steered_network (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_steered_network is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_steered_network() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_steered_network_mec_app_descriptor__mec_appd_network_policy_steered_network,
                is_container="container",
                yang_name="steered-network",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """steered_network must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_steered_network_mec_app_descriptor__mec_appd_network_policy_steered_network, is_container='container', yang_name="steered-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__steered_network = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_steered_network(self):
        self.__steered_network = YANGDynClass(
            base=yc_steered_network_mec_app_descriptor__mec_appd_network_policy_steered_network,
            is_container="container",
            yang_name="steered-network",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    steered_network = __builtin__.property(_get_steered_network, _set_steered_network)

    _pyangbind_elements = OrderedDict(
        [
            ("steered_network", steered_network),
        ]
    )


class yc_artifacts_mec_app_descriptor__mec_appd_artifacts(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd/artifacts. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: List of artifacts required by the MEC application.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__name",
        "__description",
        "__type",
        "__file",
    )

    _yang_name = "artifacts"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__type = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__file = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="file",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd", "artifacts"]

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/artifacts/name (string)

        YANG Description: Name of the artifact.
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/artifacts/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: Name of the artifact.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError(
                "Cannot set keys directly when" + " within an instantiated list"
            )

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                is_keyval=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            is_keyval=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_description(self):
        """
        Getter method for description, mapped from YANG variable /mec_appd/artifacts/description (string)

        YANG Description: Description of the artifact.
        """
        return self.__description

    def _set_description(self, v, load=False):
        """
        Setter method for description, mapped from YANG variable /mec_appd/artifacts/description (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_description is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_description() directly.

        YANG Description: Description of the artifact.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="description",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """description must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__description = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_type(self):
        """
        Getter method for type, mapped from YANG variable /mec_appd/artifacts/type (string)

        YANG Description: Type of the artifact.
        """
        return self.__type

    def _set_type(self, v, load=False):
        """
        Setter method for type, mapped from YANG variable /mec_appd/artifacts/type (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_type() directly.

        YANG Description: Type of the artifact.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="type",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """type must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__type = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="type",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_file(self):
        """
        Getter method for file, mapped from YANG variable /mec_appd/artifacts/file (string)

        YANG Description: File name of the artifact.
        """
        return self.__file

    def _set_file(self, v, load=False):
        """
        Setter method for file, mapped from YANG variable /mec_appd/artifacts/file (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_file is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_file() directly.

        YANG Description: File name of the artifact.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="file",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """file must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__file = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_file(self):
        self.__file = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="file",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    type = __builtin__.property(_get_type, _set_type)
    file = __builtin__.property(_get_file, _set_file)

    _pyangbind_elements = OrderedDict(
        [
            ("name", name),
            ("description", description),
            ("type", type),
            ("file", file),
        ]
    )


class yc_mec_appd_mec_app_descriptor__mec_appd(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-appd. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__id",
        "__name",
        "__provider",
        "__soft_version",
        "__version",
        "__mec_version",
        "__info_name",
        "__description",
        "__virtual_compute",
        "__sw_image",
        "__virtual_storage",
        "__ext_cpd",
        "__service_required",
        "__service_optional",
        "__service_produced",
        "__feature_required",
        "__feature_optional",
        "__transport_dependencies",
        "__traffic_rule",
        "__dns_rule",
        "__latency",
        "__terminate_app_instance_op_config",
        "__change_app_instance_state_op_config",
        "__user_context_transfer_capability",
        "__network_policy",
        "__artifacts",
    )

    _yang_name = "mec-appd"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__provider = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="provider",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__soft_version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="soft-version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__mec_version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="mec-version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__info_name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="info-name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )
        self.__virtual_compute = YANGDynClass(
            base=yc_virtual_compute_mec_app_descriptor__mec_appd_virtual_compute,
            is_container="container",
            yang_name="virtual-compute",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__sw_image = YANGDynClass(
            base=yc_sw_image_mec_app_descriptor__mec_appd_sw_image,
            is_container="container",
            yang_name="sw-image",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__virtual_storage = YANGDynClass(
            base=YANGListType(
                "id",
                yc_virtual_storage_mec_app_descriptor__mec_appd_virtual_storage,
                yang_name="virtual-storage",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="virtual-storage",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__ext_cpd = YANGDynClass(
            base=YANGListType(
                "id",
                yc_ext_cpd_mec_app_descriptor__mec_appd_ext_cpd,
                yang_name="ext-cpd",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="ext-cpd",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__service_required = YANGDynClass(
            base=YANGListType(
                "name",
                yc_service_required_mec_app_descriptor__mec_appd_service_required,
                yang_name="service-required",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="name",
                extensions=None,
            ),
            is_container="list",
            yang_name="service-required",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__service_optional = YANGDynClass(
            base=YANGListType(
                "name",
                yc_service_optional_mec_app_descriptor__mec_appd_service_optional,
                yang_name="service-optional",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="name",
                extensions=None,
            ),
            is_container="list",
            yang_name="service-optional",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__service_produced = YANGDynClass(
            base=YANGListType(
                "name",
                yc_service_produced_mec_app_descriptor__mec_appd_service_produced,
                yang_name="service-produced",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="name",
                extensions=None,
            ),
            is_container="list",
            yang_name="service-produced",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__feature_required = YANGDynClass(
            base=yc_feature_required_mec_app_descriptor__mec_appd_feature_required,
            is_container="container",
            yang_name="feature-required",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__feature_optional = YANGDynClass(
            base=yc_feature_optional_mec_app_descriptor__mec_appd_feature_optional,
            is_container="container",
            yang_name="feature-optional",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__transport_dependencies = YANGDynClass(
            base=YANGListType(
                "id",
                yc_transport_dependencies_mec_app_descriptor__mec_appd_transport_dependencies,
                yang_name="transport-dependencies",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="transport-dependencies",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__traffic_rule = YANGDynClass(
            base=YANGListType(
                "id",
                yc_traffic_rule_mec_app_descriptor__mec_appd_traffic_rule,
                yang_name="traffic-rule",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="traffic-rule",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__dns_rule = YANGDynClass(
            base=YANGListType(
                "id",
                yc_dns_rule_mec_app_descriptor__mec_appd_dns_rule,
                yang_name="dns-rule",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="dns-rule",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )
        self.__latency = YANGDynClass(
            base=yc_latency_mec_app_descriptor__mec_appd_latency,
            is_container="container",
            yang_name="latency",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__terminate_app_instance_op_config = YANGDynClass(
            base=yc_terminate_app_instance_op_config_mec_app_descriptor__mec_appd_terminate_app_instance_op_config,
            is_container="container",
            yang_name="terminate-app-instance-op-config",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__change_app_instance_state_op_config = YANGDynClass(
            base=yc_change_app_instance_state_op_config_mec_app_descriptor__mec_appd_change_app_instance_state_op_config,
            is_container="container",
            yang_name="change-app-instance-state-op-config",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__user_context_transfer_capability = YANGDynClass(
            base=yc_user_context_transfer_capability_mec_app_descriptor__mec_appd_user_context_transfer_capability,
            is_container="container",
            yang_name="user-context-transfer-capability",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__network_policy = YANGDynClass(
            base=yc_network_policy_mec_app_descriptor__mec_appd_network_policy,
            is_container="container",
            yang_name="network-policy",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )
        self.__artifacts = YANGDynClass(
            base=YANGListType(
                "name",
                yc_artifacts_mec_app_descriptor__mec_appd_artifacts,
                yang_name="artifacts",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="name",
                extensions=None,
            ),
            is_container="list",
            yang_name="artifacts",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ["mec-appd"]

    def _get_id(self):
        """
        Getter method for id, mapped from YANG variable /mec_appd/id (string)

        YANG Description: Identifier of this MEC application descriptor. This attribute shall be globally unique.
        """
        return self.__id

    def _set_id(self, v, load=False):
        """
        Setter method for id, mapped from YANG variable /mec_appd/id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_id() directly.

        YANG Description: Identifier of this MEC application descriptor. This attribute shall be globally unique.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="id",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """id must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__id = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="id",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_name(self):
        """
        Getter method for name, mapped from YANG variable /mec_appd/name (string)

        YANG Description: Name to identify the MEC application.
        """
        return self.__name

    def _set_name(self, v, load=False):
        """
        Setter method for name, mapped from YANG variable /mec_appd/name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_name() directly.

        YANG Description: Name to identify the MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_provider(self):
        """
        Getter method for provider, mapped from YANG variable /mec_appd/provider (string)

        YANG Description: Provider of the application and of the AppD.
        """
        return self.__provider

    def _set_provider(self, v, load=False):
        """
        Setter method for provider, mapped from YANG variable /mec_appd/provider (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_provider is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_provider() directly.

        YANG Description: Provider of the application and of the AppD.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="provider",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """provider must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__provider = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_provider(self):
        self.__provider = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="provider",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_soft_version(self):
        """
        Getter method for soft_version, mapped from YANG variable /mec_appd/soft_version (string)

        YANG Description: Identifies the version of software of the MEC application.
        """
        return self.__soft_version

    def _set_soft_version(self, v, load=False):
        """
        Setter method for soft_version, mapped from YANG variable /mec_appd/soft_version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_soft_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_soft_version() directly.

        YANG Description: Identifies the version of software of the MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="soft-version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """soft_version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="soft-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__soft_version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_soft_version(self):
        self.__soft_version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="soft-version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_version(self):
        """
        Getter method for version, mapped from YANG variable /mec_appd/version (string)

        YANG Description: Identifies the version of the application descriptor.
        """
        return self.__version

    def _set_version(self, v, load=False):
        """
        Setter method for version, mapped from YANG variable /mec_appd/version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_version() directly.

        YANG Description: Identifies the version of the application descriptor.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_mec_version(self):
        """
        Getter method for mec_version, mapped from YANG variable /mec_appd/mec_version (string)

        YANG Description: Identifies version(s) of MEC system compatible with the MEC application described in this version of the AppD. The value shall be formatted as comma-separated list of strings.
        """
        return self.__mec_version

    def _set_mec_version(self, v, load=False):
        """
        Setter method for mec_version, mapped from YANG variable /mec_appd/mec_version (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_mec_version is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_mec_version() directly.

        YANG Description: Identifies version(s) of MEC system compatible with the MEC application described in this version of the AppD. The value shall be formatted as comma-separated list of strings.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="mec-version",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """mec_version must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mec-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__mec_version = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_mec_version(self):
        self.__mec_version = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="mec-version",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_info_name(self):
        """
        Getter method for info_name, mapped from YANG variable /mec_appd/info_name (string)

        YANG Description: Human readable name for the MEC application.
        """
        return self.__info_name

    def _set_info_name(self, v, load=False):
        """
        Setter method for info_name, mapped from YANG variable /mec_appd/info_name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_info_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_info_name() directly.

        YANG Description: Human readable name for the MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="info-name",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """info_name must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__info_name = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_info_name(self):
        self.__info_name = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="info-name",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_description(self):
        """
        Getter method for description, mapped from YANG variable /mec_appd/description (string)

        YANG Description: Human readable description of the MEC application.
        """
        return self.__description

    def _set_description(self, v, load=False):
        """
        Setter method for description, mapped from YANG variable /mec_appd/description (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_description is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_description() directly.

        YANG Description: Human readable description of the MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=six.text_type,
                is_leaf=True,
                yang_name="description",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="string",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """description must be of a type compatible with string""",
                    "defined-type": "string",
                    "generated-type": """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
                }
            )

        self.__description = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(
            base=six.text_type,
            is_leaf=True,
            yang_name="description",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="string",
            is_config=True,
        )

    def _get_virtual_compute(self):
        """
        Getter method for virtual_compute, mapped from YANG variable /mec_appd/virtual_compute (container)

        YANG Description: Describes CPU and memory requirements, as well as optional additional requirements, such as disk and acceleration related capabilities, of the virtualisation container used to realize this MEC application.
        """
        return self.__virtual_compute

    def _set_virtual_compute(self, v, load=False):
        """
        Setter method for virtual_compute, mapped from YANG variable /mec_appd/virtual_compute (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_virtual_compute is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_virtual_compute() directly.

        YANG Description: Describes CPU and memory requirements, as well as optional additional requirements, such as disk and acceleration related capabilities, of the virtualisation container used to realize this MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_virtual_compute_mec_app_descriptor__mec_appd_virtual_compute,
                is_container="container",
                yang_name="virtual-compute",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """virtual_compute must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_virtual_compute_mec_app_descriptor__mec_appd_virtual_compute, is_container='container', yang_name="virtual-compute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__virtual_compute = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_virtual_compute(self):
        self.__virtual_compute = YANGDynClass(
            base=yc_virtual_compute_mec_app_descriptor__mec_appd_virtual_compute,
            is_container="container",
            yang_name="virtual-compute",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_sw_image(self):
        """
        Getter method for sw_image, mapped from YANG variable /mec_appd/sw_image (container)

        YANG Description: Describes the descriptors of the software image to be used by the virtualisation container used to realize this MEC application.
        """
        return self.__sw_image

    def _set_sw_image(self, v, load=False):
        """
        Setter method for sw_image, mapped from YANG variable /mec_appd/sw_image (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_sw_image is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_sw_image() directly.

        YANG Description: Describes the descriptors of the software image to be used by the virtualisation container used to realize this MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_sw_image_mec_app_descriptor__mec_appd_sw_image,
                is_container="container",
                yang_name="sw-image",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """sw_image must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_sw_image_mec_app_descriptor__mec_appd_sw_image, is_container='container', yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__sw_image = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_sw_image(self):
        self.__sw_image = YANGDynClass(
            base=yc_sw_image_mec_app_descriptor__mec_appd_sw_image,
            is_container="container",
            yang_name="sw-image",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_virtual_storage(self):
        """
        Getter method for virtual_storage, mapped from YANG variable /mec_appd/virtual_storage (list)

        YANG Description: Defines descriptors of virtual storage resources to be used by the MEC application.
        """
        return self.__virtual_storage

    def _set_virtual_storage(self, v, load=False):
        """
        Setter method for virtual_storage, mapped from YANG variable /mec_appd/virtual_storage (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_virtual_storage is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_virtual_storage() directly.

        YANG Description: Defines descriptors of virtual storage resources to be used by the MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_virtual_storage_mec_app_descriptor__mec_appd_virtual_storage,
                    yang_name="virtual-storage",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="virtual-storage",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """virtual_storage must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_virtual_storage_mec_app_descriptor__mec_appd_virtual_storage, yang_name="virtual-storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__virtual_storage = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_virtual_storage(self):
        self.__virtual_storage = YANGDynClass(
            base=YANGListType(
                "id",
                yc_virtual_storage_mec_app_descriptor__mec_appd_virtual_storage,
                yang_name="virtual-storage",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="virtual-storage",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_ext_cpd(self):
        """
        Getter method for ext_cpd, mapped from YANG variable /mec_appd/ext_cpd (list)

        YANG Description: Describes external interface(s) exposed by this MEC application.
        """
        return self.__ext_cpd

    def _set_ext_cpd(self, v, load=False):
        """
        Setter method for ext_cpd, mapped from YANG variable /mec_appd/ext_cpd (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_ext_cpd is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_ext_cpd() directly.

        YANG Description: Describes external interface(s) exposed by this MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_ext_cpd_mec_app_descriptor__mec_appd_ext_cpd,
                    yang_name="ext-cpd",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="ext-cpd",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """ext_cpd must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_ext_cpd_mec_app_descriptor__mec_appd_ext_cpd, yang_name="ext-cpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__ext_cpd = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_ext_cpd(self):
        self.__ext_cpd = YANGDynClass(
            base=YANGListType(
                "id",
                yc_ext_cpd_mec_app_descriptor__mec_appd_ext_cpd,
                yang_name="ext-cpd",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="ext-cpd",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_service_required(self):
        """
        Getter method for service_required, mapped from YANG variable /mec_appd/service_required (list)

        YANG Description: Describes services a MEC application requires to run
        """
        return self.__service_required

    def _set_service_required(self, v, load=False):
        """
        Setter method for service_required, mapped from YANG variable /mec_appd/service_required (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_service_required is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_service_required() directly.

        YANG Description: Describes services a MEC application requires to run
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "name",
                    yc_service_required_mec_app_descriptor__mec_appd_service_required,
                    yang_name="service-required",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="name",
                    extensions=None,
                ),
                is_container="list",
                yang_name="service-required",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """service_required must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("name",yc_service_required_mec_app_descriptor__mec_appd_service_required, yang_name="service-required", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__service_required = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_service_required(self):
        self.__service_required = YANGDynClass(
            base=YANGListType(
                "name",
                yc_service_required_mec_app_descriptor__mec_appd_service_required,
                yang_name="service-required",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="name",
                extensions=None,
            ),
            is_container="list",
            yang_name="service-required",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_service_optional(self):
        """
        Getter method for service_optional, mapped from YANG variable /mec_appd/service_optional (list)

        YANG Description: Describes services a MEC application may use if available.
        """
        return self.__service_optional

    def _set_service_optional(self, v, load=False):
        """
        Setter method for service_optional, mapped from YANG variable /mec_appd/service_optional (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_service_optional is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_service_optional() directly.

        YANG Description: Describes services a MEC application may use if available.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "name",
                    yc_service_optional_mec_app_descriptor__mec_appd_service_optional,
                    yang_name="service-optional",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="name",
                    extensions=None,
                ),
                is_container="list",
                yang_name="service-optional",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """service_optional must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("name",yc_service_optional_mec_app_descriptor__mec_appd_service_optional, yang_name="service-optional", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__service_optional = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_service_optional(self):
        self.__service_optional = YANGDynClass(
            base=YANGListType(
                "name",
                yc_service_optional_mec_app_descriptor__mec_appd_service_optional,
                yang_name="service-optional",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="name",
                extensions=None,
            ),
            is_container="list",
            yang_name="service-optional",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_service_produced(self):
        """
        Getter method for service_produced, mapped from YANG variable /mec_appd/service_produced (list)

        YANG Description: Describes services a MEC application is able to produce to the platform or other MEC applications. Only relevant for serviceproducing apps.
        """
        return self.__service_produced

    def _set_service_produced(self, v, load=False):
        """
        Setter method for service_produced, mapped from YANG variable /mec_appd/service_produced (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_service_produced is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_service_produced() directly.

        YANG Description: Describes services a MEC application is able to produce to the platform or other MEC applications. Only relevant for serviceproducing apps.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "name",
                    yc_service_produced_mec_app_descriptor__mec_appd_service_produced,
                    yang_name="service-produced",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="name",
                    extensions=None,
                ),
                is_container="list",
                yang_name="service-produced",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """service_produced must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("name",yc_service_produced_mec_app_descriptor__mec_appd_service_produced, yang_name="service-produced", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-produced", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__service_produced = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_service_produced(self):
        self.__service_produced = YANGDynClass(
            base=YANGListType(
                "name",
                yc_service_produced_mec_app_descriptor__mec_appd_service_produced,
                yang_name="service-produced",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="name",
                extensions=None,
            ),
            is_container="list",
            yang_name="service-produced",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_feature_required(self):
        """
        Getter method for feature_required, mapped from YANG variable /mec_appd/feature_required (container)

        YANG Description: Describes features a MEC application requires to run
        """
        return self.__feature_required

    def _set_feature_required(self, v, load=False):
        """
        Setter method for feature_required, mapped from YANG variable /mec_appd/feature_required (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_feature_required is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_feature_required() directly.

        YANG Description: Describes features a MEC application requires to run
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_feature_required_mec_app_descriptor__mec_appd_feature_required,
                is_container="container",
                yang_name="feature-required",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """feature_required must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_feature_required_mec_app_descriptor__mec_appd_feature_required, is_container='container', yang_name="feature-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__feature_required = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_feature_required(self):
        self.__feature_required = YANGDynClass(
            base=yc_feature_required_mec_app_descriptor__mec_appd_feature_required,
            is_container="container",
            yang_name="feature-required",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_feature_optional(self):
        """
        Getter method for feature_optional, mapped from YANG variable /mec_appd/feature_optional (container)

        YANG Description: Describes features a MEC application may use if available.
        """
        return self.__feature_optional

    def _set_feature_optional(self, v, load=False):
        """
        Setter method for feature_optional, mapped from YANG variable /mec_appd/feature_optional (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_feature_optional is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_feature_optional() directly.

        YANG Description: Describes features a MEC application may use if available.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_feature_optional_mec_app_descriptor__mec_appd_feature_optional,
                is_container="container",
                yang_name="feature-optional",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """feature_optional must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_feature_optional_mec_app_descriptor__mec_appd_feature_optional, is_container='container', yang_name="feature-optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__feature_optional = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_feature_optional(self):
        self.__feature_optional = YANGDynClass(
            base=yc_feature_optional_mec_app_descriptor__mec_appd_feature_optional,
            is_container="container",
            yang_name="feature-optional",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_transport_dependencies(self):
        """
        Getter method for transport_dependencies, mapped from YANG variable /mec_appd/transport_dependencies (list)

        YANG Description: Transports, if any, that this application requires to be provided by the platform. These transports will be used by the application to deliver services provided by this application. Only relevant for service-producing apps. See note 2.
        """
        return self.__transport_dependencies

    def _set_transport_dependencies(self, v, load=False):
        """
        Setter method for transport_dependencies, mapped from YANG variable /mec_appd/transport_dependencies (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transport_dependencies is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transport_dependencies() directly.

        YANG Description: Transports, if any, that this application requires to be provided by the platform. These transports will be used by the application to deliver services provided by this application. Only relevant for service-producing apps. See note 2.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_transport_dependencies_mec_app_descriptor__mec_appd_transport_dependencies,
                    yang_name="transport-dependencies",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="transport-dependencies",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """transport_dependencies must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__mec_appd_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__transport_dependencies = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_transport_dependencies(self):
        self.__transport_dependencies = YANGDynClass(
            base=YANGListType(
                "id",
                yc_transport_dependencies_mec_app_descriptor__mec_appd_transport_dependencies,
                yang_name="transport-dependencies",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="transport-dependencies",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_traffic_rule(self):
        """
        Getter method for traffic_rule, mapped from YANG variable /mec_appd/traffic_rule (list)

        YANG Description: Describes traffic rules the MEC application requires.
        """
        return self.__traffic_rule

    def _set_traffic_rule(self, v, load=False):
        """
        Setter method for traffic_rule, mapped from YANG variable /mec_appd/traffic_rule (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_traffic_rule is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_traffic_rule() directly.

        YANG Description: Describes traffic rules the MEC application requires.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_traffic_rule_mec_app_descriptor__mec_appd_traffic_rule,
                    yang_name="traffic-rule",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="traffic-rule",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """traffic_rule must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_traffic_rule_mec_app_descriptor__mec_appd_traffic_rule, yang_name="traffic-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="traffic-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__traffic_rule = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_traffic_rule(self):
        self.__traffic_rule = YANGDynClass(
            base=YANGListType(
                "id",
                yc_traffic_rule_mec_app_descriptor__mec_appd_traffic_rule,
                yang_name="traffic-rule",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="traffic-rule",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_dns_rule(self):
        """
        Getter method for dns_rule, mapped from YANG variable /mec_appd/dns_rule (list)

        YANG Description: Describes DNS rules the MEC application requires.
        """
        return self.__dns_rule

    def _set_dns_rule(self, v, load=False):
        """
        Setter method for dns_rule, mapped from YANG variable /mec_appd/dns_rule (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_dns_rule is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_dns_rule() directly.

        YANG Description: Describes DNS rules the MEC application requires.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "id",
                    yc_dns_rule_mec_app_descriptor__mec_appd_dns_rule,
                    yang_name="dns-rule",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="id",
                    extensions=None,
                ),
                is_container="list",
                yang_name="dns-rule",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """dns_rule must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("id",yc_dns_rule_mec_app_descriptor__mec_appd_dns_rule, yang_name="dns-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dns-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__dns_rule = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_dns_rule(self):
        self.__dns_rule = YANGDynClass(
            base=YANGListType(
                "id",
                yc_dns_rule_mec_app_descriptor__mec_appd_dns_rule,
                yang_name="dns-rule",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="id",
                extensions=None,
            ),
            is_container="list",
            yang_name="dns-rule",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    def _get_latency(self):
        """
        Getter method for latency, mapped from YANG variable /mec_appd/latency (container)

        YANG Description: Describes the maximum latency tolerated by the MEC application.
        """
        return self.__latency

    def _set_latency(self, v, load=False):
        """
        Setter method for latency, mapped from YANG variable /mec_appd/latency (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_latency is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_latency() directly.

        YANG Description: Describes the maximum latency tolerated by the MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_latency_mec_app_descriptor__mec_appd_latency,
                is_container="container",
                yang_name="latency",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """latency must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_latency_mec_app_descriptor__mec_appd_latency, is_container='container', yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__latency = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_latency(self):
        self.__latency = YANGDynClass(
            base=yc_latency_mec_app_descriptor__mec_appd_latency,
            is_container="container",
            yang_name="latency",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_terminate_app_instance_op_config(self):
        """
        Getter method for terminate_app_instance_op_config, mapped from YANG variable /mec_appd/terminate_app_instance_op_config (container)

        YANG Description: Configuration parameters for the Terminate application instance operation.
        """
        return self.__terminate_app_instance_op_config

    def _set_terminate_app_instance_op_config(self, v, load=False):
        """
        Setter method for terminate_app_instance_op_config, mapped from YANG variable /mec_appd/terminate_app_instance_op_config (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_terminate_app_instance_op_config is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_terminate_app_instance_op_config() directly.

        YANG Description: Configuration parameters for the Terminate application instance operation.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_terminate_app_instance_op_config_mec_app_descriptor__mec_appd_terminate_app_instance_op_config,
                is_container="container",
                yang_name="terminate-app-instance-op-config",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """terminate_app_instance_op_config must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_terminate_app_instance_op_config_mec_app_descriptor__mec_appd_terminate_app_instance_op_config, is_container='container', yang_name="terminate-app-instance-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__terminate_app_instance_op_config = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_terminate_app_instance_op_config(self):
        self.__terminate_app_instance_op_config = YANGDynClass(
            base=yc_terminate_app_instance_op_config_mec_app_descriptor__mec_appd_terminate_app_instance_op_config,
            is_container="container",
            yang_name="terminate-app-instance-op-config",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_change_app_instance_state_op_config(self):
        """
        Getter method for change_app_instance_state_op_config, mapped from YANG variable /mec_appd/change_app_instance_state_op_config (container)

        YANG Description: Configuration parameters for the change application instance state operation.
        """
        return self.__change_app_instance_state_op_config

    def _set_change_app_instance_state_op_config(self, v, load=False):
        """
        Setter method for change_app_instance_state_op_config, mapped from YANG variable /mec_appd/change_app_instance_state_op_config (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_change_app_instance_state_op_config is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_change_app_instance_state_op_config() directly.

        YANG Description: Configuration parameters for the change application instance state operation.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_change_app_instance_state_op_config_mec_app_descriptor__mec_appd_change_app_instance_state_op_config,
                is_container="container",
                yang_name="change-app-instance-state-op-config",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """change_app_instance_state_op_config must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_change_app_instance_state_op_config_mec_app_descriptor__mec_appd_change_app_instance_state_op_config, is_container='container', yang_name="change-app-instance-state-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__change_app_instance_state_op_config = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_change_app_instance_state_op_config(self):
        self.__change_app_instance_state_op_config = YANGDynClass(
            base=yc_change_app_instance_state_op_config_mec_app_descriptor__mec_appd_change_app_instance_state_op_config,
            is_container="container",
            yang_name="change-app-instance-state-op-config",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_user_context_transfer_capability(self):
        """
        Getter method for user_context_transfer_capability, mapped from YANG variable /mec_appd/user_context_transfer_capability (container)

        YANG Description: If the application supports the user context transfer capability, this attribute shall be included.
        """
        return self.__user_context_transfer_capability

    def _set_user_context_transfer_capability(self, v, load=False):
        """
        Setter method for user_context_transfer_capability, mapped from YANG variable /mec_appd/user_context_transfer_capability (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_user_context_transfer_capability is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_user_context_transfer_capability() directly.

        YANG Description: If the application supports the user context transfer capability, this attribute shall be included.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_user_context_transfer_capability_mec_app_descriptor__mec_appd_user_context_transfer_capability,
                is_container="container",
                yang_name="user-context-transfer-capability",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """user_context_transfer_capability must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_user_context_transfer_capability_mec_app_descriptor__mec_appd_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__user_context_transfer_capability = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_user_context_transfer_capability(self):
        self.__user_context_transfer_capability = YANGDynClass(
            base=yc_user_context_transfer_capability_mec_app_descriptor__mec_appd_user_context_transfer_capability,
            is_container="container",
            yang_name="user-context-transfer-capability",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_network_policy(self):
        """
        Getter method for network_policy, mapped from YANG variable /mec_appd/network_policy (container)

        YANG Description: If present, it represents the application network policy of carrying the application traffic.
        """
        return self.__network_policy

    def _set_network_policy(self, v, load=False):
        """
        Setter method for network_policy, mapped from YANG variable /mec_appd/network_policy (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_network_policy is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_network_policy() directly.

        YANG Description: If present, it represents the application network policy of carrying the application traffic.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_network_policy_mec_app_descriptor__mec_appd_network_policy,
                is_container="container",
                yang_name="network-policy",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """network_policy must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_network_policy_mec_app_descriptor__mec_appd_network_policy, is_container='container', yang_name="network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__network_policy = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_network_policy(self):
        self.__network_policy = YANGDynClass(
            base=yc_network_policy_mec_app_descriptor__mec_appd_network_policy,
            is_container="container",
            yang_name="network-policy",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    def _get_artifacts(self):
        """
        Getter method for artifacts, mapped from YANG variable /mec_appd/artifacts (list)

        YANG Description: List of artifacts required by the MEC application.
        """
        return self.__artifacts

    def _set_artifacts(self, v, load=False):
        """
        Setter method for artifacts, mapped from YANG variable /mec_appd/artifacts (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_artifacts is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_artifacts() directly.

        YANG Description: List of artifacts required by the MEC application.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=YANGListType(
                    "name",
                    yc_artifacts_mec_app_descriptor__mec_appd_artifacts,
                    yang_name="artifacts",
                    parent=self,
                    is_container="list",
                    user_ordered=False,
                    path_helper=self._path_helper,
                    yang_keys="name",
                    extensions=None,
                ),
                is_container="list",
                yang_name="artifacts",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="list",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """artifacts must be of a type compatible with list""",
                    "defined-type": "list",
                    "generated-type": """YANGDynClass(base=YANGListType("name",yc_artifacts_mec_app_descriptor__mec_appd_artifacts, yang_name="artifacts", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="artifacts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
                }
            )

        self.__artifacts = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_artifacts(self):
        self.__artifacts = YANGDynClass(
            base=YANGListType(
                "name",
                yc_artifacts_mec_app_descriptor__mec_appd_artifacts,
                yang_name="artifacts",
                parent=self,
                is_container="list",
                user_ordered=False,
                path_helper=self._path_helper,
                yang_keys="name",
                extensions=None,
            ),
            is_container="list",
            yang_name="artifacts",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="list",
            is_config=True,
        )

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    provider = __builtin__.property(_get_provider, _set_provider)
    soft_version = __builtin__.property(_get_soft_version, _set_soft_version)
    version = __builtin__.property(_get_version, _set_version)
    mec_version = __builtin__.property(_get_mec_version, _set_mec_version)
    info_name = __builtin__.property(_get_info_name, _set_info_name)
    description = __builtin__.property(_get_description, _set_description)
    virtual_compute = __builtin__.property(_get_virtual_compute, _set_virtual_compute)
    sw_image = __builtin__.property(_get_sw_image, _set_sw_image)
    virtual_storage = __builtin__.property(_get_virtual_storage, _set_virtual_storage)
    ext_cpd = __builtin__.property(_get_ext_cpd, _set_ext_cpd)
    service_required = __builtin__.property(
        _get_service_required, _set_service_required
    )
    service_optional = __builtin__.property(
        _get_service_optional, _set_service_optional
    )
    service_produced = __builtin__.property(
        _get_service_produced, _set_service_produced
    )
    feature_required = __builtin__.property(
        _get_feature_required, _set_feature_required
    )
    feature_optional = __builtin__.property(
        _get_feature_optional, _set_feature_optional
    )
    transport_dependencies = __builtin__.property(
        _get_transport_dependencies, _set_transport_dependencies
    )
    traffic_rule = __builtin__.property(_get_traffic_rule, _set_traffic_rule)
    dns_rule = __builtin__.property(_get_dns_rule, _set_dns_rule)
    latency = __builtin__.property(_get_latency, _set_latency)
    terminate_app_instance_op_config = __builtin__.property(
        _get_terminate_app_instance_op_config, _set_terminate_app_instance_op_config
    )
    change_app_instance_state_op_config = __builtin__.property(
        _get_change_app_instance_state_op_config,
        _set_change_app_instance_state_op_config,
    )
    user_context_transfer_capability = __builtin__.property(
        _get_user_context_transfer_capability, _set_user_context_transfer_capability
    )
    network_policy = __builtin__.property(_get_network_policy, _set_network_policy)
    artifacts = __builtin__.property(_get_artifacts, _set_artifacts)

    _pyangbind_elements = OrderedDict(
        [
            ("id", id),
            ("name", name),
            ("provider", provider),
            ("soft_version", soft_version),
            ("version", version),
            ("mec_version", mec_version),
            ("info_name", info_name),
            ("description", description),
            ("virtual_compute", virtual_compute),
            ("sw_image", sw_image),
            ("virtual_storage", virtual_storage),
            ("ext_cpd", ext_cpd),
            ("service_required", service_required),
            ("service_optional", service_optional),
            ("service_produced", service_produced),
            ("feature_required", feature_required),
            ("feature_optional", feature_optional),
            ("transport_dependencies", transport_dependencies),
            ("traffic_rule", traffic_rule),
            ("dns_rule", dns_rule),
            ("latency", latency),
            ("terminate_app_instance_op_config", terminate_app_instance_op_config),
            (
                "change_app_instance_state_op_config",
                change_app_instance_state_op_config,
            ),
            ("user_context_transfer_capability", user_context_transfer_capability),
            ("network_policy", network_policy),
            ("artifacts", artifacts),
        ]
    )


class mec_app_descriptor(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module mec-app-descriptor - based on the path /mec-app-descriptor. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: YANG module for MEC Application Descriptors based on ETSI GS MEC 010-2 V2.2.1.
    """

    __slots__ = (
        "_path_helper",
        "_extmethods",
        "__mec_appd",
    )

    _yang_name = "mec-app-descriptor"
    _yang_namespace = "http://example.com/ns/mec-app-descriptor"

    _pybind_generated_by = "container"

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__mec_appd = YANGDynClass(
            base=yc_mec_appd_mec_app_descriptor__mec_appd,
            is_container="container",
            yang_name="mec-appd",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return []

    def _get_mec_appd(self):
        """
        Getter method for mec_appd, mapped from YANG variable /mec_appd (container)
        """
        return self.__mec_appd

    def _set_mec_appd(self, v, load=False):
        """
        Setter method for mec_appd, mapped from YANG variable /mec_appd (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_mec_appd is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_mec_appd() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(
                v,
                base=yc_mec_appd_mec_app_descriptor__mec_appd,
                is_container="container",
                yang_name="mec-appd",
                parent=self,
                path_helper=self._path_helper,
                extmethods=self._extmethods,
                register_paths=True,
                extensions=None,
                namespace="http://example.com/ns/mec-app-descriptor",
                defining_module="mec-app-descriptor",
                yang_type="container",
                is_config=True,
            )
        except (TypeError, ValueError):
            raise ValueError(
                {
                    "error-string": """mec_appd must be of a type compatible with container""",
                    "defined-type": "container",
                    "generated-type": """YANGDynClass(base=yc_mec_appd_mec_app_descriptor__mec_appd, is_container='container', yang_name="mec-appd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
                }
            )

        self.__mec_appd = t
        if hasattr(self, "_set"):
            self._set()

    def _unset_mec_appd(self):
        self.__mec_appd = YANGDynClass(
            base=yc_mec_appd_mec_app_descriptor__mec_appd,
            is_container="container",
            yang_name="mec-appd",
            parent=self,
            path_helper=self._path_helper,
            extmethods=self._extmethods,
            register_paths=True,
            extensions=None,
            namespace="http://example.com/ns/mec-app-descriptor",
            defining_module="mec-app-descriptor",
            yang_type="container",
            is_config=True,
        )

    mec_appd = __builtin__.property(_get_mec_appd, _set_mec_appd)

    _pyangbind_elements = OrderedDict(
        [
            ("mec_appd", mec_appd),
        ]
    )
