# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_logical_node_reqs_mec_app_descriptor__app_descriptor_virtual_compute_logical_node_reqs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/logical-node-reqs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The logical node requirements
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__logical_node_requirement_detail',)

  _yang_name = 'logical-node-reqs'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__logical_node_requirement_detail = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="logical-node-requirement-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'logical-node-reqs']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/virtual_compute/logical_node_reqs/id (string)

    YANG Description: Identifier of the logical node requirement
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/virtual_compute/logical_node_reqs/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of the logical node requirement
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_logical_node_requirement_detail(self):
    """
    Getter method for logical_node_requirement_detail, mapped from YANG variable /app_descriptor/virtual_compute/logical_node_reqs/logical_node_requirement_detail (string)

    YANG Description: The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements. This could include the number of CPU cores on this logical node, a memory configuration specific to a logical node (e.g. such as available in the Linux kernel via the libnuma library) or a requirement related to the association of an I/O device with the logical node.
    """
    return self.__logical_node_requirement_detail
      
  def _set_logical_node_requirement_detail(self, v, load=False):
    """
    Setter method for logical_node_requirement_detail, mapped from YANG variable /app_descriptor/virtual_compute/logical_node_reqs/logical_node_requirement_detail (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_node_requirement_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_node_requirement_detail() directly.

    YANG Description: The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements. This could include the number of CPU cores on this logical node, a memory configuration specific to a logical node (e.g. such as available in the Linux kernel via the libnuma library) or a requirement related to the association of an I/O device with the logical node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="logical-node-requirement-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_node_requirement_detail must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="logical-node-requirement-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__logical_node_requirement_detail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_node_requirement_detail(self):
    self.__logical_node_requirement_detail = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="logical-node-requirement-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  logical_node_requirement_detail = __builtin__.property(_get_logical_node_requirement_detail, _set_logical_node_requirement_detail)


  _pyangbind_elements = OrderedDict([('id', id), ('logical_node_requirement_detail', logical_node_requirement_detail), ])


class yc_target_performance_parameters_mec_app_descriptor__app_descriptor_virtual_compute_request_additional_capabilities_target_performance_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/request-additional-capabilities/target-performance-parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies especific attributes, dependent on the requested additional capability type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'target-performance-parameters'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'request-additional-capabilities', 'target-performance-parameters']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/target_performance_parameters/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/target_performance_parameters/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/target_performance_parameters/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/target_performance_parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_request_additional_capabilities_mec_app_descriptor__app_descriptor_virtual_compute_request_additional_capabilities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/request-additional-capabilities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies requirements for additional capabilities
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__support_mandatory','__min_requested_additional_capability_version','__preferred_requested_additional_capability_version','__target_performance_parameters',)

  _yang_name = 'request-additional-capabilities'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__support_mandatory = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__min_requested_additional_capability_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-requested-additional-capability-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__preferred_requested_additional_capability_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferred-requested-additional-capability-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__target_performance_parameters = YANGDynClass(base=YANGListType("key",yc_target_performance_parameters_mec_app_descriptor__app_descriptor_virtual_compute_request_additional_capabilities_target_performance_parameters, yang_name="target-performance-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="target-performance-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'request-additional-capabilities']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/name (string)

    YANG Description: Specifies a requested additional capability for the VDU
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Specifies a requested additional capability for the VDU
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_support_mandatory(self):
    """
    Getter method for support_mandatory, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/support_mandatory (boolean)

    YANG Description: Indicates whether the requested additional capability is mandatory for successful operation
    """
    return self.__support_mandatory
      
  def _set_support_mandatory(self, v, load=False):
    """
    Setter method for support_mandatory, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/support_mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_support_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_support_mandatory() directly.

    YANG Description: Indicates whether the requested additional capability is mandatory for successful operation
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """support_mandatory must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__support_mandatory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_support_mandatory(self):
    self.__support_mandatory = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_min_requested_additional_capability_version(self):
    """
    Getter method for min_requested_additional_capability_version, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/min_requested_additional_capability_version (string)

    YANG Description: Specifies the minimum version of the requested additional capability
    """
    return self.__min_requested_additional_capability_version
      
  def _set_min_requested_additional_capability_version(self, v, load=False):
    """
    Setter method for min_requested_additional_capability_version, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/min_requested_additional_capability_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_requested_additional_capability_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_requested_additional_capability_version() directly.

    YANG Description: Specifies the minimum version of the requested additional capability
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="min-requested-additional-capability-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_requested_additional_capability_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-requested-additional-capability-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__min_requested_additional_capability_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_requested_additional_capability_version(self):
    self.__min_requested_additional_capability_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-requested-additional-capability-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_preferred_requested_additional_capability_version(self):
    """
    Getter method for preferred_requested_additional_capability_version, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/preferred_requested_additional_capability_version (string)

    YANG Description: Specifies the preferred version of the requested additional capability
    """
    return self.__preferred_requested_additional_capability_version
      
  def _set_preferred_requested_additional_capability_version(self, v, load=False):
    """
    Setter method for preferred_requested_additional_capability_version, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/preferred_requested_additional_capability_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_requested_additional_capability_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_requested_additional_capability_version() directly.

    YANG Description: Specifies the preferred version of the requested additional capability
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="preferred-requested-additional-capability-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferred_requested_additional_capability_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferred-requested-additional-capability-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__preferred_requested_additional_capability_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferred_requested_additional_capability_version(self):
    self.__preferred_requested_additional_capability_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferred-requested-additional-capability-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_target_performance_parameters(self):
    """
    Getter method for target_performance_parameters, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/target_performance_parameters (list)

    YANG Description: Specifies especific attributes, dependent on the requested additional capability type.
    """
    return self.__target_performance_parameters
      
  def _set_target_performance_parameters(self, v, load=False):
    """
    Setter method for target_performance_parameters, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities/target_performance_parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_performance_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_performance_parameters() directly.

    YANG Description: Specifies especific attributes, dependent on the requested additional capability type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_target_performance_parameters_mec_app_descriptor__app_descriptor_virtual_compute_request_additional_capabilities_target_performance_parameters, yang_name="target-performance-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="target-performance-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_performance_parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_target_performance_parameters_mec_app_descriptor__app_descriptor_virtual_compute_request_additional_capabilities_target_performance_parameters, yang_name="target-performance-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="target-performance-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__target_performance_parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_performance_parameters(self):
    self.__target_performance_parameters = YANGDynClass(base=YANGListType("key",yc_target_performance_parameters_mec_app_descriptor__app_descriptor_virtual_compute_request_additional_capabilities_target_performance_parameters, yang_name="target-performance-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="target-performance-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  support_mandatory = __builtin__.property(_get_support_mandatory, _set_support_mandatory)
  min_requested_additional_capability_version = __builtin__.property(_get_min_requested_additional_capability_version, _set_min_requested_additional_capability_version)
  preferred_requested_additional_capability_version = __builtin__.property(_get_preferred_requested_additional_capability_version, _set_preferred_requested_additional_capability_version)
  target_performance_parameters = __builtin__.property(_get_target_performance_parameters, _set_target_performance_parameters)


  _pyangbind_elements = OrderedDict([('name', name), ('support_mandatory', support_mandatory), ('min_requested_additional_capability_version', min_requested_additional_capability_version), ('preferred_requested_additional_capability_version', preferred_requested_additional_capability_version), ('target_performance_parameters', target_performance_parameters), ])


class yc_compute_requirements_mec_app_descriptor__app_descriptor_virtual_compute_compute_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/compute-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies compute requirements
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'compute-requirements'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'compute-requirements']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/virtual_compute/compute_requirements/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/virtual_compute/compute_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/virtual_compute/compute_requirements/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/virtual_compute/compute_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_vdu_mem_requirements_mec_app_descriptor__app_descriptor_virtual_compute_virtual_memory_vdu_mem_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/virtual-memory/vdu-mem-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the memory requirements for the VDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'vdu-mem-requirements'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'virtual-memory', 'vdu-mem-requirements']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/vdu_mem_requirements/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/vdu_mem_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/vdu_mem_requirements/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/vdu_mem_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_virtual_memory_mec_app_descriptor__app_descriptor_virtual_compute_virtual_memory(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/virtual-memory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual memory of the virtualised compute
  """
  __slots__ = ('_path_helper', '_extmethods', '__mem_size','__mem_oversubscription_policy','__vdu_mem_requirements','__numa_enabled',)

  _yang_name = 'virtual-memory'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mem_size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mem-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__mem_oversubscription_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mem-oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__vdu_mem_requirements = YANGDynClass(base=YANGListType("key",yc_vdu_mem_requirements_mec_app_descriptor__app_descriptor_virtual_compute_virtual_memory_vdu_mem_requirements, yang_name="vdu-mem-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-mem-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__numa_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'virtual-memory']

  def _get_mem_size(self):
    """
    Getter method for mem_size, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/mem_size (uint64)

    YANG Description: Amount of virtual Memory (e.g. in MB)
    """
    return self.__mem_size
      
  def _set_mem_size(self, v, load=False):
    """
    Setter method for mem_size, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/mem_size (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mem_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mem_size() directly.

    YANG Description: Amount of virtual Memory (e.g. in MB)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mem-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mem_size must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mem-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__mem_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mem_size(self):
    self.__mem_size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="mem-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_mem_oversubscription_policy(self):
    """
    Getter method for mem_oversubscription_policy, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/mem_oversubscription_policy (string)

    YANG Description: The memory core oversubscription policy in terms of virtual memory to physical memory on the platform
    """
    return self.__mem_oversubscription_policy
      
  def _set_mem_oversubscription_policy(self, v, load=False):
    """
    Setter method for mem_oversubscription_policy, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/mem_oversubscription_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mem_oversubscription_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mem_oversubscription_policy() directly.

    YANG Description: The memory core oversubscription policy in terms of virtual memory to physical memory on the platform
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mem-oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mem_oversubscription_policy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mem-oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__mem_oversubscription_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mem_oversubscription_policy(self):
    self.__mem_oversubscription_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mem-oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_vdu_mem_requirements(self):
    """
    Getter method for vdu_mem_requirements, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/vdu_mem_requirements (list)

    YANG Description: Specifies the memory requirements for the VDU
    """
    return self.__vdu_mem_requirements
      
  def _set_vdu_mem_requirements(self, v, load=False):
    """
    Setter method for vdu_mem_requirements, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/vdu_mem_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_mem_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_mem_requirements() directly.

    YANG Description: Specifies the memory requirements for the VDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_vdu_mem_requirements_mec_app_descriptor__app_descriptor_virtual_compute_virtual_memory_vdu_mem_requirements, yang_name="vdu-mem-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-mem-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_mem_requirements must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_vdu_mem_requirements_mec_app_descriptor__app_descriptor_virtual_compute_virtual_memory_vdu_mem_requirements, yang_name="vdu-mem-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-mem-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__vdu_mem_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_mem_requirements(self):
    self.__vdu_mem_requirements = YANGDynClass(base=YANGListType("key",yc_vdu_mem_requirements_mec_app_descriptor__app_descriptor_virtual_compute_virtual_memory_vdu_mem_requirements, yang_name="vdu-mem-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-mem-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_numa_enabled(self):
    """
    Getter method for numa_enabled, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/numa_enabled (boolean)

    YANG Description: It specifies the memory allocation to be cognisant of the relevant process/core allocation
    """
    return self.__numa_enabled
      
  def _set_numa_enabled(self, v, load=False):
    """
    Setter method for numa_enabled, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory/numa_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numa_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numa_enabled() directly.

    YANG Description: It specifies the memory allocation to be cognisant of the relevant process/core allocation
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numa_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__numa_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numa_enabled(self):
    self.__numa_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

  mem_size = __builtin__.property(_get_mem_size, _set_mem_size)
  mem_oversubscription_policy = __builtin__.property(_get_mem_oversubscription_policy, _set_mem_oversubscription_policy)
  vdu_mem_requirements = __builtin__.property(_get_vdu_mem_requirements, _set_vdu_mem_requirements)
  numa_enabled = __builtin__.property(_get_numa_enabled, _set_numa_enabled)


  _pyangbind_elements = OrderedDict([('mem_size', mem_size), ('mem_oversubscription_policy', mem_oversubscription_policy), ('vdu_mem_requirements', vdu_mem_requirements), ('numa_enabled', numa_enabled), ])


class yc_vdu_cpu_requirements_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_vdu_cpu_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/virtual-cpu/vdu-cpu-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the CPU requirements for the VDU
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'vdu-cpu-requirements'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'virtual-cpu', 'vdu-cpu-requirements']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/vdu_cpu_requirements/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/vdu_cpu_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/vdu_cpu_requirements/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/vdu_cpu_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_pinning_rule_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_cpu_pinning_pinning_rule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/virtual-cpu/cpu-pinning/pinning-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of rules that should be considered during the allocation of the virtual CPUs to logical CPUs in case of 'STATIC' virtualCpuPinningPolicy
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'pinning-rule'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'virtual-cpu', 'cpu-pinning', 'pinning-rule']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_cpu_pinning_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_cpu_pinning(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/virtual-cpu/cpu-pinning. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual CPU pinning configuration
  """
  __slots__ = ('_path_helper', '_extmethods', '__pinning_policy','__pinning_rule',)

  _yang_name = 'cpu-pinning'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__pinning_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="pinning-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__pinning_rule = YANGDynClass(base=YANGListType("key",yc_pinning_rule_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_cpu_pinning_pinning_rule, yang_name="pinning-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="pinning-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'virtual-cpu', 'cpu-pinning']

  def _get_pinning_policy(self):
    """
    Getter method for pinning_policy, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_pinning/pinning_policy (enumeration)

    YANG Description: Indicates the policy for CPU pinning
    """
    return self.__pinning_policy
      
  def _set_pinning_policy(self, v, load=False):
    """
    Setter method for pinning_policy, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_pinning/pinning_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pinning_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pinning_policy() directly.

    YANG Description: Indicates the policy for CPU pinning
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="pinning-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pinning_policy must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="pinning-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__pinning_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pinning_policy(self):
    self.__pinning_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="pinning-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_pinning_rule(self):
    """
    Getter method for pinning_rule, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule (list)

    YANG Description: List of rules that should be considered during the allocation of the virtual CPUs to logical CPUs in case of 'STATIC' virtualCpuPinningPolicy
    """
    return self.__pinning_rule
      
  def _set_pinning_rule(self, v, load=False):
    """
    Setter method for pinning_rule, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_pinning/pinning_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pinning_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pinning_rule() directly.

    YANG Description: List of rules that should be considered during the allocation of the virtual CPUs to logical CPUs in case of 'STATIC' virtualCpuPinningPolicy
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_pinning_rule_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_cpu_pinning_pinning_rule, yang_name="pinning-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="pinning-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pinning_rule must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_pinning_rule_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_cpu_pinning_pinning_rule, yang_name="pinning-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="pinning-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__pinning_rule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pinning_rule(self):
    self.__pinning_rule = YANGDynClass(base=YANGListType("key",yc_pinning_rule_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_cpu_pinning_pinning_rule, yang_name="pinning-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="pinning-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  pinning_policy = __builtin__.property(_get_pinning_policy, _set_pinning_policy)
  pinning_rule = __builtin__.property(_get_pinning_rule, _set_pinning_rule)


  _pyangbind_elements = OrderedDict([('pinning_policy', pinning_policy), ('pinning_rule', pinning_rule), ])


class yc_virtual_cpu_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/virtual-cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual CPU(s) of the virtualised compute
  """
  __slots__ = ('_path_helper', '_extmethods', '__architecture','__num_cpus','__cpu_clock','__cpu_oversubscription_policy','__vdu_cpu_requirements','__cpu_pinning',)

  _yang_name = 'virtual-cpu'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__architecture = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="architecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__num_cpus = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="num-cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint16', is_config=True)
    self.__cpu_clock = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__cpu_oversubscription_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu-oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__vdu_cpu_requirements = YANGDynClass(base=YANGListType("key",yc_vdu_cpu_requirements_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_vdu_cpu_requirements, yang_name="vdu-cpu-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-cpu-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__cpu_pinning = YANGDynClass(base=yc_cpu_pinning_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_cpu_pinning, is_container='container', yang_name="cpu-pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'virtual-cpu']

  def _get_architecture(self):
    """
    Getter method for architecture, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/architecture (string)

    YANG Description: CPU architecture type. Examples are x86, ARM
    """
    return self.__architecture
      
  def _set_architecture(self, v, load=False):
    """
    Setter method for architecture, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/architecture (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_architecture is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_architecture() directly.

    YANG Description: CPU architecture type. Examples are x86, ARM
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="architecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """architecture must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="architecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__architecture = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_architecture(self):
    self.__architecture = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="architecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_num_cpus(self):
    """
    Getter method for num_cpus, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/num_cpus (uint16)

    YANG Description: Number of virtual CPUs
    """
    return self.__num_cpus
      
  def _set_num_cpus(self, v, load=False):
    """
    Setter method for num_cpus, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/num_cpus (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_cpus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_cpus() directly.

    YANG Description: Number of virtual CPUs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="num-cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_cpus must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="num-cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint16', is_config=True)""",
        })

    self.__num_cpus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_cpus(self):
    self.__num_cpus = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="num-cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint16', is_config=True)


  def _get_cpu_clock(self):
    """
    Getter method for cpu_clock, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_clock (uint64)

    YANG Description: Minimum virtual CPU clock rate (e.g. in MHz)
    """
    return self.__cpu_clock
      
  def _set_cpu_clock(self, v, load=False):
    """
    Setter method for cpu_clock, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_clock (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_clock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_clock() directly.

    YANG Description: Minimum virtual CPU clock rate (e.g. in MHz)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_clock must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__cpu_clock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_clock(self):
    self.__cpu_clock = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_cpu_oversubscription_policy(self):
    """
    Getter method for cpu_oversubscription_policy, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_oversubscription_policy (string)

    YANG Description: The CPU core oversubscription policy e.g. the relation of virtual CPU cores to physical CPU cores/threads
    """
    return self.__cpu_oversubscription_policy
      
  def _set_cpu_oversubscription_policy(self, v, load=False):
    """
    Setter method for cpu_oversubscription_policy, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_oversubscription_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_oversubscription_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_oversubscription_policy() directly.

    YANG Description: The CPU core oversubscription policy e.g. the relation of virtual CPU cores to physical CPU cores/threads
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cpu-oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_oversubscription_policy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu-oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__cpu_oversubscription_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_oversubscription_policy(self):
    self.__cpu_oversubscription_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu-oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_vdu_cpu_requirements(self):
    """
    Getter method for vdu_cpu_requirements, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/vdu_cpu_requirements (list)

    YANG Description: Specifies the CPU requirements for the VDU
    """
    return self.__vdu_cpu_requirements
      
  def _set_vdu_cpu_requirements(self, v, load=False):
    """
    Setter method for vdu_cpu_requirements, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/vdu_cpu_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_cpu_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_cpu_requirements() directly.

    YANG Description: Specifies the CPU requirements for the VDU
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_vdu_cpu_requirements_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_vdu_cpu_requirements, yang_name="vdu-cpu-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-cpu-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vdu_cpu_requirements must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_vdu_cpu_requirements_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_vdu_cpu_requirements, yang_name="vdu-cpu-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-cpu-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__vdu_cpu_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vdu_cpu_requirements(self):
    self.__vdu_cpu_requirements = YANGDynClass(base=YANGListType("key",yc_vdu_cpu_requirements_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_vdu_cpu_requirements, yang_name="vdu-cpu-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-cpu-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_cpu_pinning(self):
    """
    Getter method for cpu_pinning, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_pinning (container)

    YANG Description: The virtual CPU pinning configuration
    """
    return self.__cpu_pinning
      
  def _set_cpu_pinning(self, v, load=False):
    """
    Setter method for cpu_pinning, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu/cpu_pinning (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_pinning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_pinning() directly.

    YANG Description: The virtual CPU pinning configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cpu_pinning_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_cpu_pinning, is_container='container', yang_name="cpu-pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu_pinning must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cpu_pinning_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_cpu_pinning, is_container='container', yang_name="cpu-pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__cpu_pinning = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu_pinning(self):
    self.__cpu_pinning = YANGDynClass(base=yc_cpu_pinning_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu_cpu_pinning, is_container='container', yang_name="cpu-pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  architecture = __builtin__.property(_get_architecture, _set_architecture)
  num_cpus = __builtin__.property(_get_num_cpus, _set_num_cpus)
  cpu_clock = __builtin__.property(_get_cpu_clock, _set_cpu_clock)
  cpu_oversubscription_policy = __builtin__.property(_get_cpu_oversubscription_policy, _set_cpu_oversubscription_policy)
  vdu_cpu_requirements = __builtin__.property(_get_vdu_cpu_requirements, _set_vdu_cpu_requirements)
  cpu_pinning = __builtin__.property(_get_cpu_pinning, _set_cpu_pinning)


  _pyangbind_elements = OrderedDict([('architecture', architecture), ('num_cpus', num_cpus), ('cpu_clock', cpu_clock), ('cpu_oversubscription_policy', cpu_oversubscription_policy), ('vdu_cpu_requirements', vdu_cpu_requirements), ('cpu_pinning', cpu_pinning), ])


class yc_virtual_disk_mec_app_descriptor__app_descriptor_virtual_compute_virtual_disk(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute/virtual-disk. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The local or ephemeral disk(s) of the virtualised compute
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__hosting_provides_iops','__guaranteed_iops','__max_iops',)

  _yang_name = 'virtual-disk'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__hosting_provides_iops = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__guaranteed_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute', 'virtual-disk']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/virtual_compute/virtual_disk/id (string)

    YANG Description: Unique identifier of the virtual disk in the VNFD
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/virtual_compute/virtual_disk/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the virtual disk in the VNFD
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_hosting_provides_iops(self):
    """
    Getter method for hosting_provides_iops, mapped from YANG variable /app_descriptor/virtual_compute/virtual_disk/hosting_provides_iops (boolean)

    YANG Description: If set to true, the NFVI provides dedicated IOPS (I/O operations per second) to the virtualised block storage resource
    """
    return self.__hosting_provides_iops
      
  def _set_hosting_provides_iops(self, v, load=False):
    """
    Setter method for hosting_provides_iops, mapped from YANG variable /app_descriptor/virtual_compute/virtual_disk/hosting_provides_iops (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hosting_provides_iops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hosting_provides_iops() directly.

    YANG Description: If set to true, the NFVI provides dedicated IOPS (I/O operations per second) to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hosting_provides_iops must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__hosting_provides_iops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hosting_provides_iops(self):
    self.__hosting_provides_iops = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_guaranteed_iops(self):
    """
    Getter method for guaranteed_iops, mapped from YANG variable /app_descriptor/virtual_compute/virtual_disk/guaranteed_iops (uint64)

    YANG Description: Minimum IOPS that the NFVI provides to the virtualised block storage resource
    """
    return self.__guaranteed_iops
      
  def _set_guaranteed_iops(self, v, load=False):
    """
    Setter method for guaranteed_iops, mapped from YANG variable /app_descriptor/virtual_compute/virtual_disk/guaranteed_iops (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_guaranteed_iops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_guaranteed_iops() directly.

    YANG Description: Minimum IOPS that the NFVI provides to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """guaranteed_iops must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__guaranteed_iops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_guaranteed_iops(self):
    self.__guaranteed_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_iops(self):
    """
    Getter method for max_iops, mapped from YANG variable /app_descriptor/virtual_compute/virtual_disk/max_iops (uint64)

    YANG Description: Maximum IOPS that the NFVI provides to the virtualised block storage resource
    """
    return self.__max_iops
      
  def _set_max_iops(self, v, load=False):
    """
    Setter method for max_iops, mapped from YANG variable /app_descriptor/virtual_compute/virtual_disk/max_iops (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_iops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_iops() directly.

    YANG Description: Maximum IOPS that the NFVI provides to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_iops must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_iops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_iops(self):
    self.__max_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  hosting_provides_iops = __builtin__.property(_get_hosting_provides_iops, _set_hosting_provides_iops)
  guaranteed_iops = __builtin__.property(_get_guaranteed_iops, _set_guaranteed_iops)
  max_iops = __builtin__.property(_get_max_iops, _set_max_iops)


  _pyangbind_elements = OrderedDict([('id', id), ('hosting_provides_iops', hosting_provides_iops), ('guaranteed_iops', guaranteed_iops), ('max_iops', max_iops), ])


class yc_virtual_compute_mec_app_descriptor__app_descriptor_virtual_compute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-compute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__logical_node_reqs','__request_additional_capabilities','__compute_requirements','__virtual_memory','__virtual_cpu','__virtual_disk',)

  _yang_name = 'virtual-compute'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__logical_node_reqs = YANGDynClass(base=YANGListType("id",yc_logical_node_reqs_mec_app_descriptor__app_descriptor_virtual_compute_logical_node_reqs, yang_name="logical-node-reqs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="logical-node-reqs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__request_additional_capabilities = YANGDynClass(base=YANGListType("name",yc_request_additional_capabilities_mec_app_descriptor__app_descriptor_virtual_compute_request_additional_capabilities, yang_name="request-additional-capabilities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="request-additional-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__compute_requirements = YANGDynClass(base=YANGListType("key",yc_compute_requirements_mec_app_descriptor__app_descriptor_virtual_compute_compute_requirements, yang_name="compute-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="compute-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__virtual_memory = YANGDynClass(base=yc_virtual_memory_mec_app_descriptor__app_descriptor_virtual_compute_virtual_memory, is_container='container', yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__virtual_cpu = YANGDynClass(base=yc_virtual_cpu_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu, is_container='container', yang_name="virtual-cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__virtual_disk = YANGDynClass(base=YANGListType("id",yc_virtual_disk_mec_app_descriptor__app_descriptor_virtual_compute_virtual_disk, yang_name="virtual-disk", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-compute']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/virtual_compute/id (string)

    YANG Description: Unique identifier of this virtual-compute-descriptor in the VNFD
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/virtual_compute/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this virtual-compute-descriptor in the VNFD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_logical_node_reqs(self):
    """
    Getter method for logical_node_reqs, mapped from YANG variable /app_descriptor/virtual_compute/logical_node_reqs (list)

    YANG Description: The logical node requirements
    """
    return self.__logical_node_reqs
      
  def _set_logical_node_reqs(self, v, load=False):
    """
    Setter method for logical_node_reqs, mapped from YANG variable /app_descriptor/virtual_compute/logical_node_reqs (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_node_reqs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_node_reqs() directly.

    YANG Description: The logical node requirements
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_logical_node_reqs_mec_app_descriptor__app_descriptor_virtual_compute_logical_node_reqs, yang_name="logical-node-reqs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="logical-node-reqs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_node_reqs must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_logical_node_reqs_mec_app_descriptor__app_descriptor_virtual_compute_logical_node_reqs, yang_name="logical-node-reqs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="logical-node-reqs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__logical_node_reqs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_node_reqs(self):
    self.__logical_node_reqs = YANGDynClass(base=YANGListType("id",yc_logical_node_reqs_mec_app_descriptor__app_descriptor_virtual_compute_logical_node_reqs, yang_name="logical-node-reqs", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="logical-node-reqs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_request_additional_capabilities(self):
    """
    Getter method for request_additional_capabilities, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities (list)

    YANG Description: Specifies requirements for additional capabilities
    """
    return self.__request_additional_capabilities
      
  def _set_request_additional_capabilities(self, v, load=False):
    """
    Setter method for request_additional_capabilities, mapped from YANG variable /app_descriptor/virtual_compute/request_additional_capabilities (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_request_additional_capabilities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_request_additional_capabilities() directly.

    YANG Description: Specifies requirements for additional capabilities
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_request_additional_capabilities_mec_app_descriptor__app_descriptor_virtual_compute_request_additional_capabilities, yang_name="request-additional-capabilities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="request-additional-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """request_additional_capabilities must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_request_additional_capabilities_mec_app_descriptor__app_descriptor_virtual_compute_request_additional_capabilities, yang_name="request-additional-capabilities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="request-additional-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__request_additional_capabilities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_request_additional_capabilities(self):
    self.__request_additional_capabilities = YANGDynClass(base=YANGListType("name",yc_request_additional_capabilities_mec_app_descriptor__app_descriptor_virtual_compute_request_additional_capabilities, yang_name="request-additional-capabilities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="request-additional-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_compute_requirements(self):
    """
    Getter method for compute_requirements, mapped from YANG variable /app_descriptor/virtual_compute/compute_requirements (list)

    YANG Description: Specifies compute requirements
    """
    return self.__compute_requirements
      
  def _set_compute_requirements(self, v, load=False):
    """
    Setter method for compute_requirements, mapped from YANG variable /app_descriptor/virtual_compute/compute_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compute_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compute_requirements() directly.

    YANG Description: Specifies compute requirements
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_compute_requirements_mec_app_descriptor__app_descriptor_virtual_compute_compute_requirements, yang_name="compute-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="compute-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """compute_requirements must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_compute_requirements_mec_app_descriptor__app_descriptor_virtual_compute_compute_requirements, yang_name="compute-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="compute-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__compute_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_compute_requirements(self):
    self.__compute_requirements = YANGDynClass(base=YANGListType("key",yc_compute_requirements_mec_app_descriptor__app_descriptor_virtual_compute_compute_requirements, yang_name="compute-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="compute-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_virtual_memory(self):
    """
    Getter method for virtual_memory, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory (container)

    YANG Description: The virtual memory of the virtualised compute
    """
    return self.__virtual_memory
      
  def _set_virtual_memory(self, v, load=False):
    """
    Setter method for virtual_memory, mapped from YANG variable /app_descriptor/virtual_compute/virtual_memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_memory() directly.

    YANG Description: The virtual memory of the virtualised compute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_virtual_memory_mec_app_descriptor__app_descriptor_virtual_compute_virtual_memory, is_container='container', yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_memory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_virtual_memory_mec_app_descriptor__app_descriptor_virtual_compute_virtual_memory, is_container='container', yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__virtual_memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_memory(self):
    self.__virtual_memory = YANGDynClass(base=yc_virtual_memory_mec_app_descriptor__app_descriptor_virtual_compute_virtual_memory, is_container='container', yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_virtual_cpu(self):
    """
    Getter method for virtual_cpu, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu (container)

    YANG Description: The virtual CPU(s) of the virtualised compute
    """
    return self.__virtual_cpu
      
  def _set_virtual_cpu(self, v, load=False):
    """
    Setter method for virtual_cpu, mapped from YANG variable /app_descriptor/virtual_compute/virtual_cpu (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_cpu() directly.

    YANG Description: The virtual CPU(s) of the virtualised compute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_virtual_cpu_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu, is_container='container', yang_name="virtual-cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_cpu must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_virtual_cpu_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu, is_container='container', yang_name="virtual-cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__virtual_cpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_cpu(self):
    self.__virtual_cpu = YANGDynClass(base=yc_virtual_cpu_mec_app_descriptor__app_descriptor_virtual_compute_virtual_cpu, is_container='container', yang_name="virtual-cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_virtual_disk(self):
    """
    Getter method for virtual_disk, mapped from YANG variable /app_descriptor/virtual_compute/virtual_disk (list)

    YANG Description: The local or ephemeral disk(s) of the virtualised compute
    """
    return self.__virtual_disk
      
  def _set_virtual_disk(self, v, load=False):
    """
    Setter method for virtual_disk, mapped from YANG variable /app_descriptor/virtual_compute/virtual_disk (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_disk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_disk() directly.

    YANG Description: The local or ephemeral disk(s) of the virtualised compute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_virtual_disk_mec_app_descriptor__app_descriptor_virtual_compute_virtual_disk, yang_name="virtual-disk", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_disk must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_disk_mec_app_descriptor__app_descriptor_virtual_compute_virtual_disk, yang_name="virtual-disk", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__virtual_disk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_disk(self):
    self.__virtual_disk = YANGDynClass(base=YANGListType("id",yc_virtual_disk_mec_app_descriptor__app_descriptor_virtual_compute_virtual_disk, yang_name="virtual-disk", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  logical_node_reqs = __builtin__.property(_get_logical_node_reqs, _set_logical_node_reqs)
  request_additional_capabilities = __builtin__.property(_get_request_additional_capabilities, _set_request_additional_capabilities)
  compute_requirements = __builtin__.property(_get_compute_requirements, _set_compute_requirements)
  virtual_memory = __builtin__.property(_get_virtual_memory, _set_virtual_memory)
  virtual_cpu = __builtin__.property(_get_virtual_cpu, _set_virtual_cpu)
  virtual_disk = __builtin__.property(_get_virtual_disk, _set_virtual_disk)


  _pyangbind_elements = OrderedDict([('id', id), ('logical_node_reqs', logical_node_reqs), ('request_additional_capabilities', request_additional_capabilities), ('compute_requirements', compute_requirements), ('virtual_memory', virtual_memory), ('virtual_cpu', virtual_cpu), ('virtual_disk', virtual_disk), ])


class yc_sw_image_mec_app_descriptor__app_descriptor_sw_image(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/sw-image. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__version','__checksum','__container_format','__disk_format','__min_disk','__min_ram','__size','__sw_image','__operating_system','__supported_virtualisation_environment',)

  _yang_name = 'sw-image'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__container_format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__disk_format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__min_disk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__min_ram = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__sw_image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__operating_system = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__supported_virtualisation_environment = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualisation-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'sw-image']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/sw_image/id (string)

    YANG Description: The identifier of this software image.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/sw_image/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The identifier of this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/sw_image/name (string)

    YANG Description: The name of this software image.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/sw_image/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/sw_image/version (string)

    YANG Description: The version of this software image.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/sw_image/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_checksum(self):
    """
    Getter method for checksum, mapped from YANG variable /app_descriptor/sw_image/checksum (string)

    YANG Description: The checksum of the software image file.
    """
    return self.__checksum
      
  def _set_checksum(self, v, load=False):
    """
    Setter method for checksum, mapped from YANG variable /app_descriptor/sw_image/checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checksum() directly.

    YANG Description: The checksum of the software image file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checksum(self):
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_container_format(self):
    """
    Getter method for container_format, mapped from YANG variable /app_descriptor/sw_image/container_format (string)

    YANG Description: The container format describes the container file format in which software image is provided.
    """
    return self.__container_format
      
  def _set_container_format(self, v, load=False):
    """
    Setter method for container_format, mapped from YANG variable /app_descriptor/sw_image/container_format (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_container_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_container_format() directly.

    YANG Description: The container format describes the container file format in which software image is provided.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """container_format must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__container_format = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_container_format(self):
    self.__container_format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_disk_format(self):
    """
    Getter method for disk_format, mapped from YANG variable /app_descriptor/sw_image/disk_format (string)

    YANG Description: The disk format of a software image is the format of the underlying disk image.
    """
    return self.__disk_format
      
  def _set_disk_format(self, v, load=False):
    """
    Setter method for disk_format, mapped from YANG variable /app_descriptor/sw_image/disk_format (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disk_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disk_format() directly.

    YANG Description: The disk format of a software image is the format of the underlying disk image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disk_format must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__disk_format = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disk_format(self):
    self.__disk_format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_min_disk(self):
    """
    Getter method for min_disk, mapped from YANG variable /app_descriptor/sw_image/min_disk (uint64)

    YANG Description: The minimal disk size requirement for this software image.
    """
    return self.__min_disk
      
  def _set_min_disk(self, v, load=False):
    """
    Setter method for min_disk, mapped from YANG variable /app_descriptor/sw_image/min_disk (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_disk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_disk() directly.

    YANG Description: The minimal disk size requirement for this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_disk must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__min_disk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_disk(self):
    self.__min_disk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_min_ram(self):
    """
    Getter method for min_ram, mapped from YANG variable /app_descriptor/sw_image/min_ram (uint64)

    YANG Description: The minimal RAM requirement for this software image.
    """
    return self.__min_ram
      
  def _set_min_ram(self, v, load=False):
    """
    Setter method for min_ram, mapped from YANG variable /app_descriptor/sw_image/min_ram (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ram is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_ram() directly.

    YANG Description: The minimal RAM requirement for this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ram must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__min_ram = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_ram(self):
    self.__min_ram = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_size(self):
    """
    Getter method for size, mapped from YANG variable /app_descriptor/sw_image/size (uint64)

    YANG Description: The size of this software image file.
    """
    return self.__size
      
  def _set_size(self, v, load=False):
    """
    Setter method for size, mapped from YANG variable /app_descriptor/sw_image/size (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: The size of this software image file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size(self):
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_sw_image(self):
    """
    Getter method for sw_image, mapped from YANG variable /app_descriptor/sw_image/sw_image (string)

    YANG Description: This is a reference to the actual software image.
    """
    return self.__sw_image
      
  def _set_sw_image(self, v, load=False):
    """
    Setter method for sw_image, mapped from YANG variable /app_descriptor/sw_image/sw_image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image() directly.

    YANG Description: This is a reference to the actual software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sw_image must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__sw_image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sw_image(self):
    self.__sw_image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_operating_system(self):
    """
    Getter method for operating_system, mapped from YANG variable /app_descriptor/sw_image/operating_system (string)

    YANG Description: Specifies the operating system used in the software image.
    """
    return self.__operating_system
      
  def _set_operating_system(self, v, load=False):
    """
    Setter method for operating_system, mapped from YANG variable /app_descriptor/sw_image/operating_system (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_system() directly.

    YANG Description: Specifies the operating system used in the software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operating_system must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__operating_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operating_system(self):
    self.__operating_system = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_supported_virtualisation_environment(self):
    """
    Getter method for supported_virtualisation_environment, mapped from YANG variable /app_descriptor/sw_image/supported_virtualisation_environment (string)

    YANG Description: Specifies the virtualisation environments compatible with this software image.
    """
    return self.__supported_virtualisation_environment
      
  def _set_supported_virtualisation_environment(self, v, load=False):
    """
    Setter method for supported_virtualisation_environment, mapped from YANG variable /app_descriptor/sw_image/supported_virtualisation_environment (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_virtualisation_environment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_virtualisation_environment() directly.

    YANG Description: Specifies the virtualisation environments compatible with this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualisation-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supported_virtualisation_environment must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualisation-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__supported_virtualisation_environment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supported_virtualisation_environment(self):
    self.__supported_virtualisation_environment = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualisation-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  checksum = __builtin__.property(_get_checksum, _set_checksum)
  container_format = __builtin__.property(_get_container_format, _set_container_format)
  disk_format = __builtin__.property(_get_disk_format, _set_disk_format)
  min_disk = __builtin__.property(_get_min_disk, _set_min_disk)
  min_ram = __builtin__.property(_get_min_ram, _set_min_ram)
  size = __builtin__.property(_get_size, _set_size)
  sw_image = __builtin__.property(_get_sw_image, _set_sw_image)
  operating_system = __builtin__.property(_get_operating_system, _set_operating_system)
  supported_virtualisation_environment = __builtin__.property(_get_supported_virtualisation_environment, _set_supported_virtualisation_environment)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('checksum', checksum), ('container_format', container_format), ('disk_format', disk_format), ('min_disk', min_disk), ('min_ram', min_ram), ('size', size), ('sw_image', sw_image), ('operating_system', operating_system), ('supported_virtualisation_environment', supported_virtualisation_environment), ])


class yc_block_storage_mec_app_descriptor__app_descriptor_virtual_storage_block_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-storage/block-storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Block storage data, applicable only if typeOfStorage=BLOCK
  """
  __slots__ = ('_path_helper', '_extmethods', '__hosting_provides_iops','__guaranteed_iops','__max_iops',)

  _yang_name = 'block-storage'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hosting_provides_iops = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__guaranteed_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-storage', 'block-storage']

  def _get_hosting_provides_iops(self):
    """
    Getter method for hosting_provides_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/hosting_provides_iops (boolean)

    YANG Description: If set to true, the NFVI provides dedicated IOPS (I/O operations per second) to the virtualised block storage resource
    """
    return self.__hosting_provides_iops
      
  def _set_hosting_provides_iops(self, v, load=False):
    """
    Setter method for hosting_provides_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/hosting_provides_iops (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hosting_provides_iops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hosting_provides_iops() directly.

    YANG Description: If set to true, the NFVI provides dedicated IOPS (I/O operations per second) to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hosting_provides_iops must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__hosting_provides_iops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hosting_provides_iops(self):
    self.__hosting_provides_iops = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_guaranteed_iops(self):
    """
    Getter method for guaranteed_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/guaranteed_iops (uint64)

    YANG Description: Minimum IOPS that the NFVI provides to the virtualised block storage resource
    """
    return self.__guaranteed_iops
      
  def _set_guaranteed_iops(self, v, load=False):
    """
    Setter method for guaranteed_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/guaranteed_iops (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_guaranteed_iops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_guaranteed_iops() directly.

    YANG Description: Minimum IOPS that the NFVI provides to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """guaranteed_iops must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__guaranteed_iops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_guaranteed_iops(self):
    self.__guaranteed_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_iops(self):
    """
    Getter method for max_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/max_iops (uint64)

    YANG Description: Maximum IOPS that the NFVI provides to the virtualised block storage resource
    """
    return self.__max_iops
      
  def _set_max_iops(self, v, load=False):
    """
    Setter method for max_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/max_iops (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_iops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_iops() directly.

    YANG Description: Maximum IOPS that the NFVI provides to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_iops must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_iops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_iops(self):
    self.__max_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  hosting_provides_iops = __builtin__.property(_get_hosting_provides_iops, _set_hosting_provides_iops)
  guaranteed_iops = __builtin__.property(_get_guaranteed_iops, _set_guaranteed_iops)
  max_iops = __builtin__.property(_get_max_iops, _set_max_iops)

  __choices__ = {'storage': {'block-storage': ['hosting_provides_iops', 'guaranteed_iops', 'max_iops']}}
  _pyangbind_elements = OrderedDict([('hosting_provides_iops', hosting_provides_iops), ('guaranteed_iops', guaranteed_iops), ('max_iops', max_iops), ])


class yc_object_storage_mec_app_descriptor__app_descriptor_virtual_storage_object_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-storage/object-storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Object storage data, applicable only if typeOfStorage=OBJECT
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_size_of_object','__max_concurrent_incoming_transfers','__max_concurrent_outgoing_transfers',)

  _yang_name = 'object-storage'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_size_of_object = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-object", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_concurrent_incoming_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_concurrent_outgoing_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-storage', 'object-storage']

  def _get_max_size_of_object(self):
    """
    Getter method for max_size_of_object, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_size_of_object (uint64)

    YANG Description: Maximum size of object that can be stored in the object storage resource
    """
    return self.__max_size_of_object
      
  def _set_max_size_of_object(self, v, load=False):
    """
    Setter method for max_size_of_object, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_size_of_object (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_size_of_object is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_size_of_object() directly.

    YANG Description: Maximum size of object that can be stored in the object storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-object", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_size_of_object must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-object", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_size_of_object = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_size_of_object(self):
    self.__max_size_of_object = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-object", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_concurrent_incoming_transfers(self):
    """
    Getter method for max_concurrent_incoming_transfers, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_concurrent_incoming_transfers (uint64)

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the object storage resource can handle
    """
    return self.__max_concurrent_incoming_transfers
      
  def _set_max_concurrent_incoming_transfers(self, v, load=False):
    """
    Setter method for max_concurrent_incoming_transfers, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_concurrent_incoming_transfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_concurrent_incoming_transfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_concurrent_incoming_transfers() directly.

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the object storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_concurrent_incoming_transfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_concurrent_incoming_transfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_concurrent_incoming_transfers(self):
    self.__max_concurrent_incoming_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_concurrent_outgoing_transfers(self):
    """
    Getter method for max_concurrent_outgoing_transfers, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_concurrent_outgoing_transfers (uint64)

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the object storage resource can handle
    """
    return self.__max_concurrent_outgoing_transfers
      
  def _set_max_concurrent_outgoing_transfers(self, v, load=False):
    """
    Setter method for max_concurrent_outgoing_transfers, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_concurrent_outgoing_transfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_concurrent_outgoing_transfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_concurrent_outgoing_transfers() directly.

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the object storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_concurrent_outgoing_transfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_concurrent_outgoing_transfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_concurrent_outgoing_transfers(self):
    self.__max_concurrent_outgoing_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  max_size_of_object = __builtin__.property(_get_max_size_of_object, _set_max_size_of_object)
  max_concurrent_incoming_transfers = __builtin__.property(_get_max_concurrent_incoming_transfers, _set_max_concurrent_incoming_transfers)
  max_concurrent_outgoing_transfers = __builtin__.property(_get_max_concurrent_outgoing_transfers, _set_max_concurrent_outgoing_transfers)

  __choices__ = {'storage': {'object-storage': ['max_size_of_object', 'max_concurrent_incoming_transfers', 'max_concurrent_outgoing_transfers']}}
  _pyangbind_elements = OrderedDict([('max_size_of_object', max_size_of_object), ('max_concurrent_incoming_transfers', max_concurrent_incoming_transfers), ('max_concurrent_outgoing_transfers', max_concurrent_outgoing_transfers), ])


class yc_file_storage_mec_app_descriptor__app_descriptor_virtual_storage_file_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-storage/file-storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: File storage data, applicable only if typeOfStorage=FILE
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_size_of_file','__max_concurrent_incoming_transfers','__max_concurrent_outgoing_transfers',)

  _yang_name = 'file-storage'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_size_of_file = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-file", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_concurrent_incoming_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_concurrent_outgoing_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-storage', 'file-storage']

  def _get_max_size_of_file(self):
    """
    Getter method for max_size_of_file, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_size_of_file (uint64)

    YANG Description: Maximum size of file that can be stored in the file storage resource
    """
    return self.__max_size_of_file
      
  def _set_max_size_of_file(self, v, load=False):
    """
    Setter method for max_size_of_file, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_size_of_file (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_size_of_file is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_size_of_file() directly.

    YANG Description: Maximum size of file that can be stored in the file storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-file", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_size_of_file must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-file", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_size_of_file = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_size_of_file(self):
    self.__max_size_of_file = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-file", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_concurrent_incoming_transfers(self):
    """
    Getter method for max_concurrent_incoming_transfers, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_concurrent_incoming_transfers (uint64)

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the file storage resource can handle
    """
    return self.__max_concurrent_incoming_transfers
      
  def _set_max_concurrent_incoming_transfers(self, v, load=False):
    """
    Setter method for max_concurrent_incoming_transfers, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_concurrent_incoming_transfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_concurrent_incoming_transfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_concurrent_incoming_transfers() directly.

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the file storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_concurrent_incoming_transfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_concurrent_incoming_transfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_concurrent_incoming_transfers(self):
    self.__max_concurrent_incoming_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_concurrent_outgoing_transfers(self):
    """
    Getter method for max_concurrent_outgoing_transfers, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_concurrent_outgoing_transfers (uint64)

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the file storage resource can handle
    """
    return self.__max_concurrent_outgoing_transfers
      
  def _set_max_concurrent_outgoing_transfers(self, v, load=False):
    """
    Setter method for max_concurrent_outgoing_transfers, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_concurrent_outgoing_transfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_concurrent_outgoing_transfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_concurrent_outgoing_transfers() directly.

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the file storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_concurrent_outgoing_transfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_concurrent_outgoing_transfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_concurrent_outgoing_transfers(self):
    self.__max_concurrent_outgoing_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  max_size_of_file = __builtin__.property(_get_max_size_of_file, _set_max_size_of_file)
  max_concurrent_incoming_transfers = __builtin__.property(_get_max_concurrent_incoming_transfers, _set_max_concurrent_incoming_transfers)
  max_concurrent_outgoing_transfers = __builtin__.property(_get_max_concurrent_outgoing_transfers, _set_max_concurrent_outgoing_transfers)

  __choices__ = {'storage': {'file-storage': ['max_size_of_file', 'max_concurrent_incoming_transfers', 'max_concurrent_outgoing_transfers']}}
  _pyangbind_elements = OrderedDict([('max_size_of_file', max_size_of_file), ('max_concurrent_incoming_transfers', max_concurrent_incoming_transfers), ('max_concurrent_outgoing_transfers', max_concurrent_outgoing_transfers), ])


class yc_virtual_storage_mec_app_descriptor__app_descriptor_virtual_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__type_of_storage','__block_storage','__object_storage','__file_storage','__size_of_storage','__operation_status',)

  _yang_name = 'virtual-storage'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__type_of_storage = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__block_storage = YANGDynClass(base=yc_block_storage_mec_app_descriptor__app_descriptor_virtual_storage_block_storage, is_container='container', yang_name="block-storage", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__object_storage = YANGDynClass(base=yc_object_storage_mec_app_descriptor__app_descriptor_virtual_storage_object_storage, is_container='container', yang_name="object-storage", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__file_storage = YANGDynClass(base=yc_file_storage_mec_app_descriptor__app_descriptor_virtual_storage_file_storage, is_container='container', yang_name="file-storage", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__size_of_storage = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__operation_status = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-storage']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/virtual_storage/id (string)

    YANG Description: Unique identifier for this VirtualStorageDesc
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/virtual_storage/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this VirtualStorageDesc
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_type_of_storage(self):
    """
    Getter method for type_of_storage, mapped from YANG variable /app_descriptor/virtual_storage/type_of_storage (enumeration)

    YANG Description: Type of virtualised storage resource
    """
    return self.__type_of_storage
      
  def _set_type_of_storage(self, v, load=False):
    """
    Setter method for type_of_storage, mapped from YANG variable /app_descriptor/virtual_storage/type_of_storage (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_of_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_of_storage() directly.

    YANG Description: Type of virtualised storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_of_storage must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__type_of_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_of_storage(self):
    self.__type_of_storage = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_block_storage(self):
    """
    Getter method for block_storage, mapped from YANG variable /app_descriptor/virtual_storage/block_storage (container)

    YANG Description: Block storage data, applicable only if typeOfStorage=BLOCK
    """
    return self.__block_storage
      
  def _set_block_storage(self, v, load=False):
    """
    Setter method for block_storage, mapped from YANG variable /app_descriptor/virtual_storage/block_storage (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_block_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_block_storage() directly.

    YANG Description: Block storage data, applicable only if typeOfStorage=BLOCK
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_block_storage_mec_app_descriptor__app_descriptor_virtual_storage_block_storage, is_container='container', yang_name="block-storage", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """block_storage must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_block_storage_mec_app_descriptor__app_descriptor_virtual_storage_block_storage, is_container='container', yang_name="block-storage", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__block_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_block_storage(self):
    self.__block_storage = YANGDynClass(base=yc_block_storage_mec_app_descriptor__app_descriptor_virtual_storage_block_storage, is_container='container', yang_name="block-storage", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_object_storage(self):
    """
    Getter method for object_storage, mapped from YANG variable /app_descriptor/virtual_storage/object_storage (container)

    YANG Description: Object storage data, applicable only if typeOfStorage=OBJECT
    """
    return self.__object_storage
      
  def _set_object_storage(self, v, load=False):
    """
    Setter method for object_storage, mapped from YANG variable /app_descriptor/virtual_storage/object_storage (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_object_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_object_storage() directly.

    YANG Description: Object storage data, applicable only if typeOfStorage=OBJECT
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_object_storage_mec_app_descriptor__app_descriptor_virtual_storage_object_storage, is_container='container', yang_name="object-storage", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """object_storage must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_object_storage_mec_app_descriptor__app_descriptor_virtual_storage_object_storage, is_container='container', yang_name="object-storage", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__object_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_object_storage(self):
    self.__object_storage = YANGDynClass(base=yc_object_storage_mec_app_descriptor__app_descriptor_virtual_storage_object_storage, is_container='container', yang_name="object-storage", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_file_storage(self):
    """
    Getter method for file_storage, mapped from YANG variable /app_descriptor/virtual_storage/file_storage (container)

    YANG Description: File storage data, applicable only if typeOfStorage=FILE
    """
    return self.__file_storage
      
  def _set_file_storage(self, v, load=False):
    """
    Setter method for file_storage, mapped from YANG variable /app_descriptor/virtual_storage/file_storage (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_file_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_file_storage() directly.

    YANG Description: File storage data, applicable only if typeOfStorage=FILE
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_file_storage_mec_app_descriptor__app_descriptor_virtual_storage_file_storage, is_container='container', yang_name="file-storage", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """file_storage must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_file_storage_mec_app_descriptor__app_descriptor_virtual_storage_file_storage, is_container='container', yang_name="file-storage", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__file_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_file_storage(self):
    self.__file_storage = YANGDynClass(base=yc_file_storage_mec_app_descriptor__app_descriptor_virtual_storage_file_storage, is_container='container', yang_name="file-storage", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_size_of_storage(self):
    """
    Getter method for size_of_storage, mapped from YANG variable /app_descriptor/virtual_storage/size_of_storage (uint64)

    YANG Description: Size of virtualised storage resource (e.g. size of block storage device)
    """
    return self.__size_of_storage
      
  def _set_size_of_storage(self, v, load=False):
    """
    Setter method for size_of_storage, mapped from YANG variable /app_descriptor/virtual_storage/size_of_storage (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size_of_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size_of_storage() directly.

    YANG Description: Size of virtualised storage resource (e.g. size of block storage device)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size_of_storage must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__size_of_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size_of_storage(self):
    self.__size_of_storage = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_operation_status(self):
    """
    Getter method for operation_status, mapped from YANG variable /app_descriptor/virtual_storage/operation_status (string)

    YANG Description: Operation status of the virtualised storage resource
    """
    return self.__operation_status
      
  def _set_operation_status(self, v, load=False):
    """
    Setter method for operation_status, mapped from YANG variable /app_descriptor/virtual_storage/operation_status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operation_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operation_status() directly.

    YANG Description: Operation status of the virtualised storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operation_status must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__operation_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operation_status(self):
    self.__operation_status = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  type_of_storage = __builtin__.property(_get_type_of_storage, _set_type_of_storage)
  block_storage = __builtin__.property(_get_block_storage, _set_block_storage)
  object_storage = __builtin__.property(_get_object_storage, _set_object_storage)
  file_storage = __builtin__.property(_get_file_storage, _set_file_storage)
  size_of_storage = __builtin__.property(_get_size_of_storage, _set_size_of_storage)
  operation_status = __builtin__.property(_get_operation_status, _set_operation_status)

  __choices__ = {'storage': {'block-storage': ['block_storage'], 'object-storage': ['object_storage'], 'file-storage': ['file_storage']}}
  _pyangbind_elements = OrderedDict([('id', id), ('type_of_storage', type_of_storage), ('block_storage', block_storage), ('object_storage', object_storage), ('file_storage', file_storage), ('size_of_storage', size_of_storage), ('operation_status', operation_status), ])


class yc_network_interface_requirement_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements_network_interface_requirement(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ext-cpd/virtual-network-interface-requirements/network-interface-requirement. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The network interface requirement. An element from an array of key-value pairs that articulate the network interface deployment requirements.
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'network-interface-requirement'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ext-cpd', 'virtual-network-interface-requirements', 'network-interface-requirement']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/network_interface_requirement/key (string)

    YANG Description: The key of the requirement
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/network_interface_requirement/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: The key of the requirement
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/network_interface_requirement/value (string)

    YANG Description: The value of the requirement
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/network_interface_requirement/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: The value of the requirement
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_niclo_requirements_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements_niclo_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ext-cpd/virtual-network-interface-requirements/niclo-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This references (couples) the CPD with any logical node I/O requirements (for network devices) that may have been created. Linking these attributes is necessary so that I/O requirements that need to be articulated at the logical node level can be associated with the network interface requirements associated with the CPD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__logical_node_requirement_detail',)

  _yang_name = 'niclo-requirements'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__logical_node_requirement_detail = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="logical-node-requirement-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ext-cpd', 'virtual-network-interface-requirements', 'niclo-requirements']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/niclo_requirements/id (string)

    YANG Description: Identifier of the logical node requirement
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/niclo_requirements/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of the logical node requirement
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_logical_node_requirement_detail(self):
    """
    Getter method for logical_node_requirement_detail, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/niclo_requirements/logical_node_requirement_detail (string)

    YANG Description: The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements. This could include the number of CPU cores on this logical node, a memory configuration specific to a logical node (e.g. such as available in the Linux kernel via the libnuma library) or a requirement related to the association of an I/O device with the logical node.
    """
    return self.__logical_node_requirement_detail
      
  def _set_logical_node_requirement_detail(self, v, load=False):
    """
    Setter method for logical_node_requirement_detail, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/niclo_requirements/logical_node_requirement_detail (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_node_requirement_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_node_requirement_detail() directly.

    YANG Description: The logical node-level compute, memory and I/O requirements. An array of key-value pairs that articulate the deployment requirements. This could include the number of CPU cores on this logical node, a memory configuration specific to a logical node (e.g. such as available in the Linux kernel via the libnuma library) or a requirement related to the association of an I/O device with the logical node.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="logical-node-requirement-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_node_requirement_detail must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="logical-node-requirement-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__logical_node_requirement_detail = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_node_requirement_detail(self):
    self.__logical_node_requirement_detail = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="logical-node-requirement-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  logical_node_requirement_detail = __builtin__.property(_get_logical_node_requirement_detail, _set_logical_node_requirement_detail)


  _pyangbind_elements = OrderedDict([('id', id), ('logical_node_requirement_detail', logical_node_requirement_detail), ])


class yc_virtual_network_interface_requirements_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ext-cpd/virtual-network-interface-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies requirements on a virtual network interface realizing the CPs instantiated from this CPD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__support_mandatory','__network_interface_requirement','__niclo_requirements',)

  _yang_name = 'virtual-network-interface-requirements'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__support_mandatory = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__network_interface_requirement = YANGDynClass(base=yc_network_interface_requirement_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements_network_interface_requirement, is_container='container', yang_name="network-interface-requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__niclo_requirements = YANGDynClass(base=yc_niclo_requirements_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements_niclo_requirements, is_container='container', yang_name="niclo-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ext-cpd', 'virtual-network-interface-requirements']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/name (string)

    YANG Description: Provides a human readable name for the requirement.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Provides a human readable name for the requirement.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/description (string)

    YANG Description: Provides a human readable description of the requirement.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides a human readable description of the requirement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_support_mandatory(self):
    """
    Getter method for support_mandatory, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/support_mandatory (boolean)

    YANG Description: Indicates whether fulfilling the constraint is mandatory (true) for successful operation.
    """
    return self.__support_mandatory
      
  def _set_support_mandatory(self, v, load=False):
    """
    Setter method for support_mandatory, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/support_mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_support_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_support_mandatory() directly.

    YANG Description: Indicates whether fulfilling the constraint is mandatory (true) for successful operation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """support_mandatory must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__support_mandatory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_support_mandatory(self):
    self.__support_mandatory = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_network_interface_requirement(self):
    """
    Getter method for network_interface_requirement, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/network_interface_requirement (container)

    YANG Description: The network interface requirement. An element from an array of key-value pairs that articulate the network interface deployment requirements.
    """
    return self.__network_interface_requirement
      
  def _set_network_interface_requirement(self, v, load=False):
    """
    Setter method for network_interface_requirement, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/network_interface_requirement (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_interface_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_interface_requirement() directly.

    YANG Description: The network interface requirement. An element from an array of key-value pairs that articulate the network interface deployment requirements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_interface_requirement_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements_network_interface_requirement, is_container='container', yang_name="network-interface-requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_interface_requirement must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_interface_requirement_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements_network_interface_requirement, is_container='container', yang_name="network-interface-requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__network_interface_requirement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_interface_requirement(self):
    self.__network_interface_requirement = YANGDynClass(base=yc_network_interface_requirement_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements_network_interface_requirement, is_container='container', yang_name="network-interface-requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_niclo_requirements(self):
    """
    Getter method for niclo_requirements, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/niclo_requirements (container)

    YANG Description: This references (couples) the CPD with any logical node I/O requirements (for network devices) that may have been created. Linking these attributes is necessary so that I/O requirements that need to be articulated at the logical node level can be associated with the network interface requirements associated with the CPD.
    """
    return self.__niclo_requirements
      
  def _set_niclo_requirements(self, v, load=False):
    """
    Setter method for niclo_requirements, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements/niclo_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_niclo_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_niclo_requirements() directly.

    YANG Description: This references (couples) the CPD with any logical node I/O requirements (for network devices) that may have been created. Linking these attributes is necessary so that I/O requirements that need to be articulated at the logical node level can be associated with the network interface requirements associated with the CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_niclo_requirements_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements_niclo_requirements, is_container='container', yang_name="niclo-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """niclo_requirements must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_niclo_requirements_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements_niclo_requirements, is_container='container', yang_name="niclo-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__niclo_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_niclo_requirements(self):
    self.__niclo_requirements = YANGDynClass(base=yc_niclo_requirements_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements_niclo_requirements, is_container='container', yang_name="niclo-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  support_mandatory = __builtin__.property(_get_support_mandatory, _set_support_mandatory)
  network_interface_requirement = __builtin__.property(_get_network_interface_requirement, _set_network_interface_requirement)
  niclo_requirements = __builtin__.property(_get_niclo_requirements, _set_niclo_requirements)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('support_mandatory', support_mandatory), ('network_interface_requirement', network_interface_requirement), ('niclo_requirements', niclo_requirements), ])


class yc_l3_address_data_mec_app_descriptor__app_descriptor_ext_cpd_address_data_l3_address_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ext-cpd/address-data/l3-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The L3 address data for the CP instantiated from this CPD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip_address_type','__number_of_ip_addresses','__ip_address_assignment','__floating_ip_activated','__ip_address_reservation',)

  _yang_name = 'l3-address-data'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip_address_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__number_of_ip_addresses = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    self.__ip_address_assignment = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DYNAMIC': {}, 'STATIC': {}},)), is_leaf=False, yang_name="ip-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__floating_ip_activated = YANGDynClass(unique=True, base=TypedListType(allowed_type=YANGBool), is_leaf=False, yang_name="floating-ip-activated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__ip_address_reservation = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="ip-address-reservation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ext-cpd', 'address-data', 'l3-address-data']

  def _get_ip_address_type(self):
    """
    Getter method for ip_address_type, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data/ip_address_type (enumeration)

    YANG Description: The type of the IP address.
    """
    return self.__ip_address_type
      
  def _set_ip_address_type(self, v, load=False):
    """
    Setter method for ip_address_type, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data/ip_address_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_type() directly.

    YANG Description: The type of the IP address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address_type must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__ip_address_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address_type(self):
    self.__ip_address_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_number_of_ip_addresses(self):
    """
    Getter method for number_of_ip_addresses, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data/number_of_ip_addresses (uint32)

    YANG Description: The number of IP addresses to assign to the CP instantiated from this CPD.
    """
    return self.__number_of_ip_addresses
      
  def _set_number_of_ip_addresses(self, v, load=False):
    """
    Setter method for number_of_ip_addresses, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data/number_of_ip_addresses (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_ip_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_ip_addresses() directly.

    YANG Description: The number of IP addresses to assign to the CP instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """number_of_ip_addresses must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__number_of_ip_addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_number_of_ip_addresses(self):
    self.__number_of_ip_addresses = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)


  def _get_ip_address_assignment(self):
    """
    Getter method for ip_address_assignment, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data/ip_address_assignment (enumeration)

    YANG Description: Specifies how the IP address(es) will be assigned.
    """
    return self.__ip_address_assignment
      
  def _set_ip_address_assignment(self, v, load=False):
    """
    Setter method for ip_address_assignment, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data/ip_address_assignment (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_assignment() directly.

    YANG Description: Specifies how the IP address(es) will be assigned.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DYNAMIC': {}, 'STATIC': {}},)), is_leaf=False, yang_name="ip-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address_assignment must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DYNAMIC': {}, 'STATIC': {}},)), is_leaf=False, yang_name="ip-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__ip_address_assignment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address_assignment(self):
    self.__ip_address_assignment = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DYNAMIC': {}, 'STATIC': {}},)), is_leaf=False, yang_name="ip-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_floating_ip_activated(self):
    """
    Getter method for floating_ip_activated, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data/floating_ip_activated (boolean)

    YANG Description: Specify if the floating IP scheme is activated on the CP instantiated from this CPD.
    """
    return self.__floating_ip_activated
      
  def _set_floating_ip_activated(self, v, load=False):
    """
    Setter method for floating_ip_activated, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data/floating_ip_activated (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_activated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_activated() directly.

    YANG Description: Specify if the floating IP scheme is activated on the CP instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=YANGBool), is_leaf=False, yang_name="floating-ip-activated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """floating_ip_activated must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=YANGBool), is_leaf=False, yang_name="floating-ip-activated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__floating_ip_activated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_floating_ip_activated(self):
    self.__floating_ip_activated = YANGDynClass(unique=True, base=TypedListType(allowed_type=YANGBool), is_leaf=False, yang_name="floating-ip-activated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_ip_address_reservation(self):
    """
    Getter method for ip_address_reservation, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data/ip_address_reservation (inet:ip-address)

    YANG Description: Specifies the IP addresses to be assigned.
    """
    return self.__ip_address_reservation
      
  def _set_ip_address_reservation(self, v, load=False):
    """
    Setter method for ip_address_reservation, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data/ip_address_reservation (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_reservation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_reservation() directly.

    YANG Description: Specifies the IP addresses to be assigned.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="ip-address-reservation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address_reservation must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="ip-address-reservation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__ip_address_reservation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address_reservation(self):
    self.__ip_address_reservation = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="ip-address-reservation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

  ip_address_type = __builtin__.property(_get_ip_address_type, _set_ip_address_type)
  number_of_ip_addresses = __builtin__.property(_get_number_of_ip_addresses, _set_number_of_ip_addresses)
  ip_address_assignment = __builtin__.property(_get_ip_address_assignment, _set_ip_address_assignment)
  floating_ip_activated = __builtin__.property(_get_floating_ip_activated, _set_floating_ip_activated)
  ip_address_reservation = __builtin__.property(_get_ip_address_reservation, _set_ip_address_reservation)


  _pyangbind_elements = OrderedDict([('ip_address_type', ip_address_type), ('number_of_ip_addresses', number_of_ip_addresses), ('ip_address_assignment', ip_address_assignment), ('floating_ip_activated', floating_ip_activated), ('ip_address_reservation', ip_address_reservation), ])


class yc_address_data_mec_app_descriptor__app_descriptor_ext_cpd_address_data(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ext-cpd/address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides information on the addresses to be assigned to the CP(s) instantiated from this CPD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address_type','__l2_address_data','__l3_address_data',)

  _yang_name = 'address-data'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MAC_ADDRESS': {}, 'IP_ADDRESS': {}},), is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__l2_address_data = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="l2-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    self.__l3_address_data = YANGDynClass(base=yc_l3_address_data_mec_app_descriptor__app_descriptor_ext_cpd_address_data_l3_address_data, is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ext-cpd', 'address-data']

  def _get_address_type(self):
    """
    Getter method for address_type, mapped from YANG variable /app_descriptor/ext_cpd/address_data/address_type (enumeration)

    YANG Description: Describes the type of the address to be assigned to the CP instantiated from this CPD.
    """
    return self.__address_type
      
  def _set_address_type(self, v, load=False):
    """
    Setter method for address_type, mapped from YANG variable /app_descriptor/ext_cpd/address_data/address_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_type() directly.

    YANG Description: Describes the type of the address to be assigned to the CP instantiated from this CPD.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MAC_ADDRESS': {}, 'IP_ADDRESS': {}},), is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_type must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MAC_ADDRESS': {}, 'IP_ADDRESS': {}},), is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__address_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_type(self):
    self.__address_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MAC_ADDRESS': {}, 'IP_ADDRESS': {}},), is_leaf=True, yang_name="address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_l2_address_data(self):
    """
    Getter method for l2_address_data, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l2_address_data (yang:mac-address)

    YANG Description: Specifies the L2 address to be assigned to the CP instantiated from this CPD.
    """
    return self.__l2_address_data
      
  def _set_l2_address_data(self, v, load=False):
    """
    Setter method for l2_address_data, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l2_address_data (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_address_data() directly.

    YANG Description: Specifies the L2 address to be assigned to the CP instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="l2-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2_address_data must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="l2-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__l2_address_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2_address_data(self):
    self.__l2_address_data = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="l2-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)


  def _get_l3_address_data(self):
    """
    Getter method for l3_address_data, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data (container)

    YANG Description: The L3 address data for the CP instantiated from this CPD.
    """
    return self.__l3_address_data
      
  def _set_l3_address_data(self, v, load=False):
    """
    Setter method for l3_address_data, mapped from YANG variable /app_descriptor/ext_cpd/address_data/l3_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_address_data() directly.

    YANG Description: The L3 address data for the CP instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3_address_data_mec_app_descriptor__app_descriptor_ext_cpd_address_data_l3_address_data, is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3_address_data must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3_address_data_mec_app_descriptor__app_descriptor_ext_cpd_address_data_l3_address_data, is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__l3_address_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3_address_data(self):
    self.__l3_address_data = YANGDynClass(base=yc_l3_address_data_mec_app_descriptor__app_descriptor_ext_cpd_address_data_l3_address_data, is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  address_type = __builtin__.property(_get_address_type, _set_address_type)
  l2_address_data = __builtin__.property(_get_l2_address_data, _set_l2_address_data)
  l3_address_data = __builtin__.property(_get_l3_address_data, _set_l3_address_data)


  _pyangbind_elements = OrderedDict([('address_type', address_type), ('l2_address_data', l2_address_data), ('l3_address_data', l3_address_data), ])


class yc_ext_cpd_mec_app_descriptor__app_descriptor_ext_cpd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ext-cpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__virtual_network_interface_requirements','__cpd_id','__layer_protocol','__cp_role','__description','__address_data',)

  _yang_name = 'ext-cpd'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__virtual_network_interface_requirements = YANGDynClass(base=YANGListType("name",yc_virtual_network_interface_requirements_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements, yang_name="virtual-network-interface-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtual-network-interface-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__layer_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ETHERNET': {}, 'MPLS': {}, 'ODU2': {}, 'IPV4': {}, 'IPV6': {}, 'PSEUDO_WIRE': {}},), is_leaf=True, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__cp_role = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__address_data = YANGDynClass(base=YANGListType("address_type",yc_address_data_mec_app_descriptor__app_descriptor_ext_cpd_address_data, yang_name="address-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-type', extensions=None), is_container='list', yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ext-cpd']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/ext_cpd/id (string)

    YANG Description: Identifier of the external connection point
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/ext_cpd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of the external connection point
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_virtual_network_interface_requirements(self):
    """
    Getter method for virtual_network_interface_requirements, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements (list)

    YANG Description: Specifies requirements on a virtual network interface realizing the CPs instantiated from this CPD.
    """
    return self.__virtual_network_interface_requirements
      
  def _set_virtual_network_interface_requirements(self, v, load=False):
    """
    Setter method for virtual_network_interface_requirements, mapped from YANG variable /app_descriptor/ext_cpd/virtual_network_interface_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_network_interface_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_network_interface_requirements() directly.

    YANG Description: Specifies requirements on a virtual network interface realizing the CPs instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_virtual_network_interface_requirements_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements, yang_name="virtual-network-interface-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtual-network-interface-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_network_interface_requirements must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_virtual_network_interface_requirements_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements, yang_name="virtual-network-interface-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtual-network-interface-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__virtual_network_interface_requirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_network_interface_requirements(self):
    self.__virtual_network_interface_requirements = YANGDynClass(base=YANGListType("name",yc_virtual_network_interface_requirements_mec_app_descriptor__app_descriptor_ext_cpd_virtual_network_interface_requirements, yang_name="virtual-network-interface-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtual-network-interface-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_cpd_id(self):
    """
    Getter method for cpd_id, mapped from YANG variable /app_descriptor/ext_cpd/cpd_id (string)

    YANG Description: Identifier of this Cpd information element.
    """
    return self.__cpd_id
      
  def _set_cpd_id(self, v, load=False):
    """
    Setter method for cpd_id, mapped from YANG variable /app_descriptor/ext_cpd/cpd_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpd_id() directly.

    YANG Description: Identifier of this Cpd information element.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpd_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__cpd_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpd_id(self):
    self.__cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_layer_protocol(self):
    """
    Getter method for layer_protocol, mapped from YANG variable /app_descriptor/ext_cpd/layer_protocol (enumeration)

    YANG Description: Identifies which protocol the CP uses for connectivity purposes.
    """
    return self.__layer_protocol
      
  def _set_layer_protocol(self, v, load=False):
    """
    Setter method for layer_protocol, mapped from YANG variable /app_descriptor/ext_cpd/layer_protocol (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer_protocol() directly.

    YANG Description: Identifies which protocol the CP uses for connectivity purposes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ETHERNET': {}, 'MPLS': {}, 'ODU2': {}, 'IPV4': {}, 'IPV6': {}, 'PSEUDO_WIRE': {}},), is_leaf=True, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """layer_protocol must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ETHERNET': {}, 'MPLS': {}, 'ODU2': {}, 'IPV4': {}, 'IPV6': {}, 'PSEUDO_WIRE': {}},), is_leaf=True, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__layer_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_layer_protocol(self):
    self.__layer_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ETHERNET': {}, 'MPLS': {}, 'ODU2': {}, 'IPV4': {}, 'IPV6': {}, 'PSEUDO_WIRE': {}},), is_leaf=True, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_cp_role(self):
    """
    Getter method for cp_role, mapped from YANG variable /app_descriptor/ext_cpd/cp_role (string)

    YANG Description: Identifies the role of the CP in the context of the traffic flow patterns in the VNF or parent NS.
    """
    return self.__cp_role
      
  def _set_cp_role(self, v, load=False):
    """
    Setter method for cp_role, mapped from YANG variable /app_descriptor/ext_cpd/cp_role (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_role() directly.

    YANG Description: Identifies the role of the CP in the context of the traffic flow patterns in the VNF or parent NS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cp-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cp_role must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__cp_role = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cp_role(self):
    self.__cp_role = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cp-role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/ext_cpd/description (string)

    YANG Description: Provides human-readable information on the purpose of the CP.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/ext_cpd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides human-readable information on the purpose of the CP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_address_data(self):
    """
    Getter method for address_data, mapped from YANG variable /app_descriptor/ext_cpd/address_data (list)

    YANG Description: Provides information on the addresses to be assigned to the CP(s) instantiated from this CPD.
    """
    return self.__address_data
      
  def _set_address_data(self, v, load=False):
    """
    Setter method for address_data, mapped from YANG variable /app_descriptor/ext_cpd/address_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_data() directly.

    YANG Description: Provides information on the addresses to be assigned to the CP(s) instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("address_type",yc_address_data_mec_app_descriptor__app_descriptor_ext_cpd_address_data, yang_name="address-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-type', extensions=None), is_container='list', yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_data must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("address_type",yc_address_data_mec_app_descriptor__app_descriptor_ext_cpd_address_data, yang_name="address-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-type', extensions=None), is_container='list', yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__address_data = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_data(self):
    self.__address_data = YANGDynClass(base=YANGListType("address_type",yc_address_data_mec_app_descriptor__app_descriptor_ext_cpd_address_data, yang_name="address-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address-type', extensions=None), is_container='list', yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  virtual_network_interface_requirements = __builtin__.property(_get_virtual_network_interface_requirements, _set_virtual_network_interface_requirements)
  cpd_id = __builtin__.property(_get_cpd_id, _set_cpd_id)
  layer_protocol = __builtin__.property(_get_layer_protocol, _set_layer_protocol)
  cp_role = __builtin__.property(_get_cp_role, _set_cp_role)
  description = __builtin__.property(_get_description, _set_description)
  address_data = __builtin__.property(_get_address_data, _set_address_data)


  _pyangbind_elements = OrderedDict([('id', id), ('virtual_network_interface_requirements', virtual_network_interface_requirements), ('cpd_id', cpd_id), ('layer_protocol', layer_protocol), ('cp_role', cp_role), ('description', description), ('address_data', address_data), ])


class yc_oauth2_info_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport_security_oauth2_info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-required/transport-dependencies/transport/security/oauth2-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about OAuth2 based security
  """
  __slots__ = ('_path_helper', '_extmethods', '__grant_types','__token_endpoint',)

  _yang_name = 'oauth2-info'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__grant_types = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__token_endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-required', 'transport-dependencies', 'transport', 'security', 'oauth2-info']

  def _get_grant_types(self):
    """
    Getter method for grant_types, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)

    YANG Description: Supported OAuth2 grant types
    """
    return self.__grant_types
      
  def _set_grant_types(self, v, load=False):
    """
    Setter method for grant_types, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grant_types is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grant_types() directly.

    YANG Description: Supported OAuth2 grant types
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grant_types must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__grant_types = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grant_types(self):
    self.__grant_types = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_token_endpoint(self):
    """
    Getter method for token_endpoint, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)

    YANG Description: The token endpoint
    """
    return self.__token_endpoint
      
  def _set_token_endpoint(self, v, load=False):
    """
    Setter method for token_endpoint, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_token_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_token_endpoint() directly.

    YANG Description: The token endpoint
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """token_endpoint must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
        })

    self.__token_endpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_token_endpoint(self):
    self.__token_endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

  grant_types = __builtin__.property(_get_grant_types, _set_grant_types)
  token_endpoint = __builtin__.property(_get_token_endpoint, _set_token_endpoint)


  _pyangbind_elements = OrderedDict([('grant_types', grant_types), ('token_endpoint', token_endpoint), ])


class yc_security_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport_security(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-required/transport-dependencies/transport/security. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the security used by the transport
  """
  __slots__ = ('_path_helper', '_extmethods', '__oauth2_info',)

  _yang_name = 'security'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oauth2_info = YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-required', 'transport-dependencies', 'transport', 'security']

  def _get_oauth2_info(self):
    """
    Getter method for oauth2_info, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/security/oauth2_info (container)

    YANG Description: Information about OAuth2 based security
    """
    return self.__oauth2_info
      
  def _set_oauth2_info(self, v, load=False):
    """
    Setter method for oauth2_info, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/security/oauth2_info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oauth2_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oauth2_info() directly.

    YANG Description: Information about OAuth2 based security
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oauth2_info must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__oauth2_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oauth2_info(self):
    self.__oauth2_info = YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  oauth2_info = __builtin__.property(_get_oauth2_info, _set_oauth2_info)


  _pyangbind_elements = OrderedDict([('oauth2_info', oauth2_info), ])


class yc_transport_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-required/transport-dependencies/transport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the transport in this transport binding
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__type','__protocol','__version','__security',)

  _yang_name = 'transport'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-required', 'transport-dependencies', 'transport']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/name (string)

    YANG Description: The name of this transport
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/description (string)

    YANG Description: Human-readable description of this transport
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human-readable description of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/type (transport-type)

    YANG Description: Type of the transport
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/type (transport-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with transport-type""",
          'defined-type': "mec-app-descriptor:transport-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/protocol (string)

    YANG Description: The name of the protocol used
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: The name of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/version (string)

    YANG Description: The version of the protocol used
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_security(self):
    """
    Getter method for security, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/security (container)

    YANG Description: Information about the security used by the transport
    """
    return self.__security
      
  def _set_security(self, v, load=False):
    """
    Setter method for security, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport/security (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security() directly.

    YANG Description: Information about the security used by the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_security_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security(self):
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  version = __builtin__.property(_get_version, _set_version)
  security = __builtin__.property(_get_security, _set_security)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('type', type), ('protocol', protocol), ('version', version), ('security', security), ])


class yc_transport_dependencies_mec_app_descriptor__app_descriptor_service_required_transport_dependencies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-required/transport-dependencies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__transport','__serializers','__labels',)

  _yang_name = 'transport-dependencies'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)
    self.__labels = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-required', 'transport-dependencies']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/id (string)

    YANG Description: Unique identifier for the transport dependency
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for the transport dependency
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport (container)

    YANG Description: Information about the transport in this transport binding
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Information about the transport in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transport_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_service_required_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_serializers(self):
    """
    Getter method for serializers, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/serializers (serializer-type)

    YANG Description: Type of serializers used in this transport binding
    """
    return self.__serializers
      
  def _set_serializers(self, v, load=False):
    """
    Setter method for serializers, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/serializers (serializer-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serializers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serializers() directly.

    YANG Description: Type of serializers used in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serializers must be of a type compatible with serializer-type""",
          'defined-type': "mec-app-descriptor:serializer-type",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)""",
        })

    self.__serializers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serializers(self):
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)


  def _get_labels(self):
    """
    Getter method for labels, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/labels (string)

    YANG Description: Set of labels that allow to define groups of transport bindings
    """
    return self.__labels
      
  def _set_labels(self, v, load=False):
    """
    Setter method for labels, mapped from YANG variable /app_descriptor/service_required/transport_dependencies/labels (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_labels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_labels() directly.

    YANG Description: Set of labels that allow to define groups of transport bindings
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """labels must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__labels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_labels(self):
    self.__labels = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  transport = __builtin__.property(_get_transport, _set_transport)
  serializers = __builtin__.property(_get_serializers, _set_serializers)
  labels = __builtin__.property(_get_labels, _set_labels)


  _pyangbind_elements = OrderedDict([('id', id), ('transport', transport), ('serializers', serializers), ('labels', labels), ])


class yc_category_mec_app_descriptor__app_descriptor_service_required_category(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-required/category. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A Category reference of the service
  """
  __slots__ = ('_path_helper', '_extmethods', '__href','__id','__name','__version',)

  _yang_name = 'category'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__href = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-required', 'category']

  def _get_href(self):
    """
    Getter method for href, mapped from YANG variable /app_descriptor/service_required/category/href (string)

    YANG Description: Reference of the catalogue
    """
    return self.__href
      
  def _set_href(self, v, load=False):
    """
    Setter method for href, mapped from YANG variable /app_descriptor/service_required/category/href (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_href is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_href() directly.

    YANG Description: Reference of the catalogue
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """href must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__href = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_href(self):
    self.__href = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/service_required/category/id (string)

    YANG Description: Unique identifier of the category
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/service_required/category/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/service_required/category/name (string)

    YANG Description: Name of the category
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/service_required/category/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/service_required/category/version (string)

    YANG Description: Category version
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/service_required/category/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Category version
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  href = __builtin__.property(_get_href, _set_href)
  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('href', href), ('id', id), ('name', name), ('version', version), ])


class yc_service_required_mec_app_descriptor__app_descriptor_service_required(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-required. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__transport_dependencies','__requested_permissions','__name','__category','__version',)

  _yang_name = 'service-required'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transport_dependencies = YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_service_required_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__requested_permissions = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requested-permissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__category = YANGDynClass(base=yc_category_mec_app_descriptor__app_descriptor_service_required_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-required']

  def _get_transport_dependencies(self):
    """
    Getter method for transport_dependencies, mapped from YANG variable /app_descriptor/service_required/transport_dependencies (list)

    YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
    """
    return self.__transport_dependencies
      
  def _set_transport_dependencies(self, v, load=False):
    """
    Setter method for transport_dependencies, mapped from YANG variable /app_descriptor/service_required/transport_dependencies (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport_dependencies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport_dependencies() directly.

    YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_service_required_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport_dependencies must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_service_required_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__transport_dependencies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport_dependencies(self):
    self.__transport_dependencies = YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_service_required_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_requested_permissions(self):
    """
    Getter method for requested_permissions, mapped from YANG variable /app_descriptor/service_required/requested_permissions (string)

    YANG Description: Requested permissions regarding the access of the application to the service. The format is left for the data model design stage.
    """
    return self.__requested_permissions
      
  def _set_requested_permissions(self, v, load=False):
    """
    Setter method for requested_permissions, mapped from YANG variable /app_descriptor/service_required/requested_permissions (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requested_permissions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requested_permissions() directly.

    YANG Description: Requested permissions regarding the access of the application to the service. The format is left for the data model design stage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requested-permissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """requested_permissions must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requested-permissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__requested_permissions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_requested_permissions(self):
    self.__requested_permissions = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requested-permissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/service_required/name (string)

    YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/service_required/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_category(self):
    """
    Getter method for category, mapped from YANG variable /app_descriptor/service_required/category (container)

    YANG Description: A Category reference of the service
    """
    return self.__category
      
  def _set_category(self, v, load=False):
    """
    Setter method for category, mapped from YANG variable /app_descriptor/service_required/category (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_category is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_category() directly.

    YANG Description: A Category reference of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_category_mec_app_descriptor__app_descriptor_service_required_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """category must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_category_mec_app_descriptor__app_descriptor_service_required_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__category = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_category(self):
    self.__category = YANGDynClass(base=yc_category_mec_app_descriptor__app_descriptor_service_required_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/service_required/version (string)

    YANG Description: The version of the service
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/service_required/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  transport_dependencies = __builtin__.property(_get_transport_dependencies, _set_transport_dependencies)
  requested_permissions = __builtin__.property(_get_requested_permissions, _set_requested_permissions)
  name = __builtin__.property(_get_name, _set_name)
  category = __builtin__.property(_get_category, _set_category)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('transport_dependencies', transport_dependencies), ('requested_permissions', requested_permissions), ('name', name), ('category', category), ('version', version), ])


class yc_oauth2_info_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport_security_oauth2_info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-optional/transport-dependencies/transport/security/oauth2-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about OAuth2 based security
  """
  __slots__ = ('_path_helper', '_extmethods', '__grant_types','__token_endpoint',)

  _yang_name = 'oauth2-info'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__grant_types = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__token_endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-optional', 'transport-dependencies', 'transport', 'security', 'oauth2-info']

  def _get_grant_types(self):
    """
    Getter method for grant_types, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)

    YANG Description: Supported OAuth2 grant types
    """
    return self.__grant_types
      
  def _set_grant_types(self, v, load=False):
    """
    Setter method for grant_types, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grant_types is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grant_types() directly.

    YANG Description: Supported OAuth2 grant types
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grant_types must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__grant_types = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grant_types(self):
    self.__grant_types = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_token_endpoint(self):
    """
    Getter method for token_endpoint, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)

    YANG Description: The token endpoint
    """
    return self.__token_endpoint
      
  def _set_token_endpoint(self, v, load=False):
    """
    Setter method for token_endpoint, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_token_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_token_endpoint() directly.

    YANG Description: The token endpoint
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """token_endpoint must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
        })

    self.__token_endpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_token_endpoint(self):
    self.__token_endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

  grant_types = __builtin__.property(_get_grant_types, _set_grant_types)
  token_endpoint = __builtin__.property(_get_token_endpoint, _set_token_endpoint)


  _pyangbind_elements = OrderedDict([('grant_types', grant_types), ('token_endpoint', token_endpoint), ])


class yc_security_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport_security(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-optional/transport-dependencies/transport/security. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the security used by the transport
  """
  __slots__ = ('_path_helper', '_extmethods', '__oauth2_info',)

  _yang_name = 'security'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oauth2_info = YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-optional', 'transport-dependencies', 'transport', 'security']

  def _get_oauth2_info(self):
    """
    Getter method for oauth2_info, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/security/oauth2_info (container)

    YANG Description: Information about OAuth2 based security
    """
    return self.__oauth2_info
      
  def _set_oauth2_info(self, v, load=False):
    """
    Setter method for oauth2_info, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/security/oauth2_info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oauth2_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oauth2_info() directly.

    YANG Description: Information about OAuth2 based security
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oauth2_info must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__oauth2_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oauth2_info(self):
    self.__oauth2_info = YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  oauth2_info = __builtin__.property(_get_oauth2_info, _set_oauth2_info)


  _pyangbind_elements = OrderedDict([('oauth2_info', oauth2_info), ])


class yc_transport_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-optional/transport-dependencies/transport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the transport in this transport binding
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__type','__protocol','__version','__security',)

  _yang_name = 'transport'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-optional', 'transport-dependencies', 'transport']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/name (string)

    YANG Description: The name of this transport
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/description (string)

    YANG Description: Human-readable description of this transport
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human-readable description of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/type (transport-type)

    YANG Description: Type of the transport
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/type (transport-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with transport-type""",
          'defined-type': "mec-app-descriptor:transport-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/protocol (string)

    YANG Description: The name of the protocol used
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: The name of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/version (string)

    YANG Description: The version of the protocol used
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_security(self):
    """
    Getter method for security, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/security (container)

    YANG Description: Information about the security used by the transport
    """
    return self.__security
      
  def _set_security(self, v, load=False):
    """
    Setter method for security, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport/security (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security() directly.

    YANG Description: Information about the security used by the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_security_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security(self):
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  version = __builtin__.property(_get_version, _set_version)
  security = __builtin__.property(_get_security, _set_security)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('type', type), ('protocol', protocol), ('version', version), ('security', security), ])


class yc_transport_dependencies_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-optional/transport-dependencies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__transport','__serializers','__labels',)

  _yang_name = 'transport-dependencies'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)
    self.__labels = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-optional', 'transport-dependencies']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/id (string)

    YANG Description: Unique identifier for the transport dependency
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for the transport dependency
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport (container)

    YANG Description: Information about the transport in this transport binding
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Information about the transport in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transport_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_serializers(self):
    """
    Getter method for serializers, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/serializers (serializer-type)

    YANG Description: Type of serializers used in this transport binding
    """
    return self.__serializers
      
  def _set_serializers(self, v, load=False):
    """
    Setter method for serializers, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/serializers (serializer-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serializers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serializers() directly.

    YANG Description: Type of serializers used in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serializers must be of a type compatible with serializer-type""",
          'defined-type': "mec-app-descriptor:serializer-type",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)""",
        })

    self.__serializers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serializers(self):
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)


  def _get_labels(self):
    """
    Getter method for labels, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/labels (string)

    YANG Description: Set of labels that allow to define groups of transport bindings
    """
    return self.__labels
      
  def _set_labels(self, v, load=False):
    """
    Setter method for labels, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies/labels (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_labels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_labels() directly.

    YANG Description: Set of labels that allow to define groups of transport bindings
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """labels must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__labels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_labels(self):
    self.__labels = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  transport = __builtin__.property(_get_transport, _set_transport)
  serializers = __builtin__.property(_get_serializers, _set_serializers)
  labels = __builtin__.property(_get_labels, _set_labels)


  _pyangbind_elements = OrderedDict([('id', id), ('transport', transport), ('serializers', serializers), ('labels', labels), ])


class yc_category_mec_app_descriptor__app_descriptor_service_optional_category(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-optional/category. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A Category reference of the service
  """
  __slots__ = ('_path_helper', '_extmethods', '__href','__id','__name','__version',)

  _yang_name = 'category'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__href = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-optional', 'category']

  def _get_href(self):
    """
    Getter method for href, mapped from YANG variable /app_descriptor/service_optional/category/href (string)

    YANG Description: Reference of the catalogue
    """
    return self.__href
      
  def _set_href(self, v, load=False):
    """
    Setter method for href, mapped from YANG variable /app_descriptor/service_optional/category/href (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_href is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_href() directly.

    YANG Description: Reference of the catalogue
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """href must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__href = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_href(self):
    self.__href = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/service_optional/category/id (string)

    YANG Description: Unique identifier of the category
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/service_optional/category/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/service_optional/category/name (string)

    YANG Description: Name of the category
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/service_optional/category/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/service_optional/category/version (string)

    YANG Description: Category version
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/service_optional/category/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Category version
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  href = __builtin__.property(_get_href, _set_href)
  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('href', href), ('id', id), ('name', name), ('version', version), ])


class yc_service_optional_mec_app_descriptor__app_descriptor_service_optional(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-optional. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__transport_dependencies','__requested_permissions','__name','__category','__version',)

  _yang_name = 'service-optional'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transport_dependencies = YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__requested_permissions = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requested-permissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__category = YANGDynClass(base=yc_category_mec_app_descriptor__app_descriptor_service_optional_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-optional']

  def _get_transport_dependencies(self):
    """
    Getter method for transport_dependencies, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies (list)

    YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
    """
    return self.__transport_dependencies
      
  def _set_transport_dependencies(self, v, load=False):
    """
    Setter method for transport_dependencies, mapped from YANG variable /app_descriptor/service_optional/transport_dependencies (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport_dependencies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport_dependencies() directly.

    YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport_dependencies must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__transport_dependencies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport_dependencies(self):
    self.__transport_dependencies = YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_service_optional_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_requested_permissions(self):
    """
    Getter method for requested_permissions, mapped from YANG variable /app_descriptor/service_optional/requested_permissions (string)

    YANG Description: Requested permissions regarding the access of the application to the service. The format is left for the data model design stage.
    """
    return self.__requested_permissions
      
  def _set_requested_permissions(self, v, load=False):
    """
    Setter method for requested_permissions, mapped from YANG variable /app_descriptor/service_optional/requested_permissions (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requested_permissions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requested_permissions() directly.

    YANG Description: Requested permissions regarding the access of the application to the service. The format is left for the data model design stage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requested-permissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """requested_permissions must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requested-permissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__requested_permissions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_requested_permissions(self):
    self.__requested_permissions = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requested-permissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/service_optional/name (string)

    YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/service_optional/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_category(self):
    """
    Getter method for category, mapped from YANG variable /app_descriptor/service_optional/category (container)

    YANG Description: A Category reference of the service
    """
    return self.__category
      
  def _set_category(self, v, load=False):
    """
    Setter method for category, mapped from YANG variable /app_descriptor/service_optional/category (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_category is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_category() directly.

    YANG Description: A Category reference of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_category_mec_app_descriptor__app_descriptor_service_optional_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """category must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_category_mec_app_descriptor__app_descriptor_service_optional_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__category = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_category(self):
    self.__category = YANGDynClass(base=yc_category_mec_app_descriptor__app_descriptor_service_optional_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/service_optional/version (string)

    YANG Description: The version of the service
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/service_optional/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  transport_dependencies = __builtin__.property(_get_transport_dependencies, _set_transport_dependencies)
  requested_permissions = __builtin__.property(_get_requested_permissions, _set_requested_permissions)
  name = __builtin__.property(_get_name, _set_name)
  category = __builtin__.property(_get_category, _set_category)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('transport_dependencies', transport_dependencies), ('requested_permissions', requested_permissions), ('name', name), ('category', category), ('version', version), ])


class yc_oauth2_info_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport_security_oauth2_info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-produced/transports-supported/transport/security/oauth2-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about OAuth2 based security
  """
  __slots__ = ('_path_helper', '_extmethods', '__grant_types','__token_endpoint',)

  _yang_name = 'oauth2-info'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__grant_types = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__token_endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-produced', 'transports-supported', 'transport', 'security', 'oauth2-info']

  def _get_grant_types(self):
    """
    Getter method for grant_types, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/security/oauth2_info/grant_types (enumeration)

    YANG Description: Supported OAuth2 grant types
    """
    return self.__grant_types
      
  def _set_grant_types(self, v, load=False):
    """
    Setter method for grant_types, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/security/oauth2_info/grant_types (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grant_types is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grant_types() directly.

    YANG Description: Supported OAuth2 grant types
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grant_types must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__grant_types = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grant_types(self):
    self.__grant_types = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_token_endpoint(self):
    """
    Getter method for token_endpoint, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/security/oauth2_info/token_endpoint (inet:uri)

    YANG Description: The token endpoint
    """
    return self.__token_endpoint
      
  def _set_token_endpoint(self, v, load=False):
    """
    Setter method for token_endpoint, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/security/oauth2_info/token_endpoint (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_token_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_token_endpoint() directly.

    YANG Description: The token endpoint
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """token_endpoint must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
        })

    self.__token_endpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_token_endpoint(self):
    self.__token_endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

  grant_types = __builtin__.property(_get_grant_types, _set_grant_types)
  token_endpoint = __builtin__.property(_get_token_endpoint, _set_token_endpoint)


  _pyangbind_elements = OrderedDict([('grant_types', grant_types), ('token_endpoint', token_endpoint), ])


class yc_security_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport_security(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-produced/transports-supported/transport/security. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the security used by the transport
  """
  __slots__ = ('_path_helper', '_extmethods', '__oauth2_info',)

  _yang_name = 'security'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oauth2_info = YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-produced', 'transports-supported', 'transport', 'security']

  def _get_oauth2_info(self):
    """
    Getter method for oauth2_info, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/security/oauth2_info (container)

    YANG Description: Information about OAuth2 based security
    """
    return self.__oauth2_info
      
  def _set_oauth2_info(self, v, load=False):
    """
    Setter method for oauth2_info, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/security/oauth2_info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oauth2_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oauth2_info() directly.

    YANG Description: Information about OAuth2 based security
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oauth2_info must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__oauth2_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oauth2_info(self):
    self.__oauth2_info = YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  oauth2_info = __builtin__.property(_get_oauth2_info, _set_oauth2_info)


  _pyangbind_elements = OrderedDict([('oauth2_info', oauth2_info), ])


class yc_transport_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-produced/transports-supported/transport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the transport in this transport binding
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__type','__protocol','__version','__security',)

  _yang_name = 'transport'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-produced', 'transports-supported', 'transport']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/name (string)

    YANG Description: The name of this transport
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/description (string)

    YANG Description: Human-readable description of this transport
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human-readable description of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/type (transport-type)

    YANG Description: Type of the transport
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/type (transport-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with transport-type""",
          'defined-type': "mec-app-descriptor:transport-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/protocol (string)

    YANG Description: The name of the protocol used
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: The name of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/version (string)

    YANG Description: The version of the protocol used
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_security(self):
    """
    Getter method for security, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/security (container)

    YANG Description: Information about the security used by the transport
    """
    return self.__security
      
  def _set_security(self, v, load=False):
    """
    Setter method for security, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport/security (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security() directly.

    YANG Description: Information about the security used by the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_security_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security(self):
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  version = __builtin__.property(_get_version, _set_version)
  security = __builtin__.property(_get_security, _set_security)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('type', type), ('protocol', protocol), ('version', version), ('security', security), ])


class yc_transports_supported_mec_app_descriptor__app_descriptor_service_produced_transports_supported(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-produced/transports-supported. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Transports and serializers supported by the service
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__transport','__serializers',)

  _yang_name = 'transports-supported'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='td:serializer-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-produced', 'transports-supported']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/service_produced/transports_supported/id (string)

    YANG Description: Unique identifier for the transport binding
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/service_produced/transports_supported/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for the transport binding
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport (container)

    YANG Description: Information about the transport in this transport binding
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /app_descriptor/service_produced/transports_supported/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Information about the transport in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transport_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_service_produced_transports_supported_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_serializers(self):
    """
    Getter method for serializers, mapped from YANG variable /app_descriptor/service_produced/transports_supported/serializers (td:serializer-type)

    YANG Description: Type of serializers used in this transport binding
    """
    return self.__serializers
      
  def _set_serializers(self, v, load=False):
    """
    Setter method for serializers, mapped from YANG variable /app_descriptor/service_produced/transports_supported/serializers (td:serializer-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serializers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serializers() directly.

    YANG Description: Type of serializers used in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='td:serializer-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serializers must be of a type compatible with td:serializer-type""",
          'defined-type': "td:serializer-type",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='td:serializer-type', is_config=True)""",
        })

    self.__serializers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serializers(self):
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='td:serializer-type', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  transport = __builtin__.property(_get_transport, _set_transport)
  serializers = __builtin__.property(_get_serializers, _set_serializers)


  _pyangbind_elements = OrderedDict([('id', id), ('transport', transport), ('serializers', serializers), ])


class yc_category_mec_app_descriptor__app_descriptor_service_produced_category(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-produced/category. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A Category reference of the service
  """
  __slots__ = ('_path_helper', '_extmethods', '__href','__id','__name','__version',)

  _yang_name = 'category'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__href = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-produced', 'category']

  def _get_href(self):
    """
    Getter method for href, mapped from YANG variable /app_descriptor/service_produced/category/href (string)

    YANG Description: Reference of the catalogue
    """
    return self.__href
      
  def _set_href(self, v, load=False):
    """
    Setter method for href, mapped from YANG variable /app_descriptor/service_produced/category/href (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_href is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_href() directly.

    YANG Description: Reference of the catalogue
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """href must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__href = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_href(self):
    self.__href = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/service_produced/category/id (string)

    YANG Description: Unique identifier of the category
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/service_produced/category/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/service_produced/category/name (string)

    YANG Description: Name of the category
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/service_produced/category/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/service_produced/category/version (string)

    YANG Description: Category version
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/service_produced/category/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Category version
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  href = __builtin__.property(_get_href, _set_href)
  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('href', href), ('id', id), ('name', name), ('version', version), ])


class yc_service_produced_mec_app_descriptor__app_descriptor_service_produced(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/service-produced. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__transports_supported','__name','__category','__version',)

  _yang_name = 'service-produced'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transports_supported = YANGDynClass(base=YANGListType("id",yc_transports_supported_mec_app_descriptor__app_descriptor_service_produced_transports_supported, yang_name="transports-supported", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transports-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__category = YANGDynClass(base=yc_category_mec_app_descriptor__app_descriptor_service_produced_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'service-produced']

  def _get_transports_supported(self):
    """
    Getter method for transports_supported, mapped from YANG variable /app_descriptor/service_produced/transports_supported (list)

    YANG Description: Transports and serializers supported by the service
    """
    return self.__transports_supported
      
  def _set_transports_supported(self, v, load=False):
    """
    Setter method for transports_supported, mapped from YANG variable /app_descriptor/service_produced/transports_supported (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transports_supported is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transports_supported() directly.

    YANG Description: Transports and serializers supported by the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_transports_supported_mec_app_descriptor__app_descriptor_service_produced_transports_supported, yang_name="transports-supported", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transports-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transports_supported must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_transports_supported_mec_app_descriptor__app_descriptor_service_produced_transports_supported, yang_name="transports-supported", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transports-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__transports_supported = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transports_supported(self):
    self.__transports_supported = YANGDynClass(base=YANGListType("id",yc_transports_supported_mec_app_descriptor__app_descriptor_service_produced_transports_supported, yang_name="transports-supported", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transports-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/service_produced/name (string)

    YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/service_produced/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_category(self):
    """
    Getter method for category, mapped from YANG variable /app_descriptor/service_produced/category (container)

    YANG Description: A Category reference of the service
    """
    return self.__category
      
  def _set_category(self, v, load=False):
    """
    Setter method for category, mapped from YANG variable /app_descriptor/service_produced/category (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_category is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_category() directly.

    YANG Description: A Category reference of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_category_mec_app_descriptor__app_descriptor_service_produced_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """category must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_category_mec_app_descriptor__app_descriptor_service_produced_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__category = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_category(self):
    self.__category = YANGDynClass(base=yc_category_mec_app_descriptor__app_descriptor_service_produced_category, is_container='container', yang_name="category", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/service_produced/version (string)

    YANG Description: The version of the service
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/service_produced/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  transports_supported = __builtin__.property(_get_transports_supported, _set_transports_supported)
  name = __builtin__.property(_get_name, _set_name)
  category = __builtin__.property(_get_category, _set_category)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('transports_supported', transports_supported), ('name', name), ('category', category), ('version', version), ])


class yc_feature_required_mec_app_descriptor__app_descriptor_feature_required(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/feature-required. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__version',)

  _yang_name = 'feature-required'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'feature-required']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/feature_required/name (string)

    YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/feature_required/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/feature_required/version (string)

    YANG Description: The version of the feature.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/feature_required/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('name', name), ('version', version), ])


class yc_feature_optional_mec_app_descriptor__app_descriptor_feature_optional(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/feature-optional. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__version',)

  _yang_name = 'feature-optional'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'feature-optional']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/feature_optional/name (string)

    YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/feature_optional/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/feature_optional/version (string)

    YANG Description: The version of the feature.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/feature_optional/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('name', name), ('version', version), ])


class yc_oauth2_info_mec_app_descriptor__app_descriptor_transport_dependencies_transport_security_oauth2_info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/transport-dependencies/transport/security/oauth2-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about OAuth2 based security
  """
  __slots__ = ('_path_helper', '_extmethods', '__grant_types','__token_endpoint',)

  _yang_name = 'oauth2-info'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__grant_types = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__token_endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'transport-dependencies', 'transport', 'security', 'oauth2-info']

  def _get_grant_types(self):
    """
    Getter method for grant_types, mapped from YANG variable /app_descriptor/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)

    YANG Description: Supported OAuth2 grant types
    """
    return self.__grant_types
      
  def _set_grant_types(self, v, load=False):
    """
    Setter method for grant_types, mapped from YANG variable /app_descriptor/transport_dependencies/transport/security/oauth2_info/grant_types (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grant_types is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grant_types() directly.

    YANG Description: Supported OAuth2 grant types
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grant_types must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__grant_types = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grant_types(self):
    self.__grant_types = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grant-types", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_token_endpoint(self):
    """
    Getter method for token_endpoint, mapped from YANG variable /app_descriptor/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)

    YANG Description: The token endpoint
    """
    return self.__token_endpoint
      
  def _set_token_endpoint(self, v, load=False):
    """
    Setter method for token_endpoint, mapped from YANG variable /app_descriptor/transport_dependencies/transport/security/oauth2_info/token_endpoint (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_token_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_token_endpoint() directly.

    YANG Description: The token endpoint
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """token_endpoint must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
        })

    self.__token_endpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_token_endpoint(self):
    self.__token_endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="token-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

  grant_types = __builtin__.property(_get_grant_types, _set_grant_types)
  token_endpoint = __builtin__.property(_get_token_endpoint, _set_token_endpoint)


  _pyangbind_elements = OrderedDict([('grant_types', grant_types), ('token_endpoint', token_endpoint), ])


class yc_security_mec_app_descriptor__app_descriptor_transport_dependencies_transport_security(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/transport-dependencies/transport/security. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the security used by the transport
  """
  __slots__ = ('_path_helper', '_extmethods', '__oauth2_info',)

  _yang_name = 'security'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oauth2_info = YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'transport-dependencies', 'transport', 'security']

  def _get_oauth2_info(self):
    """
    Getter method for oauth2_info, mapped from YANG variable /app_descriptor/transport_dependencies/transport/security/oauth2_info (container)

    YANG Description: Information about OAuth2 based security
    """
    return self.__oauth2_info
      
  def _set_oauth2_info(self, v, load=False):
    """
    Setter method for oauth2_info, mapped from YANG variable /app_descriptor/transport_dependencies/transport/security/oauth2_info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oauth2_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oauth2_info() directly.

    YANG Description: Information about OAuth2 based security
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oauth2_info_mec_app_descriptor__app_descriptor_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oauth2_info must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__oauth2_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oauth2_info(self):
    self.__oauth2_info = YANGDynClass(base=yc_oauth2_info_mec_app_descriptor__app_descriptor_transport_dependencies_transport_security_oauth2_info, is_container='container', yang_name="oauth2-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  oauth2_info = __builtin__.property(_get_oauth2_info, _set_oauth2_info)


  _pyangbind_elements = OrderedDict([('oauth2_info', oauth2_info), ])


class yc_transport_mec_app_descriptor__app_descriptor_transport_dependencies_transport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/transport-dependencies/transport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the transport in this transport binding
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__type','__protocol','__version','__security',)

  _yang_name = 'transport'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'transport-dependencies', 'transport']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/transport_dependencies/transport/name (string)

    YANG Description: The name of this transport
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/transport_dependencies/transport/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/transport_dependencies/transport/description (string)

    YANG Description: Human-readable description of this transport
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/transport_dependencies/transport/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human-readable description of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /app_descriptor/transport_dependencies/transport/type (transport-type)

    YANG Description: Type of the transport
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /app_descriptor/transport_dependencies/transport/type (transport-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with transport-type""",
          'defined-type': "mec-app-descriptor:transport-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='transport-type', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /app_descriptor/transport_dependencies/transport/protocol (string)

    YANG Description: The name of the protocol used
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /app_descriptor/transport_dependencies/transport/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: The name of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/transport_dependencies/transport/version (string)

    YANG Description: The version of the protocol used
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/transport_dependencies/transport/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_security(self):
    """
    Getter method for security, mapped from YANG variable /app_descriptor/transport_dependencies/transport/security (container)

    YANG Description: Information about the security used by the transport
    """
    return self.__security
      
  def _set_security(self, v, load=False):
    """
    Setter method for security, mapped from YANG variable /app_descriptor/transport_dependencies/transport/security (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security() directly.

    YANG Description: Information about the security used by the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_security_mec_app_descriptor__app_descriptor_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security(self):
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_transport_dependencies_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  version = __builtin__.property(_get_version, _set_version)
  security = __builtin__.property(_get_security, _set_security)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('type', type), ('protocol', protocol), ('version', version), ('security', security), ])


class yc_transport_dependencies_mec_app_descriptor__app_descriptor_transport_dependencies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/transport-dependencies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__transport','__serializers','__labels',)

  _yang_name = 'transport-dependencies'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)
    self.__labels = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'transport-dependencies']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/transport_dependencies/id (string)

    YANG Description: Unique identifier for the transport dependency
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/transport_dependencies/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for the transport dependency
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /app_descriptor/transport_dependencies/transport (container)

    YANG Description: Information about the transport in this transport binding
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /app_descriptor/transport_dependencies/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Information about the transport in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transport_mec_app_descriptor__app_descriptor_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_transport_dependencies_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_serializers(self):
    """
    Getter method for serializers, mapped from YANG variable /app_descriptor/transport_dependencies/serializers (serializer-type)

    YANG Description: Type of serializers used in this transport binding
    """
    return self.__serializers
      
  def _set_serializers(self, v, load=False):
    """
    Setter method for serializers, mapped from YANG variable /app_descriptor/transport_dependencies/serializers (serializer-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serializers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serializers() directly.

    YANG Description: Type of serializers used in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serializers must be of a type compatible with serializer-type""",
          'defined-type': "mec-app-descriptor:serializer-type",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)""",
        })

    self.__serializers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serializers(self):
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {'value': 0}, 'XML': {'value': 1}, 'PROTOBUF3': {'value': 2}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='serializer-type', is_config=True)


  def _get_labels(self):
    """
    Getter method for labels, mapped from YANG variable /app_descriptor/transport_dependencies/labels (string)

    YANG Description: Set of labels that allow to define groups of transport bindings
    """
    return self.__labels
      
  def _set_labels(self, v, load=False):
    """
    Setter method for labels, mapped from YANG variable /app_descriptor/transport_dependencies/labels (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_labels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_labels() directly.

    YANG Description: Set of labels that allow to define groups of transport bindings
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """labels must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__labels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_labels(self):
    self.__labels = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  transport = __builtin__.property(_get_transport, _set_transport)
  serializers = __builtin__.property(_get_serializers, _set_serializers)
  labels = __builtin__.property(_get_labels, _set_labels)


  _pyangbind_elements = OrderedDict([('id', id), ('transport', transport), ('serializers', serializers), ('labels', labels), ])


class yc_traffic_filter_mec_app_descriptor__app_descriptor_traffic_rule_traffic_filter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/traffic-rule/traffic-filter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Filter to identify specific flow/packets
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__src_address','__dst_address','__src_port','__dst_port','__protocol','__tag','__uri','__packet_label','__src_tunnel_address','__tgt_tunnel_address','__src_tunnel_port','__dst_tunnel_port','__qci','__dscp','__tc',)

  _yang_name = 'traffic-filter'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__src_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="src-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    self.__dst_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="dst-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    self.__src_port = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    self.__dst_port = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    self.__protocol = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__tag = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__uri = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__packet_label = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="packet-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__src_tunnel_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="src-tunnel-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    self.__tgt_tunnel_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="tgt-tunnel-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    self.__src_tunnel_port = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="src-tunnel-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    self.__dst_tunnel_port = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dst-tunnel-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    self.__qci = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="qci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    self.__dscp = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    self.__tc = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'traffic-rule', 'traffic-filter']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/id (string)

    YANG Description: Unique identifier for the traffic filter
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for the traffic filter
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_src_address(self):
    """
    Getter method for src_address, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/src_address (inet:ip-address)

    YANG Description: An IP address or a range of IP addresses
    """
    return self.__src_address
      
  def _set_src_address(self, v, load=False):
    """
    Setter method for src_address, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/src_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_address() directly.

    YANG Description: An IP address or a range of IP addresses
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="src-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="src-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__src_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_address(self):
    self.__src_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="src-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)


  def _get_dst_address(self):
    """
    Getter method for dst_address, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/dst_address (inet:ip-address)

    YANG Description: An IP address or a range of IP addresses
    """
    return self.__dst_address
      
  def _set_dst_address(self, v, load=False):
    """
    Setter method for dst_address, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/dst_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_address() directly.

    YANG Description: An IP address or a range of IP addresses
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="dst-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="dst-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__dst_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_address(self):
    self.__dst_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="dst-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)


  def _get_src_port(self):
    """
    Getter method for src_port, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/src_port (inet:port-number)

    YANG Description: A port or a range of ports
    """
    return self.__src_port
      
  def _set_src_port(self, v, load=False):
    """
    Setter method for src_port, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/src_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_port() directly.

    YANG Description: A port or a range of ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
        })

    self.__src_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_port(self):
    self.__src_port = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)


  def _get_dst_port(self):
    """
    Getter method for dst_port, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/dst_port (inet:port-number)

    YANG Description: A port or a range of ports
    """
    return self.__dst_port
      
  def _set_dst_port(self, v, load=False):
    """
    Setter method for dst_port, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/dst_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_port() directly.

    YANG Description: A port or a range of ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
        })

    self.__dst_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_port(self):
    self.__dst_port = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/protocol (string)

    YANG Description: Specify the protocol of the traffic filter
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Specify the protocol of the traffic filter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/tag (string)

    YANG Description: Used for tag based traffic rule
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Used for tag based traffic rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_uri(self):
    """
    Getter method for uri, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/uri (string)

    YANG Description: An URI label used to filter the traffic
    """
    return self.__uri
      
  def _set_uri(self, v, load=False):
    """
    Setter method for uri, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/uri (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uri is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uri() directly.

    YANG Description: An URI label used to filter the traffic
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uri must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__uri = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uri(self):
    self.__uri = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_packet_label(self):
    """
    Getter method for packet_label, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/packet_label (string)

    YANG Description: A customized packet label used to filter traffic
    """
    return self.__packet_label
      
  def _set_packet_label(self, v, load=False):
    """
    Setter method for packet_label, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/packet_label (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_label() directly.

    YANG Description: A customized packet label used to filter traffic
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="packet-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_label must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="packet-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__packet_label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_label(self):
    self.__packet_label = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="packet-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_src_tunnel_address(self):
    """
    Getter method for src_tunnel_address, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/src_tunnel_address (inet:ip-address)

    YANG Description: Used for GTP tunnel based traffic rule
    """
    return self.__src_tunnel_address
      
  def _set_src_tunnel_address(self, v, load=False):
    """
    Setter method for src_tunnel_address, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/src_tunnel_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_tunnel_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_tunnel_address() directly.

    YANG Description: Used for GTP tunnel based traffic rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="src-tunnel-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_tunnel_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="src-tunnel-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__src_tunnel_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_tunnel_address(self):
    self.__src_tunnel_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="src-tunnel-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)


  def _get_tgt_tunnel_address(self):
    """
    Getter method for tgt_tunnel_address, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/tgt_tunnel_address (inet:ip-address)

    YANG Description: Used for GTP tunnel based traffic rule
    """
    return self.__tgt_tunnel_address
      
  def _set_tgt_tunnel_address(self, v, load=False):
    """
    Setter method for tgt_tunnel_address, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/tgt_tunnel_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tgt_tunnel_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tgt_tunnel_address() directly.

    YANG Description: Used for GTP tunnel based traffic rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="tgt-tunnel-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tgt_tunnel_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="tgt-tunnel-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__tgt_tunnel_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tgt_tunnel_address(self):
    self.__tgt_tunnel_address = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="tgt-tunnel-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)


  def _get_src_tunnel_port(self):
    """
    Getter method for src_tunnel_port, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/src_tunnel_port (inet:port-number)

    YANG Description: Used for GTP tunnel based traffic rule
    """
    return self.__src_tunnel_port
      
  def _set_src_tunnel_port(self, v, load=False):
    """
    Setter method for src_tunnel_port, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/src_tunnel_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_tunnel_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_tunnel_port() directly.

    YANG Description: Used for GTP tunnel based traffic rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="src-tunnel-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_tunnel_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="src-tunnel-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
        })

    self.__src_tunnel_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_tunnel_port(self):
    self.__src_tunnel_port = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="src-tunnel-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)


  def _get_dst_tunnel_port(self):
    """
    Getter method for dst_tunnel_port, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/dst_tunnel_port (inet:port-number)

    YANG Description: Used for GTP tunnel based traffic rule
    """
    return self.__dst_tunnel_port
      
  def _set_dst_tunnel_port(self, v, load=False):
    """
    Setter method for dst_tunnel_port, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/dst_tunnel_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_tunnel_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_tunnel_port() directly.

    YANG Description: Used for GTP tunnel based traffic rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dst-tunnel-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_tunnel_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dst-tunnel-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
        })

    self.__dst_tunnel_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_tunnel_port(self):
    self.__dst_tunnel_port = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dst-tunnel-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)


  def _get_qci(self):
    """
    Getter method for qci, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/qci (uint8)

    YANG Description: Used to match all packets that have the same QCI
    """
    return self.__qci
      
  def _set_qci(self, v, load=False):
    """
    Setter method for qci, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/qci (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qci is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qci() directly.

    YANG Description: Used to match all packets that have the same QCI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="qci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qci must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="qci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
        })

    self.__qci = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qci(self):
    self.__qci = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="qci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)


  def _get_dscp(self):
    """
    Getter method for dscp, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/dscp (uint8)

    YANG Description: Used to match all IPv4 packets with same DSCP
    """
    return self.__dscp
      
  def _set_dscp(self, v, load=False):
    """
    Setter method for dscp, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/dscp (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dscp() directly.

    YANG Description: Used to match all IPv4 packets with same DSCP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dscp must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
        })

    self.__dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dscp(self):
    self.__dscp = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)


  def _get_tc(self):
    """
    Getter method for tc, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/tc (uint8)

    YANG Description: Used to match all IPv6 packets with same TC
    """
    return self.__tc
      
  def _set_tc(self, v, load=False):
    """
    Setter method for tc, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter/tc (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tc() directly.

    YANG Description: Used to match all IPv6 packets with same TC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tc must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
        })

    self.__tc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tc(self):
    self.__tc = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  src_address = __builtin__.property(_get_src_address, _set_src_address)
  dst_address = __builtin__.property(_get_dst_address, _set_dst_address)
  src_port = __builtin__.property(_get_src_port, _set_src_port)
  dst_port = __builtin__.property(_get_dst_port, _set_dst_port)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  tag = __builtin__.property(_get_tag, _set_tag)
  uri = __builtin__.property(_get_uri, _set_uri)
  packet_label = __builtin__.property(_get_packet_label, _set_packet_label)
  src_tunnel_address = __builtin__.property(_get_src_tunnel_address, _set_src_tunnel_address)
  tgt_tunnel_address = __builtin__.property(_get_tgt_tunnel_address, _set_tgt_tunnel_address)
  src_tunnel_port = __builtin__.property(_get_src_tunnel_port, _set_src_tunnel_port)
  dst_tunnel_port = __builtin__.property(_get_dst_tunnel_port, _set_dst_tunnel_port)
  qci = __builtin__.property(_get_qci, _set_qci)
  dscp = __builtin__.property(_get_dscp, _set_dscp)
  tc = __builtin__.property(_get_tc, _set_tc)


  _pyangbind_elements = OrderedDict([('id', id), ('src_address', src_address), ('dst_address', dst_address), ('src_port', src_port), ('dst_port', dst_port), ('protocol', protocol), ('tag', tag), ('uri', uri), ('packet_label', packet_label), ('src_tunnel_address', src_tunnel_address), ('tgt_tunnel_address', tgt_tunnel_address), ('src_tunnel_port', src_tunnel_port), ('dst_tunnel_port', dst_tunnel_port), ('qci', qci), ('dscp', dscp), ('tc', tc), ])


class yc_tunnel_info_mec_app_descriptor__app_descriptor_traffic_rule_dst_interface_tunnel_info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/traffic-rule/dst-interface/tunnel-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Included only if interfaceType is TUNNEL
  """
  __slots__ = ('_path_helper', '_extmethods', '__tunnel_type','__tunnel_dst_address','__tunnel_src_address',)

  _yang_name = 'tunnel-info'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tunnel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GTP-U': {}, 'GRE': {}},), is_leaf=True, yang_name="tunnel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__tunnel_dst_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnel-dst-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    self.__tunnel_src_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnel-src-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'traffic-rule', 'dst-interface', 'tunnel-info']

  def _get_tunnel_type(self):
    """
    Getter method for tunnel_type, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/tunnel_info/tunnel_type (enumeration)

    YANG Description: Type of tunnel: GTP-U, GRE, etc
    """
    return self.__tunnel_type
      
  def _set_tunnel_type(self, v, load=False):
    """
    Setter method for tunnel_type, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/tunnel_info/tunnel_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_type() directly.

    YANG Description: Type of tunnel: GTP-U, GRE, etc
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GTP-U': {}, 'GRE': {}},), is_leaf=True, yang_name="tunnel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_type must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GTP-U': {}, 'GRE': {}},), is_leaf=True, yang_name="tunnel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__tunnel_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_type(self):
    self.__tunnel_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GTP-U': {}, 'GRE': {}},), is_leaf=True, yang_name="tunnel-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_tunnel_dst_address(self):
    """
    Getter method for tunnel_dst_address, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/tunnel_info/tunnel_dst_address (inet:ip-address)

    YANG Description: Destination address of the tunnel
    """
    return self.__tunnel_dst_address
      
  def _set_tunnel_dst_address(self, v, load=False):
    """
    Setter method for tunnel_dst_address, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/tunnel_info/tunnel_dst_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_dst_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_dst_address() directly.

    YANG Description: Destination address of the tunnel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnel-dst-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_dst_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnel-dst-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__tunnel_dst_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_dst_address(self):
    self.__tunnel_dst_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnel-dst-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)


  def _get_tunnel_src_address(self):
    """
    Getter method for tunnel_src_address, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/tunnel_info/tunnel_src_address (inet:ip-address)

    YANG Description: Source address of the tunnel
    """
    return self.__tunnel_src_address
      
  def _set_tunnel_src_address(self, v, load=False):
    """
    Setter method for tunnel_src_address, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/tunnel_info/tunnel_src_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_src_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_src_address() directly.

    YANG Description: Source address of the tunnel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnel-src-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_src_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnel-src-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__tunnel_src_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_src_address(self):
    self.__tunnel_src_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnel-src-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

  tunnel_type = __builtin__.property(_get_tunnel_type, _set_tunnel_type)
  tunnel_dst_address = __builtin__.property(_get_tunnel_dst_address, _set_tunnel_dst_address)
  tunnel_src_address = __builtin__.property(_get_tunnel_src_address, _set_tunnel_src_address)


  _pyangbind_elements = OrderedDict([('tunnel_type', tunnel_type), ('tunnel_dst_address', tunnel_dst_address), ('tunnel_src_address', tunnel_src_address), ])


class yc_dst_interface_mec_app_descriptor__app_descriptor_traffic_rule_dst_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/traffic-rule/dst-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Destination interface if action is FORWARD
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__interface_type','__tunnel_info','__src_mac_address','__dst_mac_address','__dst_ip_address',)

  _yang_name = 'dst-interface'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__interface_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'TUNNEL': {}, 'MAC': {}, 'IP': {}},), is_leaf=True, yang_name="interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__tunnel_info = YANGDynClass(base=yc_tunnel_info_mec_app_descriptor__app_descriptor_traffic_rule_dst_interface_tunnel_info, is_container='container', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__src_mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="src-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    self.__dst_mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="dst-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    self.__dst_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="dst-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'traffic-rule', 'dst-interface']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/id (string)

    YANG Description: Unique identifier for the interface
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for the interface
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_interface_type(self):
    """
    Getter method for interface_type, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/interface_type (enumeration)

    YANG Description: Type of interface: TUNNEL, MAC, IP, etc
    """
    return self.__interface_type
      
  def _set_interface_type(self, v, load=False):
    """
    Setter method for interface_type, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/interface_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_type() directly.

    YANG Description: Type of interface: TUNNEL, MAC, IP, etc
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'TUNNEL': {}, 'MAC': {}, 'IP': {}},), is_leaf=True, yang_name="interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface_type must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'TUNNEL': {}, 'MAC': {}, 'IP': {}},), is_leaf=True, yang_name="interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__interface_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface_type(self):
    self.__interface_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'TUNNEL': {}, 'MAC': {}, 'IP': {}},), is_leaf=True, yang_name="interface-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_tunnel_info(self):
    """
    Getter method for tunnel_info, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/tunnel_info (container)

    YANG Description: Included only if interfaceType is TUNNEL
    """
    return self.__tunnel_info
      
  def _set_tunnel_info(self, v, load=False):
    """
    Setter method for tunnel_info, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/tunnel_info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_info() directly.

    YANG Description: Included only if interfaceType is TUNNEL
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tunnel_info_mec_app_descriptor__app_descriptor_traffic_rule_dst_interface_tunnel_info, is_container='container', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_info must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tunnel_info_mec_app_descriptor__app_descriptor_traffic_rule_dst_interface_tunnel_info, is_container='container', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__tunnel_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_info(self):
    self.__tunnel_info = YANGDynClass(base=yc_tunnel_info_mec_app_descriptor__app_descriptor_traffic_rule_dst_interface_tunnel_info, is_container='container', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_src_mac_address(self):
    """
    Getter method for src_mac_address, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/src_mac_address (yang:mac-address)

    YANG Description: Source MAC address if interfaceType is MAC
    """
    return self.__src_mac_address
      
  def _set_src_mac_address(self, v, load=False):
    """
    Setter method for src_mac_address, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/src_mac_address (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_mac_address() directly.

    YANG Description: Source MAC address if interfaceType is MAC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="src-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_mac_address must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="src-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__src_mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_mac_address(self):
    self.__src_mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="src-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)


  def _get_dst_mac_address(self):
    """
    Getter method for dst_mac_address, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/dst_mac_address (yang:mac-address)

    YANG Description: Destination MAC address if interfaceType is MAC
    """
    return self.__dst_mac_address
      
  def _set_dst_mac_address(self, v, load=False):
    """
    Setter method for dst_mac_address, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/dst_mac_address (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_mac_address() directly.

    YANG Description: Destination MAC address if interfaceType is MAC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="dst-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_mac_address must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="dst-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__dst_mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_mac_address(self):
    self.__dst_mac_address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="dst-mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)


  def _get_dst_ip_address(self):
    """
    Getter method for dst_ip_address, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/dst_ip_address (inet:ip-address)

    YANG Description: Destination IP address if interfaceType is IP
    """
    return self.__dst_ip_address
      
  def _set_dst_ip_address(self, v, load=False):
    """
    Setter method for dst_ip_address, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface/dst_ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_ip_address() directly.

    YANG Description: Destination IP address if interfaceType is IP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="dst-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_ip_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="dst-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__dst_ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_ip_address(self):
    self.__dst_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="dst-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  interface_type = __builtin__.property(_get_interface_type, _set_interface_type)
  tunnel_info = __builtin__.property(_get_tunnel_info, _set_tunnel_info)
  src_mac_address = __builtin__.property(_get_src_mac_address, _set_src_mac_address)
  dst_mac_address = __builtin__.property(_get_dst_mac_address, _set_dst_mac_address)
  dst_ip_address = __builtin__.property(_get_dst_ip_address, _set_dst_ip_address)


  _pyangbind_elements = OrderedDict([('id', id), ('interface_type', interface_type), ('tunnel_info', tunnel_info), ('src_mac_address', src_mac_address), ('dst_mac_address', dst_mac_address), ('dst_ip_address', dst_ip_address), ])


class yc_traffic_rule_mec_app_descriptor__app_descriptor_traffic_rule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/traffic-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__filter_type','__priority','__action','__traffic_filter','__dst_interface',)

  _yang_name = 'traffic-rule'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__filter_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FLOW': {}, 'PACKET': {}},), is_leaf=True, yang_name="filter-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DROP': {}, 'FORWARD_DECAPSULATED': {}, 'FORWARD_AS_IS': {}, 'PASSTHROUGH': {}, 'DUPLICATED_DECAPSULATED': {}, 'DUPLICATE_AS_IS': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__traffic_filter = YANGDynClass(base=YANGListType("id",yc_traffic_filter_mec_app_descriptor__app_descriptor_traffic_rule_traffic_filter, yang_name="traffic-filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="traffic-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__dst_interface = YANGDynClass(base=YANGListType("id",yc_dst_interface_mec_app_descriptor__app_descriptor_traffic_rule_dst_interface, yang_name="dst-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dst-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'traffic-rule']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/traffic_rule/id (string)

    YANG Description: Identifies the traffic rule
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/traffic_rule/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies the traffic rule
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_filter_type(self):
    """
    Getter method for filter_type, mapped from YANG variable /app_descriptor/traffic_rule/filter_type (enumeration)

    YANG Description: Filter type: per FLOW or PACKET
    """
    return self.__filter_type
      
  def _set_filter_type(self, v, load=False):
    """
    Setter method for filter_type, mapped from YANG variable /app_descriptor/traffic_rule/filter_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filter_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filter_type() directly.

    YANG Description: Filter type: per FLOW or PACKET
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FLOW': {}, 'PACKET': {}},), is_leaf=True, yang_name="filter-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filter_type must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FLOW': {}, 'PACKET': {}},), is_leaf=True, yang_name="filter-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__filter_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filter_type(self):
    self.__filter_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FLOW': {}, 'PACKET': {}},), is_leaf=True, yang_name="filter-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /app_descriptor/traffic_rule/priority (uint8)

    YANG Description: Priority of traffic rule from 0 to 255
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /app_descriptor/traffic_rule/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Priority of traffic rule from 0 to 255
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /app_descriptor/traffic_rule/action (enumeration)

    YANG Description: Action when packet matches traffic filter
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /app_descriptor/traffic_rule/action (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: Action when packet matches traffic filter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DROP': {}, 'FORWARD_DECAPSULATED': {}, 'FORWARD_AS_IS': {}, 'PASSTHROUGH': {}, 'DUPLICATED_DECAPSULATED': {}, 'DUPLICATE_AS_IS': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DROP': {}, 'FORWARD_DECAPSULATED': {}, 'FORWARD_AS_IS': {}, 'PASSTHROUGH': {}, 'DUPLICATED_DECAPSULATED': {}, 'DUPLICATE_AS_IS': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DROP': {}, 'FORWARD_DECAPSULATED': {}, 'FORWARD_AS_IS': {}, 'PASSTHROUGH': {}, 'DUPLICATED_DECAPSULATED': {}, 'DUPLICATE_AS_IS': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_traffic_filter(self):
    """
    Getter method for traffic_filter, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter (list)

    YANG Description: Filter to identify specific flow/packets
    """
    return self.__traffic_filter
      
  def _set_traffic_filter(self, v, load=False):
    """
    Setter method for traffic_filter, mapped from YANG variable /app_descriptor/traffic_rule/traffic_filter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_filter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_filter() directly.

    YANG Description: Filter to identify specific flow/packets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_traffic_filter_mec_app_descriptor__app_descriptor_traffic_rule_traffic_filter, yang_name="traffic-filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="traffic-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_filter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_traffic_filter_mec_app_descriptor__app_descriptor_traffic_rule_traffic_filter, yang_name="traffic-filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="traffic-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__traffic_filter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_filter(self):
    self.__traffic_filter = YANGDynClass(base=YANGListType("id",yc_traffic_filter_mec_app_descriptor__app_descriptor_traffic_rule_traffic_filter, yang_name="traffic-filter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="traffic-filter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_dst_interface(self):
    """
    Getter method for dst_interface, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface (list)

    YANG Description: Destination interface if action is FORWARD
    """
    return self.__dst_interface
      
  def _set_dst_interface(self, v, load=False):
    """
    Setter method for dst_interface, mapped from YANG variable /app_descriptor/traffic_rule/dst_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_interface() directly.

    YANG Description: Destination interface if action is FORWARD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_dst_interface_mec_app_descriptor__app_descriptor_traffic_rule_dst_interface, yang_name="dst-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dst-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_dst_interface_mec_app_descriptor__app_descriptor_traffic_rule_dst_interface, yang_name="dst-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dst-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__dst_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_interface(self):
    self.__dst_interface = YANGDynClass(base=YANGListType("id",yc_dst_interface_mec_app_descriptor__app_descriptor_traffic_rule_dst_interface, yang_name="dst-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dst-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  filter_type = __builtin__.property(_get_filter_type, _set_filter_type)
  priority = __builtin__.property(_get_priority, _set_priority)
  action = __builtin__.property(_get_action, _set_action)
  traffic_filter = __builtin__.property(_get_traffic_filter, _set_traffic_filter)
  dst_interface = __builtin__.property(_get_dst_interface, _set_dst_interface)


  _pyangbind_elements = OrderedDict([('id', id), ('filter_type', filter_type), ('priority', priority), ('action', action), ('traffic_filter', traffic_filter), ('dst_interface', dst_interface), ])


class yc_dns_rule_mec_app_descriptor__app_descriptor_dns_rule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/dns-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__domain_name','__ip_address_type','__ip_address','__ttl',)

  _yang_name = 'dns-rule'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__domain_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__ip_address_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__ip_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'dns-rule']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/dns_rule/id (string)

    YANG Description: Identifies the DNS Rule.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/dns_rule/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies the DNS Rule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_domain_name(self):
    """
    Getter method for domain_name, mapped from YANG variable /app_descriptor/dns_rule/domain_name (string)

    YANG Description: FQDN of the DNS rule.
    """
    return self.__domain_name
      
  def _set_domain_name(self, v, load=False):
    """
    Setter method for domain_name, mapped from YANG variable /app_descriptor/dns_rule/domain_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_name() directly.

    YANG Description: FQDN of the DNS rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__domain_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_name(self):
    self.__domain_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_ip_address_type(self):
    """
    Getter method for ip_address_type, mapped from YANG variable /app_descriptor/dns_rule/ip_address_type (enumeration)

    YANG Description: Specifies the IP address type, value: IP_V6, IP_V4.
    """
    return self.__ip_address_type
      
  def _set_ip_address_type(self, v, load=False):
    """
    Setter method for ip_address_type, mapped from YANG variable /app_descriptor/dns_rule/ip_address_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_type() directly.

    YANG Description: Specifies the IP address type, value: IP_V6, IP_V4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address_type must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__ip_address_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address_type(self):
    self.__ip_address_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /app_descriptor/dns_rule/ip_address (string)

    YANG Description: IP address given by the DNS rule.
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /app_descriptor/dns_rule/ip_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address given by the DNS rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_ttl(self):
    """
    Getter method for ttl, mapped from YANG variable /app_descriptor/dns_rule/ttl (uint32)

    YANG Description: Time-to-live value.
    """
    return self.__ttl
      
  def _set_ttl(self, v, load=False):
    """
    Setter method for ttl, mapped from YANG variable /app_descriptor/dns_rule/ttl (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl() directly.

    YANG Description: Time-to-live value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl(self):
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  domain_name = __builtin__.property(_get_domain_name, _set_domain_name)
  ip_address_type = __builtin__.property(_get_ip_address_type, _set_ip_address_type)
  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
  ttl = __builtin__.property(_get_ttl, _set_ttl)


  _pyangbind_elements = OrderedDict([('id', id), ('domain_name', domain_name), ('ip_address_type', ip_address_type), ('ip_address', ip_address), ('ttl', ttl), ])


class yc_latency_mec_app_descriptor__app_descriptor_latency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/latency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_latency',)

  _yang_name = 'latency'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_latency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'latency']

  def _get_max_latency(self):
    """
    Getter method for max_latency, mapped from YANG variable /app_descriptor/latency/max_latency (uint32)

    YANG Description: The value of the maximum latency in nano seconds tolerated by the MEC application.
    """
    return self.__max_latency
      
  def _set_max_latency(self, v, load=False):
    """
    Setter method for max_latency, mapped from YANG variable /app_descriptor/latency/max_latency (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_latency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_latency() directly.

    YANG Description: The value of the maximum latency in nano seconds tolerated by the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_latency must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__max_latency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_latency(self):
    self.__max_latency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

  max_latency = __builtin__.property(_get_max_latency, _set_max_latency)


  _pyangbind_elements = OrderedDict([('max_latency', max_latency), ])


class yc_vnf_parameters_mec_app_descriptor__app_descriptor_terminate_app_instance_op_config_vnf_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/terminate-app-instance-op-config/vnf-parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'vnf-parameters'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'terminate-app-instance-op-config', 'vnf-parameters']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config/vnf_parameters/key (string)

    YANG Description: Key of the VNF-specific parameter.
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config/vnf_parameters/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key of the VNF-specific parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config/vnf_parameters/value (string)

    YANG Description: Value of the VNF-specific parameter.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config/vnf_parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value of the VNF-specific parameter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_terminate_app_instance_op_config_mec_app_descriptor__app_descriptor_terminate_app_instance_op_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/terminate-app-instance-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__min_graceful_termination_timeout','__max_recommended_graceful_termination_timeout','__vnf_parameters',)

  _yang_name = 'terminate-app-instance-op-config'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__min_graceful_termination_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-graceful-termination-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    self.__max_recommended_graceful_termination_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-termination-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    self.__vnf_parameters = YANGDynClass(base=YANGListType("key",yc_vnf_parameters_mec_app_descriptor__app_descriptor_terminate_app_instance_op_config_vnf_parameters, yang_name="vnf-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vnf-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'terminate-app-instance-op-config']

  def _get_min_graceful_termination_timeout(self):
    """
    Getter method for min_graceful_termination_timeout, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config/min_graceful_termination_timeout (uint32)

    YANG Description: Minimum timeout value for graceful termination of a VNF instance.
    """
    return self.__min_graceful_termination_timeout
      
  def _set_min_graceful_termination_timeout(self, v, load=False):
    """
    Setter method for min_graceful_termination_timeout, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config/min_graceful_termination_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_graceful_termination_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_graceful_termination_timeout() directly.

    YANG Description: Minimum timeout value for graceful termination of a VNF instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-graceful-termination-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_graceful_termination_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-graceful-termination-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__min_graceful_termination_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_graceful_termination_timeout(self):
    self.__min_graceful_termination_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-graceful-termination-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)


  def _get_max_recommended_graceful_termination_timeout(self):
    """
    Getter method for max_recommended_graceful_termination_timeout, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config/max_recommended_graceful_termination_timeout (uint32)

    YANG Description: Maximum recommended timeout value that can be needed to gracefully terminate a VNF instance of a particular type under certain conditions, such as maximum load condition.
    """
    return self.__max_recommended_graceful_termination_timeout
      
  def _set_max_recommended_graceful_termination_timeout(self, v, load=False):
    """
    Setter method for max_recommended_graceful_termination_timeout, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config/max_recommended_graceful_termination_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_recommended_graceful_termination_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_recommended_graceful_termination_timeout() directly.

    YANG Description: Maximum recommended timeout value that can be needed to gracefully terminate a VNF instance of a particular type under certain conditions, such as maximum load condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-termination-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_recommended_graceful_termination_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-termination-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__max_recommended_graceful_termination_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_recommended_graceful_termination_timeout(self):
    self.__max_recommended_graceful_termination_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-termination-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)


  def _get_vnf_parameters(self):
    """
    Getter method for vnf_parameters, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config/vnf_parameters (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
    """
    return self.__vnf_parameters
      
  def _set_vnf_parameters(self, v, load=False):
    """
    Setter method for vnf_parameters, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config/vnf_parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_parameters() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_vnf_parameters_mec_app_descriptor__app_descriptor_terminate_app_instance_op_config_vnf_parameters, yang_name="vnf-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vnf-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_vnf_parameters_mec_app_descriptor__app_descriptor_terminate_app_instance_op_config_vnf_parameters, yang_name="vnf-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vnf-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__vnf_parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_parameters(self):
    self.__vnf_parameters = YANGDynClass(base=YANGListType("key",yc_vnf_parameters_mec_app_descriptor__app_descriptor_terminate_app_instance_op_config_vnf_parameters, yang_name="vnf-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vnf-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  min_graceful_termination_timeout = __builtin__.property(_get_min_graceful_termination_timeout, _set_min_graceful_termination_timeout)
  max_recommended_graceful_termination_timeout = __builtin__.property(_get_max_recommended_graceful_termination_timeout, _set_max_recommended_graceful_termination_timeout)
  vnf_parameters = __builtin__.property(_get_vnf_parameters, _set_vnf_parameters)


  _pyangbind_elements = OrderedDict([('min_graceful_termination_timeout', min_graceful_termination_timeout), ('max_recommended_graceful_termination_timeout', max_recommended_graceful_termination_timeout), ('vnf_parameters', vnf_parameters), ])


class yc_vnf_parameters_mec_app_descriptor__app_descriptor_change_app_instance_state_op_config_vnf_parameters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/change-app-instance-state-op-config/vnf-parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'vnf-parameters'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'change-app-instance-state-op-config', 'vnf-parameters']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config/vnf_parameters/key (string)

    YANG Description: Key of the VNF-specific parameter.
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config/vnf_parameters/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key of the VNF-specific parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config/vnf_parameters/value (string)

    YANG Description: Value of the VNF-specific parameter.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config/vnf_parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value of the VNF-specific parameter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_change_app_instance_state_op_config_mec_app_descriptor__app_descriptor_change_app_instance_state_op_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/change-app-instance-state-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__min_graceful_stop_timeout','__max_recommended_graceful_stop_timeout','__vnf_parameters',)

  _yang_name = 'change-app-instance-state-op-config'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__min_graceful_stop_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    self.__max_recommended_graceful_stop_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    self.__vnf_parameters = YANGDynClass(base=YANGListType("key",yc_vnf_parameters_mec_app_descriptor__app_descriptor_change_app_instance_state_op_config_vnf_parameters, yang_name="vnf-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vnf-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'change-app-instance-state-op-config']

  def _get_min_graceful_stop_timeout(self):
    """
    Getter method for min_graceful_stop_timeout, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config/min_graceful_stop_timeout (uint32)

    YANG Description: Minimum timeout value for graceful stop of a VNF instance.
    """
    return self.__min_graceful_stop_timeout
      
  def _set_min_graceful_stop_timeout(self, v, load=False):
    """
    Setter method for min_graceful_stop_timeout, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config/min_graceful_stop_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_graceful_stop_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_graceful_stop_timeout() directly.

    YANG Description: Minimum timeout value for graceful stop of a VNF instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_graceful_stop_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__min_graceful_stop_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_graceful_stop_timeout(self):
    self.__min_graceful_stop_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)


  def _get_max_recommended_graceful_stop_timeout(self):
    """
    Getter method for max_recommended_graceful_stop_timeout, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config/max_recommended_graceful_stop_timeout (uint32)

    YANG Description: Maximum recommended timeout value that can be needed to gracefully stop a VNF instance of a particular type under certain conditions, such as maximum load condition.
    """
    return self.__max_recommended_graceful_stop_timeout
      
  def _set_max_recommended_graceful_stop_timeout(self, v, load=False):
    """
    Setter method for max_recommended_graceful_stop_timeout, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config/max_recommended_graceful_stop_timeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_recommended_graceful_stop_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_recommended_graceful_stop_timeout() directly.

    YANG Description: Maximum recommended timeout value that can be needed to gracefully stop a VNF instance of a particular type under certain conditions, such as maximum load condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_recommended_graceful_stop_timeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__max_recommended_graceful_stop_timeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_recommended_graceful_stop_timeout(self):
    self.__max_recommended_graceful_stop_timeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)


  def _get_vnf_parameters(self):
    """
    Getter method for vnf_parameters, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config/vnf_parameters (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
    """
    return self.__vnf_parameters
      
  def _set_vnf_parameters(self, v, load=False):
    """
    Setter method for vnf_parameters, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config/vnf_parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_parameters() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_vnf_parameters_mec_app_descriptor__app_descriptor_change_app_instance_state_op_config_vnf_parameters, yang_name="vnf-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vnf-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vnf_parameters must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_vnf_parameters_mec_app_descriptor__app_descriptor_change_app_instance_state_op_config_vnf_parameters, yang_name="vnf-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vnf-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__vnf_parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vnf_parameters(self):
    self.__vnf_parameters = YANGDynClass(base=YANGListType("key",yc_vnf_parameters_mec_app_descriptor__app_descriptor_change_app_instance_state_op_config_vnf_parameters, yang_name="vnf-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vnf-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  min_graceful_stop_timeout = __builtin__.property(_get_min_graceful_stop_timeout, _set_min_graceful_stop_timeout)
  max_recommended_graceful_stop_timeout = __builtin__.property(_get_max_recommended_graceful_stop_timeout, _set_max_recommended_graceful_stop_timeout)
  vnf_parameters = __builtin__.property(_get_vnf_parameters, _set_vnf_parameters)


  _pyangbind_elements = OrderedDict([('min_graceful_stop_timeout', min_graceful_stop_timeout), ('max_recommended_graceful_stop_timeout', max_recommended_graceful_stop_timeout), ('vnf_parameters', vnf_parameters), ])


class yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_user_context_transfer_capability(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/user-context-transfer-capability. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__stateful_application','__user_context_transfer_support',)

  _yang_name = 'user-context-transfer-capability'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__stateful_application = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stateful-application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__user_context_transfer_support = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="user-context-transfer-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'user-context-transfer-capability']

  def _get_stateful_application(self):
    """
    Getter method for stateful_application, mapped from YANG variable /app_descriptor/user_context_transfer_capability/stateful_application (boolean)

    YANG Description: If the application is stateful, this attribute shall be set to true. Otherwise, this attribute shall be set to false.
    """
    return self.__stateful_application
      
  def _set_stateful_application(self, v, load=False):
    """
    Setter method for stateful_application, mapped from YANG variable /app_descriptor/user_context_transfer_capability/stateful_application (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stateful_application is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stateful_application() directly.

    YANG Description: If the application is stateful, this attribute shall be set to true. Otherwise, this attribute shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="stateful-application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stateful_application must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stateful-application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__stateful_application = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stateful_application(self):
    self.__stateful_application = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stateful-application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_user_context_transfer_support(self):
    """
    Getter method for user_context_transfer_support, mapped from YANG variable /app_descriptor/user_context_transfer_capability/user_context_transfer_support (boolean)

    YANG Description: This attribute shall be present if the application is stateful and supports the user context transfer. Otherwise, this attribute shall be set to false or be absent.
    """
    return self.__user_context_transfer_support
      
  def _set_user_context_transfer_support(self, v, load=False):
    """
    Setter method for user_context_transfer_support, mapped from YANG variable /app_descriptor/user_context_transfer_capability/user_context_transfer_support (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_context_transfer_support is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_context_transfer_support() directly.

    YANG Description: This attribute shall be present if the application is stateful and supports the user context transfer. Otherwise, this attribute shall be set to false or be absent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="user-context-transfer-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_context_transfer_support must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="user-context-transfer-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__user_context_transfer_support = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_context_transfer_support(self):
    self.__user_context_transfer_support = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="user-context-transfer-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

  stateful_application = __builtin__.property(_get_stateful_application, _set_stateful_application)
  user_context_transfer_support = __builtin__.property(_get_user_context_transfer_support, _set_user_context_transfer_support)


  _pyangbind_elements = OrderedDict([('stateful_application', stateful_application), ('user_context_transfer_support', user_context_transfer_support), ])


class yc_network_policy_mec_app_descriptor__app_descriptor_network_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/network-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__cellular_network','__wifi_network','__fixed_access_network',)

  _yang_name = 'network-policy'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cellular_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellular-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__wifi_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wifi-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__fixed_access_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixed-access-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'network-policy']

  def _get_cellular_network(self):
    """
    Getter method for cellular_network, mapped from YANG variable /app_descriptor/network_policy/cellular_network (boolean)

    YANG Description: If present, and the application prefers to a cellular network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    return self.__cellular_network
      
  def _set_cellular_network(self, v, load=False):
    """
    Setter method for cellular_network, mapped from YANG variable /app_descriptor/network_policy/cellular_network (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cellular_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cellular_network() directly.

    YANG Description: If present, and the application prefers to a cellular network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellular-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cellular_network must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellular-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__cellular_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cellular_network(self):
    self.__cellular_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellular-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_wifi_network(self):
    """
    Getter method for wifi_network, mapped from YANG variable /app_descriptor/network_policy/wifi_network (boolean)

    YANG Description: If present, and the application prefers to a Wi-Fi network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    return self.__wifi_network
      
  def _set_wifi_network(self, v, load=False):
    """
    Setter method for wifi_network, mapped from YANG variable /app_descriptor/network_policy/wifi_network (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wifi_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wifi_network() directly.

    YANG Description: If present, and the application prefers to a Wi-Fi network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wifi-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wifi_network must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wifi-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__wifi_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wifi_network(self):
    self.__wifi_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wifi-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_fixed_access_network(self):
    """
    Getter method for fixed_access_network, mapped from YANG variable /app_descriptor/network_policy/fixed_access_network (boolean)

    YANG Description: If present, and the application prefers to a fixed access network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    return self.__fixed_access_network
      
  def _set_fixed_access_network(self, v, load=False):
    """
    Setter method for fixed_access_network, mapped from YANG variable /app_descriptor/network_policy/fixed_access_network (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fixed_access_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fixed_access_network() directly.

    YANG Description: If present, and the application prefers to a fixed access network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixed-access-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fixed_access_network must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixed-access-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__fixed_access_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fixed_access_network(self):
    self.__fixed_access_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixed-access-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

  cellular_network = __builtin__.property(_get_cellular_network, _set_cellular_network)
  wifi_network = __builtin__.property(_get_wifi_network, _set_wifi_network)
  fixed_access_network = __builtin__.property(_get_fixed_access_network, _set_fixed_access_network)


  _pyangbind_elements = OrderedDict([('cellular_network', cellular_network), ('wifi_network', wifi_network), ('fixed_access_network', fixed_access_network), ])


class yc_opendb_helm_mec_app_descriptor__app_descriptor_artifacts_opendb_helm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/artifacts/opendb_helm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: 
  """
  __slots__ = ('_path_helper', '_extmethods', '__description','__type','__file',)

  _yang_name = 'opendb_helm'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__file = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'artifacts', 'opendb_helm']

  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/artifacts/opendb_helm/description (string)

    YANG Description: Description of the artifact.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/artifacts/opendb_helm/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the artifact.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /app_descriptor/artifacts/opendb_helm/type (string)

    YANG Description: Type of the artifact.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /app_descriptor/artifacts/opendb_helm/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the artifact.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_file(self):
    """
    Getter method for file, mapped from YANG variable /app_descriptor/artifacts/opendb_helm/file (string)

    YANG Description: File name of the artifact.
    """
    return self.__file
      
  def _set_file(self, v, load=False):
    """
    Setter method for file, mapped from YANG variable /app_descriptor/artifacts/opendb_helm/file (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_file is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_file() directly.

    YANG Description: File name of the artifact.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="file", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """file must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__file = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_file(self):
    self.__file = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="file", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  file = __builtin__.property(_get_file, _set_file)


  _pyangbind_elements = OrderedDict([('description', description), ('type', type), ('file', file), ])


class yc_artifacts_mec_app_descriptor__app_descriptor_artifacts(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/artifacts. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Artifact Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__opendb_helm',)

  _yang_name = 'artifacts'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__opendb_helm = YANGDynClass(base=yc_opendb_helm_mec_app_descriptor__app_descriptor_artifacts_opendb_helm, is_container='container', yang_name="opendb_helm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'artifacts']

  def _get_opendb_helm(self):
    """
    Getter method for opendb_helm, mapped from YANG variable /app_descriptor/artifacts/opendb_helm (container)
    """
    return self.__opendb_helm
      
  def _set_opendb_helm(self, v, load=False):
    """
    Setter method for opendb_helm, mapped from YANG variable /app_descriptor/artifacts/opendb_helm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opendb_helm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opendb_helm() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_opendb_helm_mec_app_descriptor__app_descriptor_artifacts_opendb_helm, is_container='container', yang_name="opendb_helm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opendb_helm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_opendb_helm_mec_app_descriptor__app_descriptor_artifacts_opendb_helm, is_container='container', yang_name="opendb_helm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__opendb_helm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opendb_helm(self):
    self.__opendb_helm = YANGDynClass(base=yc_opendb_helm_mec_app_descriptor__app_descriptor_artifacts_opendb_helm, is_container='container', yang_name="opendb_helm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  opendb_helm = __builtin__.property(_get_opendb_helm, _set_opendb_helm)


  _pyangbind_elements = OrderedDict([('opendb_helm', opendb_helm), ])


class yc_app_descriptor_mec_app_descriptor__app_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__provider','__soft_version','__version','__mec_version','__info_name','__description','__virtual_compute','__sw_image','__virtual_storage','__ext_cpd','__service_required','__service_optional','__service_produced','__feature_required','__feature_optional','__transport_dependencies','__traffic_rule','__dns_rule','__latency','__terminate_app_instance_op_config','__change_app_instance_state_op_config','__user_context_transfer_capability','__network_policy','__artifacts',)

  _yang_name = 'app-descriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__provider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__soft_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="soft-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__mec_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mec-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__info_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__virtual_compute = YANGDynClass(base=yc_virtual_compute_mec_app_descriptor__app_descriptor_virtual_compute, is_container='container', yang_name="virtual-compute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__sw_image = YANGDynClass(base=yc_sw_image_mec_app_descriptor__app_descriptor_sw_image, is_container='container', yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__virtual_storage = YANGDynClass(base=YANGListType("id",yc_virtual_storage_mec_app_descriptor__app_descriptor_virtual_storage, yang_name="virtual-storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__ext_cpd = YANGDynClass(base=YANGListType("id",yc_ext_cpd_mec_app_descriptor__app_descriptor_ext_cpd, yang_name="ext-cpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__service_required = YANGDynClass(base=YANGListType("name",yc_service_required_mec_app_descriptor__app_descriptor_service_required, yang_name="service-required", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__service_optional = YANGDynClass(base=YANGListType("name",yc_service_optional_mec_app_descriptor__app_descriptor_service_optional, yang_name="service-optional", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__service_produced = YANGDynClass(base=YANGListType("name",yc_service_produced_mec_app_descriptor__app_descriptor_service_produced, yang_name="service-produced", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-produced", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__feature_required = YANGDynClass(base=yc_feature_required_mec_app_descriptor__app_descriptor_feature_required, is_container='container', yang_name="feature-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__feature_optional = YANGDynClass(base=yc_feature_optional_mec_app_descriptor__app_descriptor_feature_optional, is_container='container', yang_name="feature-optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__transport_dependencies = YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__traffic_rule = YANGDynClass(base=YANGListType("id",yc_traffic_rule_mec_app_descriptor__app_descriptor_traffic_rule, yang_name="traffic-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="traffic-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__dns_rule = YANGDynClass(base=YANGListType("id",yc_dns_rule_mec_app_descriptor__app_descriptor_dns_rule, yang_name="dns-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dns-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__latency = YANGDynClass(base=yc_latency_mec_app_descriptor__app_descriptor_latency, is_container='container', yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__terminate_app_instance_op_config = YANGDynClass(base=yc_terminate_app_instance_op_config_mec_app_descriptor__app_descriptor_terminate_app_instance_op_config, is_container='container', yang_name="terminate-app-instance-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__change_app_instance_state_op_config = YANGDynClass(base=yc_change_app_instance_state_op_config_mec_app_descriptor__app_descriptor_change_app_instance_state_op_config, is_container='container', yang_name="change-app-instance-state-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__user_context_transfer_capability = YANGDynClass(base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__network_policy = YANGDynClass(base=yc_network_policy_mec_app_descriptor__app_descriptor_network_policy, is_container='container', yang_name="network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__artifacts = YANGDynClass(base=yc_artifacts_mec_app_descriptor__app_descriptor_artifacts, is_container='container', yang_name="artifacts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/id (string)

    YANG Description: Identifier of this MEC application descriptor. This attribute shall be globally unique.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this MEC application descriptor. This attribute shall be globally unique.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/name (string)

    YANG Description: Name to identify the MEC application.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name to identify the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_provider(self):
    """
    Getter method for provider, mapped from YANG variable /app_descriptor/provider (string)

    YANG Description: Provider of the application and of the AppD.
    """
    return self.__provider
      
  def _set_provider(self, v, load=False):
    """
    Setter method for provider, mapped from YANG variable /app_descriptor/provider (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider() directly.

    YANG Description: Provider of the application and of the AppD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provider must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__provider = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provider(self):
    self.__provider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_soft_version(self):
    """
    Getter method for soft_version, mapped from YANG variable /app_descriptor/soft_version (string)

    YANG Description: Identifies the version of software of the MEC application.
    """
    return self.__soft_version
      
  def _set_soft_version(self, v, load=False):
    """
    Setter method for soft_version, mapped from YANG variable /app_descriptor/soft_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_version() directly.

    YANG Description: Identifies the version of software of the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="soft-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="soft-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__soft_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_version(self):
    self.__soft_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="soft-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/version (string)

    YANG Description: Identifies the version of the application descriptor.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Identifies the version of the application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_mec_version(self):
    """
    Getter method for mec_version, mapped from YANG variable /app_descriptor/mec_version (string)

    YANG Description: Identifies version(s) of MEC system compatible with the MEC application described in this version of the AppD. The value shall be formatted as comma-separated list of strings.
    """
    return self.__mec_version
      
  def _set_mec_version(self, v, load=False):
    """
    Setter method for mec_version, mapped from YANG variable /app_descriptor/mec_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mec_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mec_version() directly.

    YANG Description: Identifies version(s) of MEC system compatible with the MEC application described in this version of the AppD. The value shall be formatted as comma-separated list of strings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mec-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mec_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mec-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__mec_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mec_version(self):
    self.__mec_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mec-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_info_name(self):
    """
    Getter method for info_name, mapped from YANG variable /app_descriptor/info_name (string)

    YANG Description: Human readable name for the MEC application.
    """
    return self.__info_name
      
  def _set_info_name(self, v, load=False):
    """
    Setter method for info_name, mapped from YANG variable /app_descriptor/info_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_info_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_info_name() directly.

    YANG Description: Human readable name for the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """info_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__info_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_info_name(self):
    self.__info_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/description (string)

    YANG Description: Human readable description of the MEC application.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_virtual_compute(self):
    """
    Getter method for virtual_compute, mapped from YANG variable /app_descriptor/virtual_compute (container)
    """
    return self.__virtual_compute
      
  def _set_virtual_compute(self, v, load=False):
    """
    Setter method for virtual_compute, mapped from YANG variable /app_descriptor/virtual_compute (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_compute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_compute() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_virtual_compute_mec_app_descriptor__app_descriptor_virtual_compute, is_container='container', yang_name="virtual-compute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_compute must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_virtual_compute_mec_app_descriptor__app_descriptor_virtual_compute, is_container='container', yang_name="virtual-compute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__virtual_compute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_compute(self):
    self.__virtual_compute = YANGDynClass(base=yc_virtual_compute_mec_app_descriptor__app_descriptor_virtual_compute, is_container='container', yang_name="virtual-compute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_sw_image(self):
    """
    Getter method for sw_image, mapped from YANG variable /app_descriptor/sw_image (container)
    """
    return self.__sw_image
      
  def _set_sw_image(self, v, load=False):
    """
    Setter method for sw_image, mapped from YANG variable /app_descriptor/sw_image (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sw_image_mec_app_descriptor__app_descriptor_sw_image, is_container='container', yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sw_image must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sw_image_mec_app_descriptor__app_descriptor_sw_image, is_container='container', yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__sw_image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sw_image(self):
    self.__sw_image = YANGDynClass(base=yc_sw_image_mec_app_descriptor__app_descriptor_sw_image, is_container='container', yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_virtual_storage(self):
    """
    Getter method for virtual_storage, mapped from YANG variable /app_descriptor/virtual_storage (list)
    """
    return self.__virtual_storage
      
  def _set_virtual_storage(self, v, load=False):
    """
    Setter method for virtual_storage, mapped from YANG variable /app_descriptor/virtual_storage (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_storage() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_virtual_storage_mec_app_descriptor__app_descriptor_virtual_storage, yang_name="virtual-storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_storage must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_storage_mec_app_descriptor__app_descriptor_virtual_storage, yang_name="virtual-storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__virtual_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_storage(self):
    self.__virtual_storage = YANGDynClass(base=YANGListType("id",yc_virtual_storage_mec_app_descriptor__app_descriptor_virtual_storage, yang_name="virtual-storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_ext_cpd(self):
    """
    Getter method for ext_cpd, mapped from YANG variable /app_descriptor/ext_cpd (list)
    """
    return self.__ext_cpd
      
  def _set_ext_cpd(self, v, load=False):
    """
    Setter method for ext_cpd, mapped from YANG variable /app_descriptor/ext_cpd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_cpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_cpd() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_ext_cpd_mec_app_descriptor__app_descriptor_ext_cpd, yang_name="ext-cpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_cpd must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_ext_cpd_mec_app_descriptor__app_descriptor_ext_cpd, yang_name="ext-cpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__ext_cpd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_cpd(self):
    self.__ext_cpd = YANGDynClass(base=YANGListType("id",yc_ext_cpd_mec_app_descriptor__app_descriptor_ext_cpd, yang_name="ext-cpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_service_required(self):
    """
    Getter method for service_required, mapped from YANG variable /app_descriptor/service_required (list)
    """
    return self.__service_required
      
  def _set_service_required(self, v, load=False):
    """
    Setter method for service_required, mapped from YANG variable /app_descriptor/service_required (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_required() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_service_required_mec_app_descriptor__app_descriptor_service_required, yang_name="service-required", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_required must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_service_required_mec_app_descriptor__app_descriptor_service_required, yang_name="service-required", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__service_required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_required(self):
    self.__service_required = YANGDynClass(base=YANGListType("name",yc_service_required_mec_app_descriptor__app_descriptor_service_required, yang_name="service-required", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_service_optional(self):
    """
    Getter method for service_optional, mapped from YANG variable /app_descriptor/service_optional (list)
    """
    return self.__service_optional
      
  def _set_service_optional(self, v, load=False):
    """
    Setter method for service_optional, mapped from YANG variable /app_descriptor/service_optional (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_optional() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_service_optional_mec_app_descriptor__app_descriptor_service_optional, yang_name="service-optional", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_optional must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_service_optional_mec_app_descriptor__app_descriptor_service_optional, yang_name="service-optional", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__service_optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_optional(self):
    self.__service_optional = YANGDynClass(base=YANGListType("name",yc_service_optional_mec_app_descriptor__app_descriptor_service_optional, yang_name="service-optional", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_service_produced(self):
    """
    Getter method for service_produced, mapped from YANG variable /app_descriptor/service_produced (list)
    """
    return self.__service_produced
      
  def _set_service_produced(self, v, load=False):
    """
    Setter method for service_produced, mapped from YANG variable /app_descriptor/service_produced (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_produced is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_produced() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_service_produced_mec_app_descriptor__app_descriptor_service_produced, yang_name="service-produced", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-produced", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_produced must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_service_produced_mec_app_descriptor__app_descriptor_service_produced, yang_name="service-produced", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-produced", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__service_produced = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_produced(self):
    self.__service_produced = YANGDynClass(base=YANGListType("name",yc_service_produced_mec_app_descriptor__app_descriptor_service_produced, yang_name="service-produced", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-produced", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_feature_required(self):
    """
    Getter method for feature_required, mapped from YANG variable /app_descriptor/feature_required (container)
    """
    return self.__feature_required
      
  def _set_feature_required(self, v, load=False):
    """
    Setter method for feature_required, mapped from YANG variable /app_descriptor/feature_required (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature_required() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_feature_required_mec_app_descriptor__app_descriptor_feature_required, is_container='container', yang_name="feature-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature_required must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_feature_required_mec_app_descriptor__app_descriptor_feature_required, is_container='container', yang_name="feature-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__feature_required = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature_required(self):
    self.__feature_required = YANGDynClass(base=yc_feature_required_mec_app_descriptor__app_descriptor_feature_required, is_container='container', yang_name="feature-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_feature_optional(self):
    """
    Getter method for feature_optional, mapped from YANG variable /app_descriptor/feature_optional (container)
    """
    return self.__feature_optional
      
  def _set_feature_optional(self, v, load=False):
    """
    Setter method for feature_optional, mapped from YANG variable /app_descriptor/feature_optional (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature_optional() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_feature_optional_mec_app_descriptor__app_descriptor_feature_optional, is_container='container', yang_name="feature-optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature_optional must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_feature_optional_mec_app_descriptor__app_descriptor_feature_optional, is_container='container', yang_name="feature-optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__feature_optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature_optional(self):
    self.__feature_optional = YANGDynClass(base=yc_feature_optional_mec_app_descriptor__app_descriptor_feature_optional, is_container='container', yang_name="feature-optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_transport_dependencies(self):
    """
    Getter method for transport_dependencies, mapped from YANG variable /app_descriptor/transport_dependencies (list)
    """
    return self.__transport_dependencies
      
  def _set_transport_dependencies(self, v, load=False):
    """
    Setter method for transport_dependencies, mapped from YANG variable /app_descriptor/transport_dependencies (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport_dependencies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport_dependencies() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport_dependencies must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__transport_dependencies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport_dependencies(self):
    self.__transport_dependencies = YANGDynClass(base=YANGListType("id",yc_transport_dependencies_mec_app_descriptor__app_descriptor_transport_dependencies, yang_name="transport-dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transport-dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_traffic_rule(self):
    """
    Getter method for traffic_rule, mapped from YANG variable /app_descriptor/traffic_rule (list)
    """
    return self.__traffic_rule
      
  def _set_traffic_rule(self, v, load=False):
    """
    Setter method for traffic_rule, mapped from YANG variable /app_descriptor/traffic_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_rule() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_traffic_rule_mec_app_descriptor__app_descriptor_traffic_rule, yang_name="traffic-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="traffic-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_rule must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_traffic_rule_mec_app_descriptor__app_descriptor_traffic_rule, yang_name="traffic-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="traffic-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__traffic_rule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_rule(self):
    self.__traffic_rule = YANGDynClass(base=YANGListType("id",yc_traffic_rule_mec_app_descriptor__app_descriptor_traffic_rule, yang_name="traffic-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="traffic-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_dns_rule(self):
    """
    Getter method for dns_rule, mapped from YANG variable /app_descriptor/dns_rule (list)
    """
    return self.__dns_rule
      
  def _set_dns_rule(self, v, load=False):
    """
    Setter method for dns_rule, mapped from YANG variable /app_descriptor/dns_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_rule() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_dns_rule_mec_app_descriptor__app_descriptor_dns_rule, yang_name="dns-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dns-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_rule must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_dns_rule_mec_app_descriptor__app_descriptor_dns_rule, yang_name="dns-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dns-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__dns_rule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_rule(self):
    self.__dns_rule = YANGDynClass(base=YANGListType("id",yc_dns_rule_mec_app_descriptor__app_descriptor_dns_rule, yang_name="dns-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dns-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_latency(self):
    """
    Getter method for latency, mapped from YANG variable /app_descriptor/latency (container)
    """
    return self.__latency
      
  def _set_latency(self, v, load=False):
    """
    Setter method for latency, mapped from YANG variable /app_descriptor/latency (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latency() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_latency_mec_app_descriptor__app_descriptor_latency, is_container='container', yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """latency must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_latency_mec_app_descriptor__app_descriptor_latency, is_container='container', yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__latency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_latency(self):
    self.__latency = YANGDynClass(base=yc_latency_mec_app_descriptor__app_descriptor_latency, is_container='container', yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_terminate_app_instance_op_config(self):
    """
    Getter method for terminate_app_instance_op_config, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config (container)
    """
    return self.__terminate_app_instance_op_config
      
  def _set_terminate_app_instance_op_config(self, v, load=False):
    """
    Setter method for terminate_app_instance_op_config, mapped from YANG variable /app_descriptor/terminate_app_instance_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_app_instance_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_app_instance_op_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_terminate_app_instance_op_config_mec_app_descriptor__app_descriptor_terminate_app_instance_op_config, is_container='container', yang_name="terminate-app-instance-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminate_app_instance_op_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_terminate_app_instance_op_config_mec_app_descriptor__app_descriptor_terminate_app_instance_op_config, is_container='container', yang_name="terminate-app-instance-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__terminate_app_instance_op_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminate_app_instance_op_config(self):
    self.__terminate_app_instance_op_config = YANGDynClass(base=yc_terminate_app_instance_op_config_mec_app_descriptor__app_descriptor_terminate_app_instance_op_config, is_container='container', yang_name="terminate-app-instance-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_change_app_instance_state_op_config(self):
    """
    Getter method for change_app_instance_state_op_config, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config (container)
    """
    return self.__change_app_instance_state_op_config
      
  def _set_change_app_instance_state_op_config(self, v, load=False):
    """
    Setter method for change_app_instance_state_op_config, mapped from YANG variable /app_descriptor/change_app_instance_state_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_change_app_instance_state_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_change_app_instance_state_op_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_change_app_instance_state_op_config_mec_app_descriptor__app_descriptor_change_app_instance_state_op_config, is_container='container', yang_name="change-app-instance-state-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """change_app_instance_state_op_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_change_app_instance_state_op_config_mec_app_descriptor__app_descriptor_change_app_instance_state_op_config, is_container='container', yang_name="change-app-instance-state-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__change_app_instance_state_op_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_change_app_instance_state_op_config(self):
    self.__change_app_instance_state_op_config = YANGDynClass(base=yc_change_app_instance_state_op_config_mec_app_descriptor__app_descriptor_change_app_instance_state_op_config, is_container='container', yang_name="change-app-instance-state-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_user_context_transfer_capability(self):
    """
    Getter method for user_context_transfer_capability, mapped from YANG variable /app_descriptor/user_context_transfer_capability (container)
    """
    return self.__user_context_transfer_capability
      
  def _set_user_context_transfer_capability(self, v, load=False):
    """
    Setter method for user_context_transfer_capability, mapped from YANG variable /app_descriptor/user_context_transfer_capability (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_context_transfer_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_context_transfer_capability() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_context_transfer_capability must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__user_context_transfer_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_context_transfer_capability(self):
    self.__user_context_transfer_capability = YANGDynClass(base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_network_policy(self):
    """
    Getter method for network_policy, mapped from YANG variable /app_descriptor/network_policy (container)
    """
    return self.__network_policy
      
  def _set_network_policy(self, v, load=False):
    """
    Setter method for network_policy, mapped from YANG variable /app_descriptor/network_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_policy() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_policy_mec_app_descriptor__app_descriptor_network_policy, is_container='container', yang_name="network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_policy_mec_app_descriptor__app_descriptor_network_policy, is_container='container', yang_name="network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__network_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_policy(self):
    self.__network_policy = YANGDynClass(base=yc_network_policy_mec_app_descriptor__app_descriptor_network_policy, is_container='container', yang_name="network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_artifacts(self):
    """
    Getter method for artifacts, mapped from YANG variable /app_descriptor/artifacts (container)

    YANG Description: Incorporates the Artifact Descriptor into the MEC application descriptor.
    """
    return self.__artifacts
      
  def _set_artifacts(self, v, load=False):
    """
    Setter method for artifacts, mapped from YANG variable /app_descriptor/artifacts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_artifacts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_artifacts() directly.

    YANG Description: Incorporates the Artifact Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_artifacts_mec_app_descriptor__app_descriptor_artifacts, is_container='container', yang_name="artifacts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """artifacts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_artifacts_mec_app_descriptor__app_descriptor_artifacts, is_container='container', yang_name="artifacts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__artifacts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_artifacts(self):
    self.__artifacts = YANGDynClass(base=yc_artifacts_mec_app_descriptor__app_descriptor_artifacts, is_container='container', yang_name="artifacts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  provider = __builtin__.property(_get_provider, _set_provider)
  soft_version = __builtin__.property(_get_soft_version, _set_soft_version)
  version = __builtin__.property(_get_version, _set_version)
  mec_version = __builtin__.property(_get_mec_version, _set_mec_version)
  info_name = __builtin__.property(_get_info_name, _set_info_name)
  description = __builtin__.property(_get_description, _set_description)
  virtual_compute = __builtin__.property(_get_virtual_compute, _set_virtual_compute)
  sw_image = __builtin__.property(_get_sw_image, _set_sw_image)
  virtual_storage = __builtin__.property(_get_virtual_storage, _set_virtual_storage)
  ext_cpd = __builtin__.property(_get_ext_cpd, _set_ext_cpd)
  service_required = __builtin__.property(_get_service_required, _set_service_required)
  service_optional = __builtin__.property(_get_service_optional, _set_service_optional)
  service_produced = __builtin__.property(_get_service_produced, _set_service_produced)
  feature_required = __builtin__.property(_get_feature_required, _set_feature_required)
  feature_optional = __builtin__.property(_get_feature_optional, _set_feature_optional)
  transport_dependencies = __builtin__.property(_get_transport_dependencies, _set_transport_dependencies)
  traffic_rule = __builtin__.property(_get_traffic_rule, _set_traffic_rule)
  dns_rule = __builtin__.property(_get_dns_rule, _set_dns_rule)
  latency = __builtin__.property(_get_latency, _set_latency)
  terminate_app_instance_op_config = __builtin__.property(_get_terminate_app_instance_op_config, _set_terminate_app_instance_op_config)
  change_app_instance_state_op_config = __builtin__.property(_get_change_app_instance_state_op_config, _set_change_app_instance_state_op_config)
  user_context_transfer_capability = __builtin__.property(_get_user_context_transfer_capability, _set_user_context_transfer_capability)
  network_policy = __builtin__.property(_get_network_policy, _set_network_policy)
  artifacts = __builtin__.property(_get_artifacts, _set_artifacts)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('provider', provider), ('soft_version', soft_version), ('version', version), ('mec_version', mec_version), ('info_name', info_name), ('description', description), ('virtual_compute', virtual_compute), ('sw_image', sw_image), ('virtual_storage', virtual_storage), ('ext_cpd', ext_cpd), ('service_required', service_required), ('service_optional', service_optional), ('service_produced', service_produced), ('feature_required', feature_required), ('feature_optional', feature_optional), ('transport_dependencies', transport_dependencies), ('traffic_rule', traffic_rule), ('dns_rule', dns_rule), ('latency', latency), ('terminate_app_instance_op_config', terminate_app_instance_op_config), ('change_app_instance_state_op_config', change_app_instance_state_op_config), ('user_context_transfer_capability', user_context_transfer_capability), ('network_policy', network_policy), ('artifacts', artifacts), ])


class mec_app_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /mec-app-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: YANG module for MEC Application Descriptors based on ETSI GS MEC 010-2 V2.2.1.
  """
  __slots__ = ('_path_helper', '_extmethods', '__app_descriptor',)

  _yang_name = 'mec-app-descriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__app_descriptor = YANGDynClass(base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_app_descriptor(self):
    """
    Getter method for app_descriptor, mapped from YANG variable /app_descriptor (container)
    """
    return self.__app_descriptor
      
  def _set_app_descriptor(self, v, load=False):
    """
    Setter method for app_descriptor, mapped from YANG variable /app_descriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_app_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_app_descriptor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """app_descriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__app_descriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_app_descriptor(self):
    self.__app_descriptor = YANGDynClass(base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  app_descriptor = __builtin__.property(_get_app_descriptor, _set_app_descriptor)


  _pyangbind_elements = OrderedDict([('app_descriptor', app_descriptor), ])


