# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_virtualComputeDescId_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualComputeDescId(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/virtualComputeDescId. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifier of this VirtualComputeDesc in the VNFD
  """
  __slots__ = ('_path_helper', '_extmethods', '__value',)

  _yang_name = 'virtualComputeDescId'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'virtualComputeDescId']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualComputeDescId/value (string)

    YANG Description: Unique identifier of this VirtualComputeDesc in the VNFD
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualComputeDescId/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Unique identifier of this VirtualComputeDesc in the VNFD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('value', value), ])


class yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_logicalNode_keyValuePair(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/logicalNode/keyValuePair. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A key-value pair
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'keyValuePair'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'logicalNode', 'keyValuePair']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode/keyValuePair/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode/keyValuePair/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode/keyValuePair/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode/keyValuePair/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_logicalNode_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_logicalNode(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/logicalNode. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The logical node requirements
  """
  __slots__ = ('_path_helper', '_extmethods', '__logicalNodeId','__id','__keyValuePair',)

  _yang_name = 'logicalNode'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__logicalNodeId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logicalNodeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_logicalNode_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'logicalNode']

  def _get_logicalNodeId(self):
    """
    Getter method for logicalNodeId, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode/logicalNodeId (string)

    YANG Description: Unique identifier for these logical node requirements
    """
    return self.__logicalNodeId
      
  def _set_logicalNodeId(self, v, load=False):
    """
    Setter method for logicalNodeId, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode/logicalNodeId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logicalNodeId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logicalNodeId() directly.

    YANG Description: Unique identifier for these logical node requirements
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="logicalNodeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logicalNodeId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logicalNodeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__logicalNodeId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logicalNodeId(self):
    self.__logicalNodeId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logicalNodeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode/id (string)

    YANG Description: Unique identifier for this key-value pair
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_keyValuePair(self):
    """
    Getter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode/keyValuePair (list)

    YANG Description: A key-value pair
    """
    return self.__keyValuePair
      
  def _set_keyValuePair(self, v, load=False):
    """
    Setter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode/keyValuePair (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyValuePair is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyValuePair() directly.

    YANG Description: A key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_logicalNode_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyValuePair must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_logicalNode_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__keyValuePair = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyValuePair(self):
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_logicalNode_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  logicalNodeId = __builtin__.property(_get_logicalNodeId, _set_logicalNodeId)
  id = __builtin__.property(_get_id, _set_id)
  keyValuePair = __builtin__.property(_get_keyValuePair, _set_keyValuePair)


  _pyangbind_elements = OrderedDict([('logicalNodeId', logicalNodeId), ('id', id), ('keyValuePair', keyValuePair), ])


class yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_requestAdditionalCapabilities_keyValuePair(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/keyValuePair. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A key-value pair
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'keyValuePair'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'requestAdditionalCapabilities', 'keyValuePair']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/keyValuePair/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/keyValuePair/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/keyValuePair/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/keyValuePair/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_requestAdditionalCapabilities_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_requestAdditionalCapabilities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies requirements for additional capabilities
  """
  __slots__ = ('_path_helper', '_extmethods', '__requestedAdditionalCapabilityName','__supportMandatory','__minRequestedAdditionalCapabilityVersion','__preferredRequestedAdditionalCapabilityVersion','__id','__keyValuePair',)

  _yang_name = 'requestAdditionalCapabilities'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__requestedAdditionalCapabilityName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requestedAdditionalCapabilityName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__supportMandatory = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="supportMandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__minRequestedAdditionalCapabilityVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="minRequestedAdditionalCapabilityVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__preferredRequestedAdditionalCapabilityVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferredRequestedAdditionalCapabilityVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_requestAdditionalCapabilities_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'requestAdditionalCapabilities']

  def _get_requestedAdditionalCapabilityName(self):
    """
    Getter method for requestedAdditionalCapabilityName, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/requestedAdditionalCapabilityName (string)

    YANG Description: Specifies a requested additional capability for the VDU
    """
    return self.__requestedAdditionalCapabilityName
      
  def _set_requestedAdditionalCapabilityName(self, v, load=False):
    """
    Setter method for requestedAdditionalCapabilityName, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/requestedAdditionalCapabilityName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requestedAdditionalCapabilityName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requestedAdditionalCapabilityName() directly.

    YANG Description: Specifies a requested additional capability for the VDU
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="requestedAdditionalCapabilityName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """requestedAdditionalCapabilityName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requestedAdditionalCapabilityName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__requestedAdditionalCapabilityName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_requestedAdditionalCapabilityName(self):
    self.__requestedAdditionalCapabilityName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requestedAdditionalCapabilityName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_supportMandatory(self):
    """
    Getter method for supportMandatory, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/supportMandatory (boolean)

    YANG Description: Indicates whether the requested additional capability is mandatory for successful operation
    """
    return self.__supportMandatory
      
  def _set_supportMandatory(self, v, load=False):
    """
    Setter method for supportMandatory, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/supportMandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportMandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportMandatory() directly.

    YANG Description: Indicates whether the requested additional capability is mandatory for successful operation
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="supportMandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportMandatory must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="supportMandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__supportMandatory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportMandatory(self):
    self.__supportMandatory = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="supportMandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_minRequestedAdditionalCapabilityVersion(self):
    """
    Getter method for minRequestedAdditionalCapabilityVersion, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/minRequestedAdditionalCapabilityVersion (string)

    YANG Description: Specifies the minimum version of the requested additional capability
    """
    return self.__minRequestedAdditionalCapabilityVersion
      
  def _set_minRequestedAdditionalCapabilityVersion(self, v, load=False):
    """
    Setter method for minRequestedAdditionalCapabilityVersion, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/minRequestedAdditionalCapabilityVersion (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minRequestedAdditionalCapabilityVersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minRequestedAdditionalCapabilityVersion() directly.

    YANG Description: Specifies the minimum version of the requested additional capability
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="minRequestedAdditionalCapabilityVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minRequestedAdditionalCapabilityVersion must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="minRequestedAdditionalCapabilityVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__minRequestedAdditionalCapabilityVersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minRequestedAdditionalCapabilityVersion(self):
    self.__minRequestedAdditionalCapabilityVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="minRequestedAdditionalCapabilityVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_preferredRequestedAdditionalCapabilityVersion(self):
    """
    Getter method for preferredRequestedAdditionalCapabilityVersion, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/preferredRequestedAdditionalCapabilityVersion (string)

    YANG Description: Specifies the preferred version of the requested additional capability
    """
    return self.__preferredRequestedAdditionalCapabilityVersion
      
  def _set_preferredRequestedAdditionalCapabilityVersion(self, v, load=False):
    """
    Setter method for preferredRequestedAdditionalCapabilityVersion, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/preferredRequestedAdditionalCapabilityVersion (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferredRequestedAdditionalCapabilityVersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferredRequestedAdditionalCapabilityVersion() directly.

    YANG Description: Specifies the preferred version of the requested additional capability
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="preferredRequestedAdditionalCapabilityVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferredRequestedAdditionalCapabilityVersion must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferredRequestedAdditionalCapabilityVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__preferredRequestedAdditionalCapabilityVersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferredRequestedAdditionalCapabilityVersion(self):
    self.__preferredRequestedAdditionalCapabilityVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferredRequestedAdditionalCapabilityVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/id (string)

    YANG Description: Unique identifier for this key-value pair
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_keyValuePair(self):
    """
    Getter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/keyValuePair (list)

    YANG Description: A key-value pair
    """
    return self.__keyValuePair
      
  def _set_keyValuePair(self, v, load=False):
    """
    Setter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities/keyValuePair (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyValuePair is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyValuePair() directly.

    YANG Description: A key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_requestAdditionalCapabilities_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyValuePair must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_requestAdditionalCapabilities_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__keyValuePair = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyValuePair(self):
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_requestAdditionalCapabilities_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  requestedAdditionalCapabilityName = __builtin__.property(_get_requestedAdditionalCapabilityName, _set_requestedAdditionalCapabilityName)
  supportMandatory = __builtin__.property(_get_supportMandatory, _set_supportMandatory)
  minRequestedAdditionalCapabilityVersion = __builtin__.property(_get_minRequestedAdditionalCapabilityVersion, _set_minRequestedAdditionalCapabilityVersion)
  preferredRequestedAdditionalCapabilityVersion = __builtin__.property(_get_preferredRequestedAdditionalCapabilityVersion, _set_preferredRequestedAdditionalCapabilityVersion)
  id = __builtin__.property(_get_id, _set_id)
  keyValuePair = __builtin__.property(_get_keyValuePair, _set_keyValuePair)


  _pyangbind_elements = OrderedDict([('requestedAdditionalCapabilityName', requestedAdditionalCapabilityName), ('supportMandatory', supportMandatory), ('minRequestedAdditionalCapabilityVersion', minRequestedAdditionalCapabilityVersion), ('preferredRequestedAdditionalCapabilityVersion', preferredRequestedAdditionalCapabilityVersion), ('id', id), ('keyValuePair', keyValuePair), ])


class yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_computeRequirements_keyValuePair(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/keyValuePair. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A key-value pair
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'keyValuePair'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'computeRequirements', 'keyValuePair']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/keyValuePair/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/keyValuePair/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/keyValuePair/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/keyValuePair/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_computeRequirements_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_computeRequirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/computeRequirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies compute requirements
  """
  __slots__ = ('_path_helper', '_extmethods', '__computeReqId','__id','__keyValuePair',)

  _yang_name = 'computeRequirements'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__computeReqId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="computeReqId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_computeRequirements_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'computeRequirements']

  def _get_computeReqId(self):
    """
    Getter method for computeReqId, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/computeReqId (string)

    YANG Description: Unique identifier for these compute requirements
    """
    return self.__computeReqId
      
  def _set_computeReqId(self, v, load=False):
    """
    Setter method for computeReqId, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/computeReqId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_computeReqId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_computeReqId() directly.

    YANG Description: Unique identifier for these compute requirements
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="computeReqId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """computeReqId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="computeReqId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__computeReqId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_computeReqId(self):
    self.__computeReqId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="computeReqId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/id (string)

    YANG Description: Unique identifier for this key-value pair
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_keyValuePair(self):
    """
    Getter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/keyValuePair (list)

    YANG Description: A key-value pair
    """
    return self.__keyValuePair
      
  def _set_keyValuePair(self, v, load=False):
    """
    Setter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements/keyValuePair (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyValuePair is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyValuePair() directly.

    YANG Description: A key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_computeRequirements_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyValuePair must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_computeRequirements_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__keyValuePair = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyValuePair(self):
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_computeRequirements_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  computeReqId = __builtin__.property(_get_computeReqId, _set_computeReqId)
  id = __builtin__.property(_get_id, _set_id)
  keyValuePair = __builtin__.property(_get_keyValuePair, _set_keyValuePair)


  _pyangbind_elements = OrderedDict([('computeReqId', computeReqId), ('id', id), ('keyValuePair', keyValuePair), ])


class yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualMemory_keyValuePair(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/keyValuePair. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A key-value pair
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'keyValuePair'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'virtualMemory', 'keyValuePair']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/keyValuePair/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/keyValuePair/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/keyValuePair/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/keyValuePair/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_virtualMemory_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualMemory(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/virtualMemory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual memory of the virtualised compute
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtualMemSize','__virtualMemOversubscriptionPolicy','__id','__keyValuePair','__numaEnabled',)

  _yang_name = 'virtualMemory'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtualMemSize = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="virtualMemSize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__virtualMemOversubscriptionPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtualMemOversubscriptionPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualMemory_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__numaEnabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numaEnabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'virtualMemory']

  def _get_virtualMemSize(self):
    """
    Getter method for virtualMemSize, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/virtualMemSize (uint64)

    YANG Description: Amount of virtual Memory (e.g. in MB)
    """
    return self.__virtualMemSize
      
  def _set_virtualMemSize(self, v, load=False):
    """
    Setter method for virtualMemSize, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/virtualMemSize (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualMemSize is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualMemSize() directly.

    YANG Description: Amount of virtual Memory (e.g. in MB)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="virtualMemSize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualMemSize must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="virtualMemSize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__virtualMemSize = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualMemSize(self):
    self.__virtualMemSize = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="virtualMemSize", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_virtualMemOversubscriptionPolicy(self):
    """
    Getter method for virtualMemOversubscriptionPolicy, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/virtualMemOversubscriptionPolicy (string)

    YANG Description: The memory core oversubscription policy in terms of virtual memory to physical memory on the platform
    """
    return self.__virtualMemOversubscriptionPolicy
      
  def _set_virtualMemOversubscriptionPolicy(self, v, load=False):
    """
    Setter method for virtualMemOversubscriptionPolicy, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/virtualMemOversubscriptionPolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualMemOversubscriptionPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualMemOversubscriptionPolicy() directly.

    YANG Description: The memory core oversubscription policy in terms of virtual memory to physical memory on the platform
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="virtualMemOversubscriptionPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualMemOversubscriptionPolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtualMemOversubscriptionPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__virtualMemOversubscriptionPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualMemOversubscriptionPolicy(self):
    self.__virtualMemOversubscriptionPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtualMemOversubscriptionPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/id (string)

    YANG Description: Unique identifier for this key-value pair
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_keyValuePair(self):
    """
    Getter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/keyValuePair (list)

    YANG Description: A key-value pair
    """
    return self.__keyValuePair
      
  def _set_keyValuePair(self, v, load=False):
    """
    Setter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/keyValuePair (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyValuePair is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyValuePair() directly.

    YANG Description: A key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualMemory_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyValuePair must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualMemory_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__keyValuePair = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyValuePair(self):
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualMemory_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_numaEnabled(self):
    """
    Getter method for numaEnabled, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/numaEnabled (boolean)

    YANG Description: It specifies the memory allocation to be cognisant of the relevant process/core allocation
    """
    return self.__numaEnabled
      
  def _set_numaEnabled(self, v, load=False):
    """
    Setter method for numaEnabled, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory/numaEnabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numaEnabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numaEnabled() directly.

    YANG Description: It specifies the memory allocation to be cognisant of the relevant process/core allocation
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="numaEnabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numaEnabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numaEnabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__numaEnabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numaEnabled(self):
    self.__numaEnabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numaEnabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

  virtualMemSize = __builtin__.property(_get_virtualMemSize, _set_virtualMemSize)
  virtualMemOversubscriptionPolicy = __builtin__.property(_get_virtualMemOversubscriptionPolicy, _set_virtualMemOversubscriptionPolicy)
  id = __builtin__.property(_get_id, _set_id)
  keyValuePair = __builtin__.property(_get_keyValuePair, _set_keyValuePair)
  numaEnabled = __builtin__.property(_get_numaEnabled, _set_numaEnabled)


  _pyangbind_elements = OrderedDict([('virtualMemSize', virtualMemSize), ('virtualMemOversubscriptionPolicy', virtualMemOversubscriptionPolicy), ('id', id), ('keyValuePair', keyValuePair), ('numaEnabled', numaEnabled), ])


class yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_keyValuePair(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/keyValuePair. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A key-value pair
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'keyValuePair'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'virtualCpu', 'keyValuePair']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/keyValuePair/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/keyValuePair/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/keyValuePair/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/keyValuePair/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_virtualCpuPinningRule_keyValuePair(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule/keyValuePair. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A key-value pair
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'keyValuePair'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'virtualCpu', 'virtualCpuPinningRule', 'keyValuePair']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule/keyValuePair/key (string)

    YANG Description: Key in the key-value pair
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule/keyValuePair/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key in the key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule/keyValuePair/value (string)

    YANG Description: Value in the key-value pair
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule/keyValuePair/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value in the key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_virtualCpuPinningRule_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_virtualCpuPinningRule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of rules that should be considered during the allocation of the virtual CPUs to logical CPUs in case of 'STATIC' virtualCpuPinningPolicy
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__keyValuePair',)

  _yang_name = 'virtualCpuPinningRule'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_virtualCpuPinningRule_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'virtualCpu', 'virtualCpuPinningRule']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule/id (string)

    YANG Description: Unique identifier for this key-value pair
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this key-value pair
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_keyValuePair(self):
    """
    Getter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule/keyValuePair (list)

    YANG Description: A key-value pair
    """
    return self.__keyValuePair
      
  def _set_keyValuePair(self, v, load=False):
    """
    Setter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule/keyValuePair (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyValuePair is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyValuePair() directly.

    YANG Description: A key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_virtualCpuPinningRule_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyValuePair must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_virtualCpuPinningRule_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__keyValuePair = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyValuePair(self):
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_virtualCpuPinningRule_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  keyValuePair = __builtin__.property(_get_keyValuePair, _set_keyValuePair)


  _pyangbind_elements = OrderedDict([('id', id), ('keyValuePair', keyValuePair), ])


class yc_virtualCpu_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/virtualCpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual CPU(s) of the virtualised compute
  """
  __slots__ = ('_path_helper', '_extmethods', '__cpuArchitecture','__numVirtualCpu','__virtualCpuClock','__virtualCpuOversubscriptionPolicy','__id','__keyValuePair','__virtualCpuPinningPolicy','__virtualCpuPinningRule',)

  _yang_name = 'virtualCpu'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cpuArchitecture = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpuArchitecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__numVirtualCpu = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="numVirtualCpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint16', is_config=True)
    self.__virtualCpuClock = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="virtualCpuClock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__virtualCpuOversubscriptionPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtualCpuOversubscriptionPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__virtualCpuPinningPolicy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="virtualCpuPinningPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__virtualCpuPinningRule = YANGDynClass(base=YANGListType("id",yc_virtualCpuPinningRule_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_virtualCpuPinningRule, yang_name="virtualCpuPinningRule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualCpuPinningRule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'virtualCpu']

  def _get_cpuArchitecture(self):
    """
    Getter method for cpuArchitecture, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/cpuArchitecture (string)

    YANG Description: CPU architecture type. Examples are x86, ARM
    """
    return self.__cpuArchitecture
      
  def _set_cpuArchitecture(self, v, load=False):
    """
    Setter method for cpuArchitecture, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/cpuArchitecture (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpuArchitecture is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpuArchitecture() directly.

    YANG Description: CPU architecture type. Examples are x86, ARM
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cpuArchitecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpuArchitecture must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpuArchitecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__cpuArchitecture = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpuArchitecture(self):
    self.__cpuArchitecture = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpuArchitecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_numVirtualCpu(self):
    """
    Getter method for numVirtualCpu, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/numVirtualCpu (uint16)

    YANG Description: Number of virtual CPUs
    """
    return self.__numVirtualCpu
      
  def _set_numVirtualCpu(self, v, load=False):
    """
    Setter method for numVirtualCpu, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/numVirtualCpu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numVirtualCpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numVirtualCpu() directly.

    YANG Description: Number of virtual CPUs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="numVirtualCpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numVirtualCpu must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="numVirtualCpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint16', is_config=True)""",
        })

    self.__numVirtualCpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numVirtualCpu(self):
    self.__numVirtualCpu = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="numVirtualCpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint16', is_config=True)


  def _get_virtualCpuClock(self):
    """
    Getter method for virtualCpuClock, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuClock (uint64)

    YANG Description: Minimum virtual CPU clock rate (e.g. in MHz)
    """
    return self.__virtualCpuClock
      
  def _set_virtualCpuClock(self, v, load=False):
    """
    Setter method for virtualCpuClock, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuClock (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualCpuClock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualCpuClock() directly.

    YANG Description: Minimum virtual CPU clock rate (e.g. in MHz)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="virtualCpuClock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualCpuClock must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="virtualCpuClock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__virtualCpuClock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualCpuClock(self):
    self.__virtualCpuClock = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="virtualCpuClock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_virtualCpuOversubscriptionPolicy(self):
    """
    Getter method for virtualCpuOversubscriptionPolicy, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuOversubscriptionPolicy (string)

    YANG Description: The CPU core oversubscription policy e.g. the relation of virtual CPU cores to physical CPU cores/threads
    """
    return self.__virtualCpuOversubscriptionPolicy
      
  def _set_virtualCpuOversubscriptionPolicy(self, v, load=False):
    """
    Setter method for virtualCpuOversubscriptionPolicy, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuOversubscriptionPolicy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualCpuOversubscriptionPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualCpuOversubscriptionPolicy() directly.

    YANG Description: The CPU core oversubscription policy e.g. the relation of virtual CPU cores to physical CPU cores/threads
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="virtualCpuOversubscriptionPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualCpuOversubscriptionPolicy must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtualCpuOversubscriptionPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__virtualCpuOversubscriptionPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualCpuOversubscriptionPolicy(self):
    self.__virtualCpuOversubscriptionPolicy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtualCpuOversubscriptionPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/id (string)

    YANG Description: Unique identifier for this key-value pair
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_keyValuePair(self):
    """
    Getter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/keyValuePair (list)

    YANG Description: A key-value pair
    """
    return self.__keyValuePair
      
  def _set_keyValuePair(self, v, load=False):
    """
    Setter method for keyValuePair, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/keyValuePair (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keyValuePair is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keyValuePair() directly.

    YANG Description: A key-value pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keyValuePair must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__keyValuePair = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keyValuePair(self):
    self.__keyValuePair = YANGDynClass(base=YANGListType("key",yc_keyValuePair_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_keyValuePair, yang_name="keyValuePair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="keyValuePair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_virtualCpuPinningPolicy(self):
    """
    Getter method for virtualCpuPinningPolicy, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningPolicy (enumeration)

    YANG Description: Indicates the policy for CPU pinning
    """
    return self.__virtualCpuPinningPolicy
      
  def _set_virtualCpuPinningPolicy(self, v, load=False):
    """
    Setter method for virtualCpuPinningPolicy, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningPolicy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualCpuPinningPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualCpuPinningPolicy() directly.

    YANG Description: Indicates the policy for CPU pinning
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="virtualCpuPinningPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualCpuPinningPolicy must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="virtualCpuPinningPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__virtualCpuPinningPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualCpuPinningPolicy(self):
    self.__virtualCpuPinningPolicy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STATIC': {}, 'DYNAMIC': {}},), is_leaf=True, yang_name="virtualCpuPinningPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_virtualCpuPinningRule(self):
    """
    Getter method for virtualCpuPinningRule, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule (list)

    YANG Description: List of rules that should be considered during the allocation of the virtual CPUs to logical CPUs in case of 'STATIC' virtualCpuPinningPolicy
    """
    return self.__virtualCpuPinningRule
      
  def _set_virtualCpuPinningRule(self, v, load=False):
    """
    Setter method for virtualCpuPinningRule, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu/virtualCpuPinningRule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualCpuPinningRule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualCpuPinningRule() directly.

    YANG Description: List of rules that should be considered during the allocation of the virtual CPUs to logical CPUs in case of 'STATIC' virtualCpuPinningPolicy
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_virtualCpuPinningRule_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_virtualCpuPinningRule, yang_name="virtualCpuPinningRule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualCpuPinningRule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualCpuPinningRule must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtualCpuPinningRule_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_virtualCpuPinningRule, yang_name="virtualCpuPinningRule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualCpuPinningRule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__virtualCpuPinningRule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualCpuPinningRule(self):
    self.__virtualCpuPinningRule = YANGDynClass(base=YANGListType("id",yc_virtualCpuPinningRule_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu_virtualCpuPinningRule, yang_name="virtualCpuPinningRule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualCpuPinningRule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  cpuArchitecture = __builtin__.property(_get_cpuArchitecture, _set_cpuArchitecture)
  numVirtualCpu = __builtin__.property(_get_numVirtualCpu, _set_numVirtualCpu)
  virtualCpuClock = __builtin__.property(_get_virtualCpuClock, _set_virtualCpuClock)
  virtualCpuOversubscriptionPolicy = __builtin__.property(_get_virtualCpuOversubscriptionPolicy, _set_virtualCpuOversubscriptionPolicy)
  id = __builtin__.property(_get_id, _set_id)
  keyValuePair = __builtin__.property(_get_keyValuePair, _set_keyValuePair)
  virtualCpuPinningPolicy = __builtin__.property(_get_virtualCpuPinningPolicy, _set_virtualCpuPinningPolicy)
  virtualCpuPinningRule = __builtin__.property(_get_virtualCpuPinningRule, _set_virtualCpuPinningRule)


  _pyangbind_elements = OrderedDict([('cpuArchitecture', cpuArchitecture), ('numVirtualCpu', numVirtualCpu), ('virtualCpuClock', virtualCpuClock), ('virtualCpuOversubscriptionPolicy', virtualCpuOversubscriptionPolicy), ('id', id), ('keyValuePair', keyValuePair), ('virtualCpuPinningPolicy', virtualCpuPinningPolicy), ('virtualCpuPinningRule', virtualCpuPinningRule), ])


class yc_virtualDisk_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualDisk(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute/virtualDisk. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The local or ephemeral disk(s) of the virtualised compute
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__hostingProvidesIops','__guaranteedIops','__maxIops',)

  _yang_name = 'virtualDisk'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__hostingProvidesIops = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hostingProvidesIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__guaranteedIops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteedIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__maxIops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute', 'virtualDisk']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualDisk/id (string)

    YANG Description: Unique identifier for this block storage data
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualDisk/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this block storage data
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_hostingProvidesIops(self):
    """
    Getter method for hostingProvidesIops, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualDisk/hostingProvidesIops (boolean)

    YANG Description: If set to true, the NFVI provides dedicated IOPS (I/O operations per second) to the virtualised block storage resource
    """
    return self.__hostingProvidesIops
      
  def _set_hostingProvidesIops(self, v, load=False):
    """
    Setter method for hostingProvidesIops, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualDisk/hostingProvidesIops (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostingProvidesIops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostingProvidesIops() directly.

    YANG Description: If set to true, the NFVI provides dedicated IOPS (I/O operations per second) to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hostingProvidesIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostingProvidesIops must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hostingProvidesIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__hostingProvidesIops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostingProvidesIops(self):
    self.__hostingProvidesIops = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hostingProvidesIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_guaranteedIops(self):
    """
    Getter method for guaranteedIops, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualDisk/guaranteedIops (uint64)

    YANG Description: Minimum IOPS that the NFVI provides to the virtualised block storage resource
    """
    return self.__guaranteedIops
      
  def _set_guaranteedIops(self, v, load=False):
    """
    Setter method for guaranteedIops, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualDisk/guaranteedIops (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_guaranteedIops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_guaranteedIops() directly.

    YANG Description: Minimum IOPS that the NFVI provides to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteedIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """guaranteedIops must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteedIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__guaranteedIops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_guaranteedIops(self):
    self.__guaranteedIops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteedIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_maxIops(self):
    """
    Getter method for maxIops, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualDisk/maxIops (uint64)

    YANG Description: Maximum IOPS that the NFVI provides to the virtualised block storage resource
    """
    return self.__maxIops
      
  def _set_maxIops(self, v, load=False):
    """
    Setter method for maxIops, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualDisk/maxIops (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxIops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxIops() directly.

    YANG Description: Maximum IOPS that the NFVI provides to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxIops must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__maxIops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxIops(self):
    self.__maxIops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  hostingProvidesIops = __builtin__.property(_get_hostingProvidesIops, _set_hostingProvidesIops)
  guaranteedIops = __builtin__.property(_get_guaranteedIops, _set_guaranteedIops)
  maxIops = __builtin__.property(_get_maxIops, _set_maxIops)


  _pyangbind_elements = OrderedDict([('id', id), ('hostingProvidesIops', hostingProvidesIops), ('guaranteedIops', guaranteedIops), ('maxIops', maxIops), ])


class yc_virtualCompute_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc/virtualCompute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__virtualComputeDescId','__logicalNode','__requestAdditionalCapabilities','__computeRequirements','__virtualMemory','__virtualCpu','__virtualDisk',)

  _yang_name = 'virtualCompute'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__virtualComputeDescId = YANGDynClass(base=yc_virtualComputeDescId_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualComputeDescId, is_container='container', yang_name="virtualComputeDescId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__logicalNode = YANGDynClass(base=YANGListType("logicalNodeId",yc_logicalNode_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_logicalNode, yang_name="logicalNode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='logicalNodeId', extensions=None), is_container='list', yang_name="logicalNode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__requestAdditionalCapabilities = YANGDynClass(base=YANGListType("requestedAdditionalCapabilityName",yc_requestAdditionalCapabilities_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_requestAdditionalCapabilities, yang_name="requestAdditionalCapabilities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='requestedAdditionalCapabilityName', extensions=None), is_container='list', yang_name="requestAdditionalCapabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__computeRequirements = YANGDynClass(base=YANGListType("computeReqId",yc_computeRequirements_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_computeRequirements, yang_name="computeRequirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='computeReqId', extensions=None), is_container='list', yang_name="computeRequirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__virtualMemory = YANGDynClass(base=yc_virtualMemory_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualMemory, is_container='container', yang_name="virtualMemory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__virtualCpu = YANGDynClass(base=yc_virtualCpu_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu, is_container='container', yang_name="virtualCpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__virtualDisk = YANGDynClass(base=YANGListType("id",yc_virtualDisk_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualDisk, yang_name="virtualDisk", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualDisk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc', 'virtualCompute']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/id (string)

    YANG Description: Unique identifier for this VirtualComputeDesc
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this VirtualComputeDesc
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_virtualComputeDescId(self):
    """
    Getter method for virtualComputeDescId, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualComputeDescId (container)

    YANG Description: Identifier of this VirtualComputeDesc in the VNFD
    """
    return self.__virtualComputeDescId
      
  def _set_virtualComputeDescId(self, v, load=False):
    """
    Setter method for virtualComputeDescId, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualComputeDescId (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualComputeDescId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualComputeDescId() directly.

    YANG Description: Identifier of this VirtualComputeDesc in the VNFD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_virtualComputeDescId_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualComputeDescId, is_container='container', yang_name="virtualComputeDescId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualComputeDescId must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_virtualComputeDescId_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualComputeDescId, is_container='container', yang_name="virtualComputeDescId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__virtualComputeDescId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualComputeDescId(self):
    self.__virtualComputeDescId = YANGDynClass(base=yc_virtualComputeDescId_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualComputeDescId, is_container='container', yang_name="virtualComputeDescId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_logicalNode(self):
    """
    Getter method for logicalNode, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode (list)

    YANG Description: The logical node requirements
    """
    return self.__logicalNode
      
  def _set_logicalNode(self, v, load=False):
    """
    Setter method for logicalNode, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/logicalNode (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logicalNode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logicalNode() directly.

    YANG Description: The logical node requirements
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("logicalNodeId",yc_logicalNode_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_logicalNode, yang_name="logicalNode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='logicalNodeId', extensions=None), is_container='list', yang_name="logicalNode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logicalNode must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("logicalNodeId",yc_logicalNode_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_logicalNode, yang_name="logicalNode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='logicalNodeId', extensions=None), is_container='list', yang_name="logicalNode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__logicalNode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logicalNode(self):
    self.__logicalNode = YANGDynClass(base=YANGListType("logicalNodeId",yc_logicalNode_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_logicalNode, yang_name="logicalNode", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='logicalNodeId', extensions=None), is_container='list', yang_name="logicalNode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_requestAdditionalCapabilities(self):
    """
    Getter method for requestAdditionalCapabilities, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities (list)

    YANG Description: Specifies requirements for additional capabilities
    """
    return self.__requestAdditionalCapabilities
      
  def _set_requestAdditionalCapabilities(self, v, load=False):
    """
    Setter method for requestAdditionalCapabilities, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/requestAdditionalCapabilities (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requestAdditionalCapabilities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requestAdditionalCapabilities() directly.

    YANG Description: Specifies requirements for additional capabilities
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("requestedAdditionalCapabilityName",yc_requestAdditionalCapabilities_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_requestAdditionalCapabilities, yang_name="requestAdditionalCapabilities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='requestedAdditionalCapabilityName', extensions=None), is_container='list', yang_name="requestAdditionalCapabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """requestAdditionalCapabilities must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("requestedAdditionalCapabilityName",yc_requestAdditionalCapabilities_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_requestAdditionalCapabilities, yang_name="requestAdditionalCapabilities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='requestedAdditionalCapabilityName', extensions=None), is_container='list', yang_name="requestAdditionalCapabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__requestAdditionalCapabilities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_requestAdditionalCapabilities(self):
    self.__requestAdditionalCapabilities = YANGDynClass(base=YANGListType("requestedAdditionalCapabilityName",yc_requestAdditionalCapabilities_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_requestAdditionalCapabilities, yang_name="requestAdditionalCapabilities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='requestedAdditionalCapabilityName', extensions=None), is_container='list', yang_name="requestAdditionalCapabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_computeRequirements(self):
    """
    Getter method for computeRequirements, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements (list)

    YANG Description: Specifies compute requirements
    """
    return self.__computeRequirements
      
  def _set_computeRequirements(self, v, load=False):
    """
    Setter method for computeRequirements, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/computeRequirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_computeRequirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_computeRequirements() directly.

    YANG Description: Specifies compute requirements
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("computeReqId",yc_computeRequirements_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_computeRequirements, yang_name="computeRequirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='computeReqId', extensions=None), is_container='list', yang_name="computeRequirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """computeRequirements must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("computeReqId",yc_computeRequirements_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_computeRequirements, yang_name="computeRequirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='computeReqId', extensions=None), is_container='list', yang_name="computeRequirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__computeRequirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_computeRequirements(self):
    self.__computeRequirements = YANGDynClass(base=YANGListType("computeReqId",yc_computeRequirements_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_computeRequirements, yang_name="computeRequirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='computeReqId', extensions=None), is_container='list', yang_name="computeRequirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_virtualMemory(self):
    """
    Getter method for virtualMemory, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory (container)

    YANG Description: The virtual memory of the virtualised compute
    """
    return self.__virtualMemory
      
  def _set_virtualMemory(self, v, load=False):
    """
    Setter method for virtualMemory, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualMemory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualMemory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualMemory() directly.

    YANG Description: The virtual memory of the virtualised compute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_virtualMemory_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualMemory, is_container='container', yang_name="virtualMemory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualMemory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_virtualMemory_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualMemory, is_container='container', yang_name="virtualMemory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__virtualMemory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualMemory(self):
    self.__virtualMemory = YANGDynClass(base=yc_virtualMemory_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualMemory, is_container='container', yang_name="virtualMemory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_virtualCpu(self):
    """
    Getter method for virtualCpu, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu (container)

    YANG Description: The virtual CPU(s) of the virtualised compute
    """
    return self.__virtualCpu
      
  def _set_virtualCpu(self, v, load=False):
    """
    Setter method for virtualCpu, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualCpu (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualCpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualCpu() directly.

    YANG Description: The virtual CPU(s) of the virtualised compute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_virtualCpu_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu, is_container='container', yang_name="virtualCpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualCpu must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_virtualCpu_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu, is_container='container', yang_name="virtualCpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__virtualCpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualCpu(self):
    self.__virtualCpu = YANGDynClass(base=yc_virtualCpu_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualCpu, is_container='container', yang_name="virtualCpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_virtualDisk(self):
    """
    Getter method for virtualDisk, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualDisk (list)

    YANG Description: The local or ephemeral disk(s) of the virtualised compute
    """
    return self.__virtualDisk
      
  def _set_virtualDisk(self, v, load=False):
    """
    Setter method for virtualDisk, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute/virtualDisk (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualDisk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualDisk() directly.

    YANG Description: The local or ephemeral disk(s) of the virtualised compute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_virtualDisk_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualDisk, yang_name="virtualDisk", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualDisk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualDisk must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtualDisk_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualDisk, yang_name="virtualDisk", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualDisk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__virtualDisk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualDisk(self):
    self.__virtualDisk = YANGDynClass(base=YANGListType("id",yc_virtualDisk_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute_virtualDisk, yang_name="virtualDisk", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualDisk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  virtualComputeDescId = __builtin__.property(_get_virtualComputeDescId, _set_virtualComputeDescId)
  logicalNode = __builtin__.property(_get_logicalNode, _set_logicalNode)
  requestAdditionalCapabilities = __builtin__.property(_get_requestAdditionalCapabilities, _set_requestAdditionalCapabilities)
  computeRequirements = __builtin__.property(_get_computeRequirements, _set_computeRequirements)
  virtualMemory = __builtin__.property(_get_virtualMemory, _set_virtualMemory)
  virtualCpu = __builtin__.property(_get_virtualCpu, _set_virtualCpu)
  virtualDisk = __builtin__.property(_get_virtualDisk, _set_virtualDisk)


  _pyangbind_elements = OrderedDict([('id', id), ('virtualComputeDescId', virtualComputeDescId), ('logicalNode', logicalNode), ('requestAdditionalCapabilities', requestAdditionalCapabilities), ('computeRequirements', computeRequirements), ('virtualMemory', virtualMemory), ('virtualCpu', virtualCpu), ('virtualDisk', virtualDisk), ])


class yc_VirtualComputeDesc_mec_app_descriptor__app_descriptor_VirtualComputeDesc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualComputeDesc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates Virtual Compute Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtualCompute',)

  _yang_name = 'VirtualComputeDesc'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtualCompute = YANGDynClass(base=YANGListType("id",yc_virtualCompute_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute, yang_name="virtualCompute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualCompute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualComputeDesc']

  def _get_virtualCompute(self):
    """
    Getter method for virtualCompute, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute (list)
    """
    return self.__virtualCompute
      
  def _set_virtualCompute(self, v, load=False):
    """
    Setter method for virtualCompute, mapped from YANG variable /app_descriptor/VirtualComputeDesc/virtualCompute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualCompute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualCompute() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_virtualCompute_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute, yang_name="virtualCompute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualCompute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualCompute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtualCompute_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute, yang_name="virtualCompute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualCompute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__virtualCompute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualCompute(self):
    self.__virtualCompute = YANGDynClass(base=YANGListType("id",yc_virtualCompute_mec_app_descriptor__app_descriptor_VirtualComputeDesc_virtualCompute, yang_name="virtualCompute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualCompute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  virtualCompute = __builtin__.property(_get_virtualCompute, _set_virtualCompute)


  _pyangbind_elements = OrderedDict([('virtualCompute', virtualCompute), ])


class yc_sw_image_descriptor_mec_app_descriptor__app_descriptor_SwImageDescriptor_sw_image_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/SwImageDescriptor/sw-image-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for software image descriptor attributes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__version','__checksum','__containerFormat','__diskFormat','__minDisk','__minRam','__size','__swImage','__operatingSystem','__supportedVirtualisationEnvironment',)

  _yang_name = 'sw-image-descriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__containerFormat = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="containerFormat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__diskFormat = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="diskFormat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__minDisk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="minDisk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__minRam = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="minRam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__swImage = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="swImage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__operatingSystem = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operatingSystem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__supportedVirtualisationEnvironment = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supportedVirtualisationEnvironment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'SwImageDescriptor', 'sw-image-descriptor']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/id (string)

    YANG Description: The identifier of this software image.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The identifier of this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/name (string)

    YANG Description: The name of this software image.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/version (string)

    YANG Description: The version of this software image.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_checksum(self):
    """
    Getter method for checksum, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/checksum (string)

    YANG Description: The checksum of the software image file.
    """
    return self.__checksum
      
  def _set_checksum(self, v, load=False):
    """
    Setter method for checksum, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checksum() directly.

    YANG Description: The checksum of the software image file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checksum(self):
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_containerFormat(self):
    """
    Getter method for containerFormat, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/containerFormat (string)

    YANG Description: The container format describes the container file format in which software image is provided.
    """
    return self.__containerFormat
      
  def _set_containerFormat(self, v, load=False):
    """
    Setter method for containerFormat, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/containerFormat (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_containerFormat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_containerFormat() directly.

    YANG Description: The container format describes the container file format in which software image is provided.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="containerFormat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """containerFormat must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="containerFormat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__containerFormat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_containerFormat(self):
    self.__containerFormat = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="containerFormat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_diskFormat(self):
    """
    Getter method for diskFormat, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/diskFormat (string)

    YANG Description: The disk format of a software image is the format of the underlying disk image.
    """
    return self.__diskFormat
      
  def _set_diskFormat(self, v, load=False):
    """
    Setter method for diskFormat, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/diskFormat (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_diskFormat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_diskFormat() directly.

    YANG Description: The disk format of a software image is the format of the underlying disk image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="diskFormat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """diskFormat must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="diskFormat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__diskFormat = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_diskFormat(self):
    self.__diskFormat = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="diskFormat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_minDisk(self):
    """
    Getter method for minDisk, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/minDisk (uint64)

    YANG Description: The minimal disk size requirement for this software image.
    """
    return self.__minDisk
      
  def _set_minDisk(self, v, load=False):
    """
    Setter method for minDisk, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/minDisk (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minDisk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minDisk() directly.

    YANG Description: The minimal disk size requirement for this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="minDisk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minDisk must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="minDisk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__minDisk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minDisk(self):
    self.__minDisk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="minDisk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_minRam(self):
    """
    Getter method for minRam, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/minRam (uint64)

    YANG Description: The minimal RAM requirement for this software image.
    """
    return self.__minRam
      
  def _set_minRam(self, v, load=False):
    """
    Setter method for minRam, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/minRam (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minRam is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minRam() directly.

    YANG Description: The minimal RAM requirement for this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="minRam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minRam must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="minRam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__minRam = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minRam(self):
    self.__minRam = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="minRam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_size(self):
    """
    Getter method for size, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/size (uint64)

    YANG Description: The size of this software image file.
    """
    return self.__size
      
  def _set_size(self, v, load=False):
    """
    Setter method for size, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/size (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: The size of this software image file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size(self):
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_swImage(self):
    """
    Getter method for swImage, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/swImage (string)

    YANG Description: This is a reference to the actual software image.
    """
    return self.__swImage
      
  def _set_swImage(self, v, load=False):
    """
    Setter method for swImage, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/swImage (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_swImage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_swImage() directly.

    YANG Description: This is a reference to the actual software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="swImage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """swImage must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="swImage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__swImage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_swImage(self):
    self.__swImage = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="swImage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_operatingSystem(self):
    """
    Getter method for operatingSystem, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/operatingSystem (string)

    YANG Description: Specifies the operating system used in the software image.
    """
    return self.__operatingSystem
      
  def _set_operatingSystem(self, v, load=False):
    """
    Setter method for operatingSystem, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/operatingSystem (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operatingSystem is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operatingSystem() directly.

    YANG Description: Specifies the operating system used in the software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="operatingSystem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operatingSystem must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operatingSystem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__operatingSystem = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operatingSystem(self):
    self.__operatingSystem = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operatingSystem", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_supportedVirtualisationEnvironment(self):
    """
    Getter method for supportedVirtualisationEnvironment, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/supportedVirtualisationEnvironment (string)

    YANG Description: Specifies the virtualisation environments compatible with this software image.
    """
    return self.__supportedVirtualisationEnvironment
      
  def _set_supportedVirtualisationEnvironment(self, v, load=False):
    """
    Setter method for supportedVirtualisationEnvironment, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor/supportedVirtualisationEnvironment (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportedVirtualisationEnvironment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportedVirtualisationEnvironment() directly.

    YANG Description: Specifies the virtualisation environments compatible with this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supportedVirtualisationEnvironment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportedVirtualisationEnvironment must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supportedVirtualisationEnvironment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__supportedVirtualisationEnvironment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportedVirtualisationEnvironment(self):
    self.__supportedVirtualisationEnvironment = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supportedVirtualisationEnvironment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  checksum = __builtin__.property(_get_checksum, _set_checksum)
  containerFormat = __builtin__.property(_get_containerFormat, _set_containerFormat)
  diskFormat = __builtin__.property(_get_diskFormat, _set_diskFormat)
  minDisk = __builtin__.property(_get_minDisk, _set_minDisk)
  minRam = __builtin__.property(_get_minRam, _set_minRam)
  size = __builtin__.property(_get_size, _set_size)
  swImage = __builtin__.property(_get_swImage, _set_swImage)
  operatingSystem = __builtin__.property(_get_operatingSystem, _set_operatingSystem)
  supportedVirtualisationEnvironment = __builtin__.property(_get_supportedVirtualisationEnvironment, _set_supportedVirtualisationEnvironment)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('checksum', checksum), ('containerFormat', containerFormat), ('diskFormat', diskFormat), ('minDisk', minDisk), ('minRam', minRam), ('size', size), ('swImage', swImage), ('operatingSystem', operatingSystem), ('supportedVirtualisationEnvironment', supportedVirtualisationEnvironment), ])


class yc_SwImageDescriptor_mec_app_descriptor__app_descriptor_SwImageDescriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/SwImageDescriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Software Image Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__sw_image_descriptor',)

  _yang_name = 'SwImageDescriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sw_image_descriptor = YANGDynClass(base=yc_sw_image_descriptor_mec_app_descriptor__app_descriptor_SwImageDescriptor_sw_image_descriptor, is_container='container', yang_name="sw-image-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'SwImageDescriptor']

  def _get_sw_image_descriptor(self):
    """
    Getter method for sw_image_descriptor, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor (container)

    YANG Description: Container for software image descriptor attributes.
    """
    return self.__sw_image_descriptor
      
  def _set_sw_image_descriptor(self, v, load=False):
    """
    Setter method for sw_image_descriptor, mapped from YANG variable /app_descriptor/SwImageDescriptor/sw_image_descriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image_descriptor() directly.

    YANG Description: Container for software image descriptor attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sw_image_descriptor_mec_app_descriptor__app_descriptor_SwImageDescriptor_sw_image_descriptor, is_container='container', yang_name="sw-image-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sw_image_descriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sw_image_descriptor_mec_app_descriptor__app_descriptor_SwImageDescriptor_sw_image_descriptor, is_container='container', yang_name="sw-image-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__sw_image_descriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sw_image_descriptor(self):
    self.__sw_image_descriptor = YANGDynClass(base=yc_sw_image_descriptor_mec_app_descriptor__app_descriptor_SwImageDescriptor_sw_image_descriptor, is_container='container', yang_name="sw-image-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  sw_image_descriptor = __builtin__.property(_get_sw_image_descriptor, _set_sw_image_descriptor)


  _pyangbind_elements = OrderedDict([('sw_image_descriptor', sw_image_descriptor), ])


class yc_virtualStorageDescId_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_virtualStorageDescId(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualStorageDesc/virtualStorage/virtualStorageDescId. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifier of this VirtualStorageDesc in the VNFD
  """
  __slots__ = ('_path_helper', '_extmethods', '__value',)

  _yang_name = 'virtualStorageDescId'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualStorageDesc', 'virtualStorage', 'virtualStorageDescId']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/virtualStorageDescId/value (string)

    YANG Description: Unique identifier of this VirtualStorageDesc in the VNFD
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/virtualStorageDescId/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Unique identifier of this VirtualStorageDesc in the VNFD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('value', value), ])


class yc_blockStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_blockStorageData(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualStorageDesc/virtualStorage/blockStorageData. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Block storage data, applicable only if typeOfStorage=BLOCK
  """
  __slots__ = ('_path_helper', '_extmethods', '__hostingProvidesIops','__guaranteedIops','__maxIops',)

  _yang_name = 'blockStorageData'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hostingProvidesIops = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hostingProvidesIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__guaranteedIops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteedIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__maxIops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualStorageDesc', 'virtualStorage', 'blockStorageData']

  def _get_hostingProvidesIops(self):
    """
    Getter method for hostingProvidesIops, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/blockStorageData/hostingProvidesIops (boolean)

    YANG Description: If set to true, the NFVI provides dedicated IOPS (I/O operations per second) to the virtualised block storage resource
    """
    return self.__hostingProvidesIops
      
  def _set_hostingProvidesIops(self, v, load=False):
    """
    Setter method for hostingProvidesIops, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/blockStorageData/hostingProvidesIops (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostingProvidesIops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostingProvidesIops() directly.

    YANG Description: If set to true, the NFVI provides dedicated IOPS (I/O operations per second) to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hostingProvidesIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostingProvidesIops must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hostingProvidesIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__hostingProvidesIops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostingProvidesIops(self):
    self.__hostingProvidesIops = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hostingProvidesIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_guaranteedIops(self):
    """
    Getter method for guaranteedIops, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/blockStorageData/guaranteedIops (uint64)

    YANG Description: Minimum IOPS that the NFVI provides to the virtualised block storage resource
    """
    return self.__guaranteedIops
      
  def _set_guaranteedIops(self, v, load=False):
    """
    Setter method for guaranteedIops, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/blockStorageData/guaranteedIops (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_guaranteedIops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_guaranteedIops() directly.

    YANG Description: Minimum IOPS that the NFVI provides to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteedIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """guaranteedIops must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteedIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__guaranteedIops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_guaranteedIops(self):
    self.__guaranteedIops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteedIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_maxIops(self):
    """
    Getter method for maxIops, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/blockStorageData/maxIops (uint64)

    YANG Description: Maximum IOPS that the NFVI provides to the virtualised block storage resource
    """
    return self.__maxIops
      
  def _set_maxIops(self, v, load=False):
    """
    Setter method for maxIops, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/blockStorageData/maxIops (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxIops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxIops() directly.

    YANG Description: Maximum IOPS that the NFVI provides to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxIops must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__maxIops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxIops(self):
    self.__maxIops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxIops", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  hostingProvidesIops = __builtin__.property(_get_hostingProvidesIops, _set_hostingProvidesIops)
  guaranteedIops = __builtin__.property(_get_guaranteedIops, _set_guaranteedIops)
  maxIops = __builtin__.property(_get_maxIops, _set_maxIops)


  _pyangbind_elements = OrderedDict([('hostingProvidesIops', hostingProvidesIops), ('guaranteedIops', guaranteedIops), ('maxIops', maxIops), ])


class yc_objectStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_objectStorageData(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualStorageDesc/virtualStorage/objectStorageData. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Object storage data, applicable only if typeOfStorage=OBJECT
  """
  __slots__ = ('_path_helper', '_extmethods', '__maxSizeOfObject','__maxConcurrentIncomingTransfers','__maxConcurrentOutgoingTransfers',)

  _yang_name = 'objectStorageData'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__maxSizeOfObject = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxSizeOfObject", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__maxConcurrentIncomingTransfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentIncomingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__maxConcurrentOutgoingTransfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentOutgoingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualStorageDesc', 'virtualStorage', 'objectStorageData']

  def _get_maxSizeOfObject(self):
    """
    Getter method for maxSizeOfObject, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/objectStorageData/maxSizeOfObject (uint64)

    YANG Description: Maximum size of object that can be stored in the object storage resource
    """
    return self.__maxSizeOfObject
      
  def _set_maxSizeOfObject(self, v, load=False):
    """
    Setter method for maxSizeOfObject, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/objectStorageData/maxSizeOfObject (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxSizeOfObject is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxSizeOfObject() directly.

    YANG Description: Maximum size of object that can be stored in the object storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxSizeOfObject", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxSizeOfObject must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxSizeOfObject", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__maxSizeOfObject = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxSizeOfObject(self):
    self.__maxSizeOfObject = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxSizeOfObject", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_maxConcurrentIncomingTransfers(self):
    """
    Getter method for maxConcurrentIncomingTransfers, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/objectStorageData/maxConcurrentIncomingTransfers (uint64)

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the object storage resource can handle
    """
    return self.__maxConcurrentIncomingTransfers
      
  def _set_maxConcurrentIncomingTransfers(self, v, load=False):
    """
    Setter method for maxConcurrentIncomingTransfers, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/objectStorageData/maxConcurrentIncomingTransfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxConcurrentIncomingTransfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxConcurrentIncomingTransfers() directly.

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the object storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentIncomingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxConcurrentIncomingTransfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentIncomingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__maxConcurrentIncomingTransfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxConcurrentIncomingTransfers(self):
    self.__maxConcurrentIncomingTransfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentIncomingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_maxConcurrentOutgoingTransfers(self):
    """
    Getter method for maxConcurrentOutgoingTransfers, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/objectStorageData/maxConcurrentOutgoingTransfers (uint64)

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the object storage resource can handle
    """
    return self.__maxConcurrentOutgoingTransfers
      
  def _set_maxConcurrentOutgoingTransfers(self, v, load=False):
    """
    Setter method for maxConcurrentOutgoingTransfers, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/objectStorageData/maxConcurrentOutgoingTransfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxConcurrentOutgoingTransfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxConcurrentOutgoingTransfers() directly.

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the object storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentOutgoingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxConcurrentOutgoingTransfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentOutgoingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__maxConcurrentOutgoingTransfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxConcurrentOutgoingTransfers(self):
    self.__maxConcurrentOutgoingTransfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentOutgoingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  maxSizeOfObject = __builtin__.property(_get_maxSizeOfObject, _set_maxSizeOfObject)
  maxConcurrentIncomingTransfers = __builtin__.property(_get_maxConcurrentIncomingTransfers, _set_maxConcurrentIncomingTransfers)
  maxConcurrentOutgoingTransfers = __builtin__.property(_get_maxConcurrentOutgoingTransfers, _set_maxConcurrentOutgoingTransfers)


  _pyangbind_elements = OrderedDict([('maxSizeOfObject', maxSizeOfObject), ('maxConcurrentIncomingTransfers', maxConcurrentIncomingTransfers), ('maxConcurrentOutgoingTransfers', maxConcurrentOutgoingTransfers), ])


class yc_fileStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_fileStorageData(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualStorageDesc/virtualStorage/fileStorageData. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: File storage data, applicable only if typeOfStorage=FILE
  """
  __slots__ = ('_path_helper', '_extmethods', '__maxSizeOfFile','__maxConcurrentIncomingTransfers','__maxConcurrentOutgoingTransfers',)

  _yang_name = 'fileStorageData'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__maxSizeOfFile = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxSizeOfFile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__maxConcurrentIncomingTransfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentIncomingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__maxConcurrentOutgoingTransfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentOutgoingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualStorageDesc', 'virtualStorage', 'fileStorageData']

  def _get_maxSizeOfFile(self):
    """
    Getter method for maxSizeOfFile, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/fileStorageData/maxSizeOfFile (uint64)

    YANG Description: Maximum size of file that can be stored in the file storage resource
    """
    return self.__maxSizeOfFile
      
  def _set_maxSizeOfFile(self, v, load=False):
    """
    Setter method for maxSizeOfFile, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/fileStorageData/maxSizeOfFile (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxSizeOfFile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxSizeOfFile() directly.

    YANG Description: Maximum size of file that can be stored in the file storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxSizeOfFile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxSizeOfFile must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxSizeOfFile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__maxSizeOfFile = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxSizeOfFile(self):
    self.__maxSizeOfFile = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxSizeOfFile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_maxConcurrentIncomingTransfers(self):
    """
    Getter method for maxConcurrentIncomingTransfers, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/fileStorageData/maxConcurrentIncomingTransfers (uint64)

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the file storage resource can handle
    """
    return self.__maxConcurrentIncomingTransfers
      
  def _set_maxConcurrentIncomingTransfers(self, v, load=False):
    """
    Setter method for maxConcurrentIncomingTransfers, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/fileStorageData/maxConcurrentIncomingTransfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxConcurrentIncomingTransfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxConcurrentIncomingTransfers() directly.

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the file storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentIncomingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxConcurrentIncomingTransfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentIncomingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__maxConcurrentIncomingTransfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxConcurrentIncomingTransfers(self):
    self.__maxConcurrentIncomingTransfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentIncomingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_maxConcurrentOutgoingTransfers(self):
    """
    Getter method for maxConcurrentOutgoingTransfers, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/fileStorageData/maxConcurrentOutgoingTransfers (uint64)

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the file storage resource can handle
    """
    return self.__maxConcurrentOutgoingTransfers
      
  def _set_maxConcurrentOutgoingTransfers(self, v, load=False):
    """
    Setter method for maxConcurrentOutgoingTransfers, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/fileStorageData/maxConcurrentOutgoingTransfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxConcurrentOutgoingTransfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxConcurrentOutgoingTransfers() directly.

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the file storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentOutgoingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxConcurrentOutgoingTransfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentOutgoingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__maxConcurrentOutgoingTransfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxConcurrentOutgoingTransfers(self):
    self.__maxConcurrentOutgoingTransfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="maxConcurrentOutgoingTransfers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  maxSizeOfFile = __builtin__.property(_get_maxSizeOfFile, _set_maxSizeOfFile)
  maxConcurrentIncomingTransfers = __builtin__.property(_get_maxConcurrentIncomingTransfers, _set_maxConcurrentIncomingTransfers)
  maxConcurrentOutgoingTransfers = __builtin__.property(_get_maxConcurrentOutgoingTransfers, _set_maxConcurrentOutgoingTransfers)


  _pyangbind_elements = OrderedDict([('maxSizeOfFile', maxSizeOfFile), ('maxConcurrentIncomingTransfers', maxConcurrentIncomingTransfers), ('maxConcurrentOutgoingTransfers', maxConcurrentOutgoingTransfers), ])


class yc_virtualStorage_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualStorageDesc/virtualStorage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__virtualStorageDescId','__typeOfStorage','__sizeOfStorage','__operationStatus','__blockStorageData','__objectStorageData','__fileStorageData',)

  _yang_name = 'virtualStorage'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__virtualStorageDescId = YANGDynClass(base=yc_virtualStorageDescId_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_virtualStorageDescId, is_container='container', yang_name="virtualStorageDescId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__typeOfStorage = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="typeOfStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__sizeOfStorage = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="sizeOfStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__operationStatus = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operationStatus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__blockStorageData = YANGDynClass(base=yc_blockStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_blockStorageData, is_container='container', yang_name="blockStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__objectStorageData = YANGDynClass(base=yc_objectStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_objectStorageData, is_container='container', yang_name="objectStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__fileStorageData = YANGDynClass(base=yc_fileStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_fileStorageData, is_container='container', yang_name="fileStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualStorageDesc', 'virtualStorage']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/id (string)

    YANG Description: Unique identifier for this VirtualStorageDesc
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this VirtualStorageDesc
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_virtualStorageDescId(self):
    """
    Getter method for virtualStorageDescId, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/virtualStorageDescId (container)

    YANG Description: Identifier of this VirtualStorageDesc in the VNFD
    """
    return self.__virtualStorageDescId
      
  def _set_virtualStorageDescId(self, v, load=False):
    """
    Setter method for virtualStorageDescId, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/virtualStorageDescId (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualStorageDescId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualStorageDescId() directly.

    YANG Description: Identifier of this VirtualStorageDesc in the VNFD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_virtualStorageDescId_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_virtualStorageDescId, is_container='container', yang_name="virtualStorageDescId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualStorageDescId must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_virtualStorageDescId_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_virtualStorageDescId, is_container='container', yang_name="virtualStorageDescId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__virtualStorageDescId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualStorageDescId(self):
    self.__virtualStorageDescId = YANGDynClass(base=yc_virtualStorageDescId_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_virtualStorageDescId, is_container='container', yang_name="virtualStorageDescId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_typeOfStorage(self):
    """
    Getter method for typeOfStorage, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/typeOfStorage (enumeration)

    YANG Description: Type of virtualised storage resource
    """
    return self.__typeOfStorage
      
  def _set_typeOfStorage(self, v, load=False):
    """
    Setter method for typeOfStorage, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/typeOfStorage (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_typeOfStorage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_typeOfStorage() directly.

    YANG Description: Type of virtualised storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="typeOfStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """typeOfStorage must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="typeOfStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__typeOfStorage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_typeOfStorage(self):
    self.__typeOfStorage = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="typeOfStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_sizeOfStorage(self):
    """
    Getter method for sizeOfStorage, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/sizeOfStorage (uint64)

    YANG Description: Size of virtualised storage resource (e.g. size of block storage device)
    """
    return self.__sizeOfStorage
      
  def _set_sizeOfStorage(self, v, load=False):
    """
    Setter method for sizeOfStorage, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/sizeOfStorage (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sizeOfStorage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sizeOfStorage() directly.

    YANG Description: Size of virtualised storage resource (e.g. size of block storage device)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="sizeOfStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sizeOfStorage must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="sizeOfStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__sizeOfStorage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sizeOfStorage(self):
    self.__sizeOfStorage = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="sizeOfStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_operationStatus(self):
    """
    Getter method for operationStatus, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/operationStatus (string)

    YANG Description: Operation status of the virtualised storage resource
    """
    return self.__operationStatus
      
  def _set_operationStatus(self, v, load=False):
    """
    Setter method for operationStatus, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/operationStatus (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operationStatus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operationStatus() directly.

    YANG Description: Operation status of the virtualised storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operationStatus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operationStatus must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operationStatus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__operationStatus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operationStatus(self):
    self.__operationStatus = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operationStatus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_blockStorageData(self):
    """
    Getter method for blockStorageData, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/blockStorageData (container)

    YANG Description: Block storage data, applicable only if typeOfStorage=BLOCK
    """
    return self.__blockStorageData
      
  def _set_blockStorageData(self, v, load=False):
    """
    Setter method for blockStorageData, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/blockStorageData (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_blockStorageData is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_blockStorageData() directly.

    YANG Description: Block storage data, applicable only if typeOfStorage=BLOCK
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_blockStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_blockStorageData, is_container='container', yang_name="blockStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """blockStorageData must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_blockStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_blockStorageData, is_container='container', yang_name="blockStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__blockStorageData = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_blockStorageData(self):
    self.__blockStorageData = YANGDynClass(base=yc_blockStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_blockStorageData, is_container='container', yang_name="blockStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_objectStorageData(self):
    """
    Getter method for objectStorageData, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/objectStorageData (container)

    YANG Description: Object storage data, applicable only if typeOfStorage=OBJECT
    """
    return self.__objectStorageData
      
  def _set_objectStorageData(self, v, load=False):
    """
    Setter method for objectStorageData, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/objectStorageData (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_objectStorageData is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_objectStorageData() directly.

    YANG Description: Object storage data, applicable only if typeOfStorage=OBJECT
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_objectStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_objectStorageData, is_container='container', yang_name="objectStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """objectStorageData must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_objectStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_objectStorageData, is_container='container', yang_name="objectStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__objectStorageData = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_objectStorageData(self):
    self.__objectStorageData = YANGDynClass(base=yc_objectStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_objectStorageData, is_container='container', yang_name="objectStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_fileStorageData(self):
    """
    Getter method for fileStorageData, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/fileStorageData (container)

    YANG Description: File storage data, applicable only if typeOfStorage=FILE
    """
    return self.__fileStorageData
      
  def _set_fileStorageData(self, v, load=False):
    """
    Setter method for fileStorageData, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage/fileStorageData (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fileStorageData is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fileStorageData() directly.

    YANG Description: File storage data, applicable only if typeOfStorage=FILE
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_fileStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_fileStorageData, is_container='container', yang_name="fileStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fileStorageData must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_fileStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_fileStorageData, is_container='container', yang_name="fileStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__fileStorageData = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fileStorageData(self):
    self.__fileStorageData = YANGDynClass(base=yc_fileStorageData_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage_fileStorageData, is_container='container', yang_name="fileStorageData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  virtualStorageDescId = __builtin__.property(_get_virtualStorageDescId, _set_virtualStorageDescId)
  typeOfStorage = __builtin__.property(_get_typeOfStorage, _set_typeOfStorage)
  sizeOfStorage = __builtin__.property(_get_sizeOfStorage, _set_sizeOfStorage)
  operationStatus = __builtin__.property(_get_operationStatus, _set_operationStatus)
  blockStorageData = __builtin__.property(_get_blockStorageData, _set_blockStorageData)
  objectStorageData = __builtin__.property(_get_objectStorageData, _set_objectStorageData)
  fileStorageData = __builtin__.property(_get_fileStorageData, _set_fileStorageData)


  _pyangbind_elements = OrderedDict([('id', id), ('virtualStorageDescId', virtualStorageDescId), ('typeOfStorage', typeOfStorage), ('sizeOfStorage', sizeOfStorage), ('operationStatus', operationStatus), ('blockStorageData', blockStorageData), ('objectStorageData', objectStorageData), ('fileStorageData', fileStorageData), ])


class yc_VirtualStorageDesc_mec_app_descriptor__app_descriptor_VirtualStorageDesc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/VirtualStorageDesc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates Virtual Storage Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__virtualStorage',)

  _yang_name = 'VirtualStorageDesc'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__virtualStorage = YANGDynClass(base=YANGListType("id",yc_virtualStorage_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage, yang_name="virtualStorage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'VirtualStorageDesc']

  def _get_virtualStorage(self):
    """
    Getter method for virtualStorage, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage (list)
    """
    return self.__virtualStorage
      
  def _set_virtualStorage(self, v, load=False):
    """
    Setter method for virtualStorage, mapped from YANG variable /app_descriptor/VirtualStorageDesc/virtualStorage (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualStorage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualStorage() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_virtualStorage_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage, yang_name="virtualStorage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualStorage must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtualStorage_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage, yang_name="virtualStorage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__virtualStorage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualStorage(self):
    self.__virtualStorage = YANGDynClass(base=YANGListType("id",yc_virtualStorage_mec_app_descriptor__app_descriptor_VirtualStorageDesc_virtualStorage, yang_name="virtualStorage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtualStorage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  virtualStorage = __builtin__.property(_get_virtualStorage, _set_virtualStorage)


  _pyangbind_elements = OrderedDict([('virtualStorage', virtualStorage), ])


class yc_virtualNetworkInterfaceRequirements_mec_app_descriptor__app_descriptor_appExtCpd_virtualNetworkInterfaceRequirements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/appExtCpd/virtualNetworkInterfaceRequirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies requirements on a virtual network interface realizing the CPs instantiated from this CPD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__supportMandatory','__requirement',)

  _yang_name = 'virtualNetworkInterfaceRequirements'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__supportMandatory = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="supportMandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__requirement = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'appExtCpd', 'virtualNetworkInterfaceRequirements']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/appExtCpd/virtualNetworkInterfaceRequirements/name (string)

    YANG Description: Provides a human readable name for the requirement.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/appExtCpd/virtualNetworkInterfaceRequirements/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Provides a human readable name for the requirement.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/appExtCpd/virtualNetworkInterfaceRequirements/description (string)

    YANG Description: Provides a human readable description of the requirement.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/appExtCpd/virtualNetworkInterfaceRequirements/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides a human readable description of the requirement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_supportMandatory(self):
    """
    Getter method for supportMandatory, mapped from YANG variable /app_descriptor/appExtCpd/virtualNetworkInterfaceRequirements/supportMandatory (boolean)

    YANG Description: Indicates whether fulfilling the constraint is mandatory (true) for successful operation.
    """
    return self.__supportMandatory
      
  def _set_supportMandatory(self, v, load=False):
    """
    Setter method for supportMandatory, mapped from YANG variable /app_descriptor/appExtCpd/virtualNetworkInterfaceRequirements/supportMandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportMandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportMandatory() directly.

    YANG Description: Indicates whether fulfilling the constraint is mandatory (true) for successful operation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="supportMandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportMandatory must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="supportMandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__supportMandatory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportMandatory(self):
    self.__supportMandatory = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="supportMandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_requirement(self):
    """
    Getter method for requirement, mapped from YANG variable /app_descriptor/appExtCpd/virtualNetworkInterfaceRequirements/requirement (string)

    YANG Description: Specifies a requirement such as the support of SR-IOV, a particular data plane acceleration library, an API, or a hardware capability.
    """
    return self.__requirement
      
  def _set_requirement(self, v, load=False):
    """
    Setter method for requirement, mapped from YANG variable /app_descriptor/appExtCpd/virtualNetworkInterfaceRequirements/requirement (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requirement() directly.

    YANG Description: Specifies a requirement such as the support of SR-IOV, a particular data plane acceleration library, an API, or a hardware capability.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """requirement must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__requirement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_requirement(self):
    self.__requirement = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  supportMandatory = __builtin__.property(_get_supportMandatory, _set_supportMandatory)
  requirement = __builtin__.property(_get_requirement, _set_requirement)


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('supportMandatory', supportMandatory), ('requirement', requirement), ])


class yc_l3AddressData_mec_app_descriptor__app_descriptor_appExtCpd_addressData_l3AddressData(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/appExtCpd/addressData/l3AddressData. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The L3 address data for the CP instantiated from this CPD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipAddressType','__numberOfIpAddress','__ipAddressAssignment','__floatingIpActivated','__ipAddressReservation',)

  _yang_name = 'l3AddressData'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipAddressType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ipAddressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__numberOfIpAddress = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numberOfIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    self.__ipAddressAssignment = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DYNAMIC': {}, 'STATIC': {}},)), is_leaf=False, yang_name="ipAddressAssignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__floatingIpActivated = YANGDynClass(unique=True, base=TypedListType(allowed_type=YANGBool), is_leaf=False, yang_name="floatingIpActivated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__ipAddressReservation = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="ipAddressReservation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'appExtCpd', 'addressData', 'l3AddressData']

  def _get_ipAddressType(self):
    """
    Getter method for ipAddressType, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData/ipAddressType (enumeration)

    YANG Description: The type of the IP address.
    """
    return self.__ipAddressType
      
  def _set_ipAddressType(self, v, load=False):
    """
    Setter method for ipAddressType, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData/ipAddressType (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipAddressType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipAddressType() directly.

    YANG Description: The type of the IP address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ipAddressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipAddressType must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ipAddressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__ipAddressType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipAddressType(self):
    self.__ipAddressType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IPV4': {}, 'IPV6': {}},), is_leaf=True, yang_name="ipAddressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_numberOfIpAddress(self):
    """
    Getter method for numberOfIpAddress, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData/numberOfIpAddress (uint32)

    YANG Description: The number of IP addresses to assign to the CP instantiated from this CPD.
    """
    return self.__numberOfIpAddress
      
  def _set_numberOfIpAddress(self, v, load=False):
    """
    Setter method for numberOfIpAddress, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData/numberOfIpAddress (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numberOfIpAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numberOfIpAddress() directly.

    YANG Description: The number of IP addresses to assign to the CP instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numberOfIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numberOfIpAddress must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numberOfIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__numberOfIpAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numberOfIpAddress(self):
    self.__numberOfIpAddress = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numberOfIpAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)


  def _get_ipAddressAssignment(self):
    """
    Getter method for ipAddressAssignment, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData/ipAddressAssignment (enumeration)

    YANG Description: Specifies how the IP address(es) will be assigned.
    """
    return self.__ipAddressAssignment
      
  def _set_ipAddressAssignment(self, v, load=False):
    """
    Setter method for ipAddressAssignment, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData/ipAddressAssignment (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipAddressAssignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipAddressAssignment() directly.

    YANG Description: Specifies how the IP address(es) will be assigned.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DYNAMIC': {}, 'STATIC': {}},)), is_leaf=False, yang_name="ipAddressAssignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipAddressAssignment must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DYNAMIC': {}, 'STATIC': {}},)), is_leaf=False, yang_name="ipAddressAssignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__ipAddressAssignment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipAddressAssignment(self):
    self.__ipAddressAssignment = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DYNAMIC': {}, 'STATIC': {}},)), is_leaf=False, yang_name="ipAddressAssignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_floatingIpActivated(self):
    """
    Getter method for floatingIpActivated, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData/floatingIpActivated (boolean)

    YANG Description: Specify if the floating IP scheme is activated on the CP instantiated from this CPD.
    """
    return self.__floatingIpActivated
      
  def _set_floatingIpActivated(self, v, load=False):
    """
    Setter method for floatingIpActivated, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData/floatingIpActivated (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floatingIpActivated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floatingIpActivated() directly.

    YANG Description: Specify if the floating IP scheme is activated on the CP instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=YANGBool), is_leaf=False, yang_name="floatingIpActivated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """floatingIpActivated must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=YANGBool), is_leaf=False, yang_name="floatingIpActivated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__floatingIpActivated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_floatingIpActivated(self):
    self.__floatingIpActivated = YANGDynClass(unique=True, base=TypedListType(allowed_type=YANGBool), is_leaf=False, yang_name="floatingIpActivated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_ipAddressReservation(self):
    """
    Getter method for ipAddressReservation, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData/ipAddressReservation (inet:ip-address)

    YANG Description: Specifies the IP addresses to be assigned.
    """
    return self.__ipAddressReservation
      
  def _set_ipAddressReservation(self, v, load=False):
    """
    Setter method for ipAddressReservation, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData/ipAddressReservation (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipAddressReservation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipAddressReservation() directly.

    YANG Description: Specifies the IP addresses to be assigned.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="ipAddressReservation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipAddressReservation must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="ipAddressReservation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__ipAddressReservation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipAddressReservation(self):
    self.__ipAddressReservation = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="ipAddressReservation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

  ipAddressType = __builtin__.property(_get_ipAddressType, _set_ipAddressType)
  numberOfIpAddress = __builtin__.property(_get_numberOfIpAddress, _set_numberOfIpAddress)
  ipAddressAssignment = __builtin__.property(_get_ipAddressAssignment, _set_ipAddressAssignment)
  floatingIpActivated = __builtin__.property(_get_floatingIpActivated, _set_floatingIpActivated)
  ipAddressReservation = __builtin__.property(_get_ipAddressReservation, _set_ipAddressReservation)


  _pyangbind_elements = OrderedDict([('ipAddressType', ipAddressType), ('numberOfIpAddress', numberOfIpAddress), ('ipAddressAssignment', ipAddressAssignment), ('floatingIpActivated', floatingIpActivated), ('ipAddressReservation', ipAddressReservation), ])


class yc_addressData_mec_app_descriptor__app_descriptor_appExtCpd_addressData(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/appExtCpd/addressData. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides information on the addresses to be assigned to the CP(s) instantiated from this CPD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addressType','__l2AddressData','__l3AddressData',)

  _yang_name = 'addressData'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addressType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MAC_ADDRESS': {}, 'IP_ADDRESS': {}},), is_leaf=True, yang_name="addressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__l2AddressData = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="l2AddressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    self.__l3AddressData = YANGDynClass(base=yc_l3AddressData_mec_app_descriptor__app_descriptor_appExtCpd_addressData_l3AddressData, is_container='container', yang_name="l3AddressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'appExtCpd', 'addressData']

  def _get_addressType(self):
    """
    Getter method for addressType, mapped from YANG variable /app_descriptor/appExtCpd/addressData/addressType (enumeration)

    YANG Description: Describes the type of the address to be assigned to the CP instantiated from this CPD.
    """
    return self.__addressType
      
  def _set_addressType(self, v, load=False):
    """
    Setter method for addressType, mapped from YANG variable /app_descriptor/appExtCpd/addressData/addressType (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addressType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addressType() directly.

    YANG Description: Describes the type of the address to be assigned to the CP instantiated from this CPD.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MAC_ADDRESS': {}, 'IP_ADDRESS': {}},), is_leaf=True, yang_name="addressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addressType must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MAC_ADDRESS': {}, 'IP_ADDRESS': {}},), is_leaf=True, yang_name="addressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__addressType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addressType(self):
    self.__addressType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'MAC_ADDRESS': {}, 'IP_ADDRESS': {}},), is_leaf=True, yang_name="addressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_l2AddressData(self):
    """
    Getter method for l2AddressData, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l2AddressData (yang:mac-address)

    YANG Description: Specifies the L2 address to be assigned to the CP instantiated from this CPD.
    """
    return self.__l2AddressData
      
  def _set_l2AddressData(self, v, load=False):
    """
    Setter method for l2AddressData, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l2AddressData (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2AddressData is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2AddressData() directly.

    YANG Description: Specifies the L2 address to be assigned to the CP instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="l2AddressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2AddressData must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="l2AddressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__l2AddressData = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2AddressData(self):
    self.__l2AddressData = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="l2AddressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)


  def _get_l3AddressData(self):
    """
    Getter method for l3AddressData, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData (container)

    YANG Description: The L3 address data for the CP instantiated from this CPD.
    """
    return self.__l3AddressData
      
  def _set_l3AddressData(self, v, load=False):
    """
    Setter method for l3AddressData, mapped from YANG variable /app_descriptor/appExtCpd/addressData/l3AddressData (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3AddressData is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3AddressData() directly.

    YANG Description: The L3 address data for the CP instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3AddressData_mec_app_descriptor__app_descriptor_appExtCpd_addressData_l3AddressData, is_container='container', yang_name="l3AddressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3AddressData must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3AddressData_mec_app_descriptor__app_descriptor_appExtCpd_addressData_l3AddressData, is_container='container', yang_name="l3AddressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__l3AddressData = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3AddressData(self):
    self.__l3AddressData = YANGDynClass(base=yc_l3AddressData_mec_app_descriptor__app_descriptor_appExtCpd_addressData_l3AddressData, is_container='container', yang_name="l3AddressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  addressType = __builtin__.property(_get_addressType, _set_addressType)
  l2AddressData = __builtin__.property(_get_l2AddressData, _set_l2AddressData)
  l3AddressData = __builtin__.property(_get_l3AddressData, _set_l3AddressData)


  _pyangbind_elements = OrderedDict([('addressType', addressType), ('l2AddressData', l2AddressData), ('l3AddressData', l3AddressData), ])


class yc_appExtCpd_mec_app_descriptor__app_descriptor_appExtCpd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/appExtCpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes an external connection point of a MEC application
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__virtualNetworkInterfaceRequirements','__cpdId','__layerProtocol','__cpRole','__description','__addressData',)

  _yang_name = 'appExtCpd'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__virtualNetworkInterfaceRequirements = YANGDynClass(base=YANGListType("name",yc_virtualNetworkInterfaceRequirements_mec_app_descriptor__app_descriptor_appExtCpd_virtualNetworkInterfaceRequirements, yang_name="virtualNetworkInterfaceRequirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtualNetworkInterfaceRequirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__cpdId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpdId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__layerProtocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ETHERNET': {}, 'MPLS': {}, 'ODU2': {}, 'IPV4': {}, 'IPV6': {}, 'PSEUDO_WIRE': {}},), is_leaf=True, yang_name="layerProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__cpRole = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__addressData = YANGDynClass(base=YANGListType("addressType",yc_addressData_mec_app_descriptor__app_descriptor_appExtCpd_addressData, yang_name="addressData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addressType', extensions=None), is_container='list', yang_name="addressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'appExtCpd']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/appExtCpd/id (string)

    YANG Description: Identifier of the external connection point
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/appExtCpd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of the external connection point
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_virtualNetworkInterfaceRequirements(self):
    """
    Getter method for virtualNetworkInterfaceRequirements, mapped from YANG variable /app_descriptor/appExtCpd/virtualNetworkInterfaceRequirements (list)

    YANG Description: Specifies requirements on a virtual network interface realizing the CPs instantiated from this CPD.
    """
    return self.__virtualNetworkInterfaceRequirements
      
  def _set_virtualNetworkInterfaceRequirements(self, v, load=False):
    """
    Setter method for virtualNetworkInterfaceRequirements, mapped from YANG variable /app_descriptor/appExtCpd/virtualNetworkInterfaceRequirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtualNetworkInterfaceRequirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtualNetworkInterfaceRequirements() directly.

    YANG Description: Specifies requirements on a virtual network interface realizing the CPs instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_virtualNetworkInterfaceRequirements_mec_app_descriptor__app_descriptor_appExtCpd_virtualNetworkInterfaceRequirements, yang_name="virtualNetworkInterfaceRequirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtualNetworkInterfaceRequirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtualNetworkInterfaceRequirements must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_virtualNetworkInterfaceRequirements_mec_app_descriptor__app_descriptor_appExtCpd_virtualNetworkInterfaceRequirements, yang_name="virtualNetworkInterfaceRequirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtualNetworkInterfaceRequirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__virtualNetworkInterfaceRequirements = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtualNetworkInterfaceRequirements(self):
    self.__virtualNetworkInterfaceRequirements = YANGDynClass(base=YANGListType("name",yc_virtualNetworkInterfaceRequirements_mec_app_descriptor__app_descriptor_appExtCpd_virtualNetworkInterfaceRequirements, yang_name="virtualNetworkInterfaceRequirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtualNetworkInterfaceRequirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_cpdId(self):
    """
    Getter method for cpdId, mapped from YANG variable /app_descriptor/appExtCpd/cpdId (string)

    YANG Description: Identifier of this Cpd information element.
    """
    return self.__cpdId
      
  def _set_cpdId(self, v, load=False):
    """
    Setter method for cpdId, mapped from YANG variable /app_descriptor/appExtCpd/cpdId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpdId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpdId() directly.

    YANG Description: Identifier of this Cpd information element.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cpdId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpdId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpdId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__cpdId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpdId(self):
    self.__cpdId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpdId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_layerProtocol(self):
    """
    Getter method for layerProtocol, mapped from YANG variable /app_descriptor/appExtCpd/layerProtocol (enumeration)

    YANG Description: Identifies which protocol the CP uses for connectivity purposes.
    """
    return self.__layerProtocol
      
  def _set_layerProtocol(self, v, load=False):
    """
    Setter method for layerProtocol, mapped from YANG variable /app_descriptor/appExtCpd/layerProtocol (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layerProtocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layerProtocol() directly.

    YANG Description: Identifies which protocol the CP uses for connectivity purposes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ETHERNET': {}, 'MPLS': {}, 'ODU2': {}, 'IPV4': {}, 'IPV6': {}, 'PSEUDO_WIRE': {}},), is_leaf=True, yang_name="layerProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """layerProtocol must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ETHERNET': {}, 'MPLS': {}, 'ODU2': {}, 'IPV4': {}, 'IPV6': {}, 'PSEUDO_WIRE': {}},), is_leaf=True, yang_name="layerProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__layerProtocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_layerProtocol(self):
    self.__layerProtocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ETHERNET': {}, 'MPLS': {}, 'ODU2': {}, 'IPV4': {}, 'IPV6': {}, 'PSEUDO_WIRE': {}},), is_leaf=True, yang_name="layerProtocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_cpRole(self):
    """
    Getter method for cpRole, mapped from YANG variable /app_descriptor/appExtCpd/cpRole (string)

    YANG Description: Identifies the role of the CP in the context of the traffic flow patterns in the VNF or parent NS.
    """
    return self.__cpRole
      
  def _set_cpRole(self, v, load=False):
    """
    Setter method for cpRole, mapped from YANG variable /app_descriptor/appExtCpd/cpRole (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpRole is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpRole() directly.

    YANG Description: Identifies the role of the CP in the context of the traffic flow patterns in the VNF or parent NS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cpRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpRole must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__cpRole = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpRole(self):
    self.__cpRole = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpRole", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/appExtCpd/description (string)

    YANG Description: Provides human-readable information on the purpose of the CP.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/appExtCpd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides human-readable information on the purpose of the CP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_addressData(self):
    """
    Getter method for addressData, mapped from YANG variable /app_descriptor/appExtCpd/addressData (list)

    YANG Description: Provides information on the addresses to be assigned to the CP(s) instantiated from this CPD.
    """
    return self.__addressData
      
  def _set_addressData(self, v, load=False):
    """
    Setter method for addressData, mapped from YANG variable /app_descriptor/appExtCpd/addressData (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addressData is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addressData() directly.

    YANG Description: Provides information on the addresses to be assigned to the CP(s) instantiated from this CPD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("addressType",yc_addressData_mec_app_descriptor__app_descriptor_appExtCpd_addressData, yang_name="addressData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addressType', extensions=None), is_container='list', yang_name="addressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addressData must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("addressType",yc_addressData_mec_app_descriptor__app_descriptor_appExtCpd_addressData, yang_name="addressData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addressType', extensions=None), is_container='list', yang_name="addressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__addressData = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addressData(self):
    self.__addressData = YANGDynClass(base=YANGListType("addressType",yc_addressData_mec_app_descriptor__app_descriptor_appExtCpd_addressData, yang_name="addressData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='addressType', extensions=None), is_container='list', yang_name="addressData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  virtualNetworkInterfaceRequirements = __builtin__.property(_get_virtualNetworkInterfaceRequirements, _set_virtualNetworkInterfaceRequirements)
  cpdId = __builtin__.property(_get_cpdId, _set_cpdId)
  layerProtocol = __builtin__.property(_get_layerProtocol, _set_layerProtocol)
  cpRole = __builtin__.property(_get_cpRole, _set_cpRole)
  description = __builtin__.property(_get_description, _set_description)
  addressData = __builtin__.property(_get_addressData, _set_addressData)


  _pyangbind_elements = OrderedDict([('id', id), ('virtualNetworkInterfaceRequirements', virtualNetworkInterfaceRequirements), ('cpdId', cpdId), ('layerProtocol', layerProtocol), ('cpRole', cpRole), ('description', description), ('addressData', addressData), ])


class yc_serCategory_mec_app_descriptor__app_descriptor_ServiceDependency_serCategory(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDependency/serCategory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A Category reference of the service
  """
  __slots__ = ('_path_helper', '_extmethods', '__href','__id','__name','__version',)

  _yang_name = 'serCategory'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__href = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDependency', 'serCategory']

  def _get_href(self):
    """
    Getter method for href, mapped from YANG variable /app_descriptor/ServiceDependency/serCategory/href (string)

    YANG Description: Reference of the catalogue
    """
    return self.__href
      
  def _set_href(self, v, load=False):
    """
    Setter method for href, mapped from YANG variable /app_descriptor/ServiceDependency/serCategory/href (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_href is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_href() directly.

    YANG Description: Reference of the catalogue
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """href must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__href = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_href(self):
    self.__href = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/ServiceDependency/serCategory/id (string)

    YANG Description: Unique identifier of the category
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/ServiceDependency/serCategory/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/ServiceDependency/serCategory/name (string)

    YANG Description: Name of the category
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/ServiceDependency/serCategory/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/ServiceDependency/serCategory/version (string)

    YANG Description: Category version
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/ServiceDependency/serCategory/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Category version
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  href = __builtin__.property(_get_href, _set_href)
  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('href', href), ('id', id), ('name', name), ('version', version), ])


class yc_serTransportDependencies_mec_app_descriptor__app_descriptor_ServiceDependency_serTransportDependencies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDependency/serTransportDependencies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
  """
  __slots__ = ('_path_helper', '_extmethods', '__transportId','__transport','__serializers','__labels',)

  _yang_name = 'serTransportDependencies'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transportId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transportId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__transport = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__labels = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDependency', 'serTransportDependencies']

  def _get_transportId(self):
    """
    Getter method for transportId, mapped from YANG variable /app_descriptor/ServiceDependency/serTransportDependencies/transportId (string)

    YANG Description: Unique identifier for the transport dependency
    """
    return self.__transportId
      
  def _set_transportId(self, v, load=False):
    """
    Setter method for transportId, mapped from YANG variable /app_descriptor/ServiceDependency/serTransportDependencies/transportId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transportId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transportId() directly.

    YANG Description: Unique identifier for the transport dependency
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="transportId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transportId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transportId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__transportId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transportId(self):
    self.__transportId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transportId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /app_descriptor/ServiceDependency/serTransportDependencies/transport (string)

    YANG Description: Information about the transport in this transport binding
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /app_descriptor/ServiceDependency/serTransportDependencies/transport (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Information about the transport in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_serializers(self):
    """
    Getter method for serializers, mapped from YANG variable /app_descriptor/ServiceDependency/serTransportDependencies/serializers (string)

    YANG Description: Information about the serializers in this transport binding
    """
    return self.__serializers
      
  def _set_serializers(self, v, load=False):
    """
    Setter method for serializers, mapped from YANG variable /app_descriptor/ServiceDependency/serTransportDependencies/serializers (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serializers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serializers() directly.

    YANG Description: Information about the serializers in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serializers must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__serializers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serializers(self):
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_labels(self):
    """
    Getter method for labels, mapped from YANG variable /app_descriptor/ServiceDependency/serTransportDependencies/labels (string)

    YANG Description: Set of labels that allow to define groups of transport bindings
    """
    return self.__labels
      
  def _set_labels(self, v, load=False):
    """
    Setter method for labels, mapped from YANG variable /app_descriptor/ServiceDependency/serTransportDependencies/labels (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_labels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_labels() directly.

    YANG Description: Set of labels that allow to define groups of transport bindings
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """labels must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__labels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_labels(self):
    self.__labels = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  transportId = __builtin__.property(_get_transportId, _set_transportId)
  transport = __builtin__.property(_get_transport, _set_transport)
  serializers = __builtin__.property(_get_serializers, _set_serializers)
  labels = __builtin__.property(_get_labels, _set_labels)


  _pyangbind_elements = OrderedDict([('transportId', transportId), ('transport', transport), ('serializers', serializers), ('labels', labels), ])


class yc_ServiceDependency_mec_app_descriptor__app_descriptor_ServiceDependency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDependency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes service dependencies of the MEC app
  """
  __slots__ = ('_path_helper', '_extmethods', '__serName','__serCategory','__version','__serTransportDependencies','__requestedPermissions',)

  _yang_name = 'ServiceDependency'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__serName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__serCategory = YANGDynClass(base=yc_serCategory_mec_app_descriptor__app_descriptor_ServiceDependency_serCategory, is_container='container', yang_name="serCategory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__serTransportDependencies = YANGDynClass(base=YANGListType("transportId",yc_serTransportDependencies_mec_app_descriptor__app_descriptor_ServiceDependency_serTransportDependencies, yang_name="serTransportDependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='transportId', extensions=None), is_container='list', yang_name="serTransportDependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__requestedPermissions = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requestedPermissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDependency']

  def _get_serName(self):
    """
    Getter method for serName, mapped from YANG variable /app_descriptor/ServiceDependency/serName (string)

    YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
    """
    return self.__serName
      
  def _set_serName(self, v, load=False):
    """
    Setter method for serName, mapped from YANG variable /app_descriptor/ServiceDependency/serName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serName() directly.

    YANG Description: The name of the service, e.g. RNIS, LocationService, AMS
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="serName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__serName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serName(self):
    self.__serName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_serCategory(self):
    """
    Getter method for serCategory, mapped from YANG variable /app_descriptor/ServiceDependency/serCategory (container)

    YANG Description: A Category reference of the service
    """
    return self.__serCategory
      
  def _set_serCategory(self, v, load=False):
    """
    Setter method for serCategory, mapped from YANG variable /app_descriptor/ServiceDependency/serCategory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serCategory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serCategory() directly.

    YANG Description: A Category reference of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_serCategory_mec_app_descriptor__app_descriptor_ServiceDependency_serCategory, is_container='container', yang_name="serCategory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serCategory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_serCategory_mec_app_descriptor__app_descriptor_ServiceDependency_serCategory, is_container='container', yang_name="serCategory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__serCategory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serCategory(self):
    self.__serCategory = YANGDynClass(base=yc_serCategory_mec_app_descriptor__app_descriptor_ServiceDependency_serCategory, is_container='container', yang_name="serCategory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/ServiceDependency/version (string)

    YANG Description: The version of the service
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/ServiceDependency/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_serTransportDependencies(self):
    """
    Getter method for serTransportDependencies, mapped from YANG variable /app_descriptor/ServiceDependency/serTransportDependencies (list)

    YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
    """
    return self.__serTransportDependencies
      
  def _set_serTransportDependencies(self, v, load=False):
    """
    Setter method for serTransportDependencies, mapped from YANG variable /app_descriptor/ServiceDependency/serTransportDependencies (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serTransportDependencies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serTransportDependencies() directly.

    YANG Description: Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("transportId",yc_serTransportDependencies_mec_app_descriptor__app_descriptor_ServiceDependency_serTransportDependencies, yang_name="serTransportDependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='transportId', extensions=None), is_container='list', yang_name="serTransportDependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serTransportDependencies must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("transportId",yc_serTransportDependencies_mec_app_descriptor__app_descriptor_ServiceDependency_serTransportDependencies, yang_name="serTransportDependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='transportId', extensions=None), is_container='list', yang_name="serTransportDependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__serTransportDependencies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serTransportDependencies(self):
    self.__serTransportDependencies = YANGDynClass(base=YANGListType("transportId",yc_serTransportDependencies_mec_app_descriptor__app_descriptor_ServiceDependency_serTransportDependencies, yang_name="serTransportDependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='transportId', extensions=None), is_container='list', yang_name="serTransportDependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_requestedPermissions(self):
    """
    Getter method for requestedPermissions, mapped from YANG variable /app_descriptor/ServiceDependency/requestedPermissions (string)

    YANG Description: Requested permissions regarding the access of the application to the service. The format is left for the data model design stage.
    """
    return self.__requestedPermissions
      
  def _set_requestedPermissions(self, v, load=False):
    """
    Setter method for requestedPermissions, mapped from YANG variable /app_descriptor/ServiceDependency/requestedPermissions (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requestedPermissions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requestedPermissions() directly.

    YANG Description: Requested permissions regarding the access of the application to the service. The format is left for the data model design stage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requestedPermissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """requestedPermissions must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requestedPermissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__requestedPermissions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_requestedPermissions(self):
    self.__requestedPermissions = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="requestedPermissions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  serName = __builtin__.property(_get_serName, _set_serName)
  serCategory = __builtin__.property(_get_serCategory, _set_serCategory)
  version = __builtin__.property(_get_version, _set_version)
  serTransportDependencies = __builtin__.property(_get_serTransportDependencies, _set_serTransportDependencies)
  requestedPermissions = __builtin__.property(_get_requestedPermissions, _set_requestedPermissions)


  _pyangbind_elements = OrderedDict([('serName', serName), ('serCategory', serCategory), ('version', version), ('serTransportDependencies', serTransportDependencies), ('requestedPermissions', requestedPermissions), ])


class yc_serCategory_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_serCategory(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDescriptor/service/serCategory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A Category reference of the service
  """
  __slots__ = ('_path_helper', '_extmethods', '__href','__id','__name','__version',)

  _yang_name = 'serCategory'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__href = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDescriptor', 'service', 'serCategory']

  def _get_href(self):
    """
    Getter method for href, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serCategory/href (string)

    YANG Description: Reference of the catalogue
    """
    return self.__href
      
  def _set_href(self, v, load=False):
    """
    Setter method for href, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serCategory/href (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_href is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_href() directly.

    YANG Description: Reference of the catalogue
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """href must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__href = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_href(self):
    self.__href = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="href", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serCategory/id (string)

    YANG Description: Unique identifier of the category
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serCategory/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serCategory/name (string)

    YANG Description: Name of the category
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serCategory/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the category
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serCategory/version (string)

    YANG Description: Category version
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serCategory/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Category version
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  href = __builtin__.property(_get_href, _set_href)
  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('href', href), ('id', id), ('name', name), ('version', version), ])


class yc_addresses_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_endpoint_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Entry point information as IP address and port
  """
  __slots__ = ('_path_helper', '_extmethods', '__host','__port',)

  _yang_name = 'addresses'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__host = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', 'length': ['1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:host', is_config=True)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDescriptor', 'service', 'transportsSupported', 'transport', 'endpoint', 'addresses']

  def _get_host(self):
    """
    Getter method for host, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint/addresses/host (inet:host)

    YANG Description: IP address of the entry point
    """
    return self.__host
      
  def _set_host(self, v, load=False):
    """
    Setter method for host, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint/addresses/host (inet:host)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host() directly.

    YANG Description: IP address of the entry point
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', 'length': ['1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:host', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host must be of a type compatible with inet:host""",
          'defined-type': "inet:host",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', 'length': ['1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:host', is_config=True)""",
        })

    self.__host = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host(self):
    self.__host = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', 'length': ['1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:host', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint/addresses/port (inet:port-number)

    YANG Description: Port of the entry point
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint/addresses/port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: Port of the entry point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)

  host = __builtin__.property(_get_host, _set_host)
  port = __builtin__.property(_get_port, _set_port)


  _pyangbind_elements = OrderedDict([('host', host), ('port', port), ])


class yc_endpoint_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_endpoint(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the endpoint to access the transport
  """
  __slots__ = ('_path_helper', '_extmethods', '__uris','__addresses',)

  _yang_name = 'endpoint'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uris = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uris", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)
    self.__addresses = YANGDynClass(base=YANGListType("host",yc_addresses_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_endpoint_addresses, yang_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDescriptor', 'service', 'transportsSupported', 'transport', 'endpoint']

  def _get_uris(self):
    """
    Getter method for uris, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint/uris (inet:uri)

    YANG Description: Entry point information of the service as URI
    """
    return self.__uris
      
  def _set_uris(self, v, load=False):
    """
    Setter method for uris, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint/uris (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uris is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uris() directly.

    YANG Description: Entry point information of the service as URI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uris", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uris must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uris", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
        })

    self.__uris = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uris(self):
    self.__uris = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uris", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint/addresses (list)

    YANG Description: Entry point information as IP address and port
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint/addresses (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: Entry point information as IP address and port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("host",yc_addresses_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_endpoint_addresses, yang_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("host",yc_addresses_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_endpoint_addresses, yang_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=YANGListType("host",yc_addresses_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_endpoint_addresses, yang_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  uris = __builtin__.property(_get_uris, _set_uris)
  addresses = __builtin__.property(_get_addresses, _set_addresses)


  _pyangbind_elements = OrderedDict([('uris', uris), ('addresses', addresses), ])


class yc_oAuth2Info_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_security_oAuth2Info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDescriptor/service/transportsSupported/transport/security/oAuth2Info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about OAuth2 based security
  """
  __slots__ = ('_path_helper', '_extmethods', '__grantTypes','__tokenEndpoint',)

  _yang_name = 'oAuth2Info'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__grantTypes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grantTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__tokenEndpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tokenEndpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDescriptor', 'service', 'transportsSupported', 'transport', 'security', 'oAuth2Info']

  def _get_grantTypes(self):
    """
    Getter method for grantTypes, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/security/oAuth2Info/grantTypes (enumeration)

    YANG Description: Supported OAuth2 grant types
    """
    return self.__grantTypes
      
  def _set_grantTypes(self, v, load=False):
    """
    Setter method for grantTypes, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/security/oAuth2Info/grantTypes (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grantTypes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grantTypes() directly.

    YANG Description: Supported OAuth2 grant types
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grantTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grantTypes must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grantTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__grantTypes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grantTypes(self):
    self.__grantTypes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grantTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_tokenEndpoint(self):
    """
    Getter method for tokenEndpoint, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/security/oAuth2Info/tokenEndpoint (inet:uri)

    YANG Description: The token endpoint
    """
    return self.__tokenEndpoint
      
  def _set_tokenEndpoint(self, v, load=False):
    """
    Setter method for tokenEndpoint, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/security/oAuth2Info/tokenEndpoint (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tokenEndpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tokenEndpoint() directly.

    YANG Description: The token endpoint
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tokenEndpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tokenEndpoint must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tokenEndpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
        })

    self.__tokenEndpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tokenEndpoint(self):
    self.__tokenEndpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tokenEndpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

  grantTypes = __builtin__.property(_get_grantTypes, _set_grantTypes)
  tokenEndpoint = __builtin__.property(_get_tokenEndpoint, _set_tokenEndpoint)


  _pyangbind_elements = OrderedDict([('grantTypes', grantTypes), ('tokenEndpoint', tokenEndpoint), ])


class yc_security_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_security(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDescriptor/service/transportsSupported/transport/security. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the security used by the transport
  """
  __slots__ = ('_path_helper', '_extmethods', '__oAuth2Info',)

  _yang_name = 'security'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oAuth2Info = YANGDynClass(base=yc_oAuth2Info_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_security_oAuth2Info, is_container='container', yang_name="oAuth2Info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDescriptor', 'service', 'transportsSupported', 'transport', 'security']

  def _get_oAuth2Info(self):
    """
    Getter method for oAuth2Info, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/security/oAuth2Info (container)

    YANG Description: Information about OAuth2 based security
    """
    return self.__oAuth2Info
      
  def _set_oAuth2Info(self, v, load=False):
    """
    Setter method for oAuth2Info, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/security/oAuth2Info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oAuth2Info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oAuth2Info() directly.

    YANG Description: Information about OAuth2 based security
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oAuth2Info_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_security_oAuth2Info, is_container='container', yang_name="oAuth2Info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oAuth2Info must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oAuth2Info_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_security_oAuth2Info, is_container='container', yang_name="oAuth2Info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__oAuth2Info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oAuth2Info(self):
    self.__oAuth2Info = YANGDynClass(base=yc_oAuth2Info_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_security_oAuth2Info, is_container='container', yang_name="oAuth2Info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  oAuth2Info = __builtin__.property(_get_oAuth2Info, _set_oAuth2Info)


  _pyangbind_elements = OrderedDict([('oAuth2Info', oAuth2Info), ])


class yc_transport_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDescriptor/service/transportsSupported/transport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the transport
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__description','__type','__protocol','__version','__endpoint','__security',)

  _yang_name = 'transport'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__endpoint = YANGDynClass(base=yc_endpoint_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_endpoint, is_container='container', yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDescriptor', 'service', 'transportsSupported', 'transport']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/id (string)

    YANG Description: The identifier of this transport
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The identifier of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/name (string)

    YANG Description: The name of this transport
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/description (string)

    YANG Description: Human-readable description of this transport
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human-readable description of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/type (enumeration)

    YANG Description: Type of the transport
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/protocol (string)

    YANG Description: The name of the protocol used
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: The name of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/version (string)

    YANG Description: The version of the protocol used
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_endpoint(self):
    """
    Getter method for endpoint, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint (container)

    YANG Description: Information about the endpoint to access the transport
    """
    return self.__endpoint
      
  def _set_endpoint(self, v, load=False):
    """
    Setter method for endpoint, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/endpoint (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endpoint() directly.

    YANG Description: Information about the endpoint to access the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endpoint_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_endpoint, is_container='container', yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endpoint must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endpoint_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_endpoint, is_container='container', yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__endpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endpoint(self):
    self.__endpoint = YANGDynClass(base=yc_endpoint_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_endpoint, is_container='container', yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_security(self):
    """
    Getter method for security, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/security (container)

    YANG Description: Information about the security used by the transport
    """
    return self.__security
      
  def _set_security(self, v, load=False):
    """
    Setter method for security, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport/security (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security() directly.

    YANG Description: Information about the security used by the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_security_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security(self):
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  version = __builtin__.property(_get_version, _set_version)
  endpoint = __builtin__.property(_get_endpoint, _set_endpoint)
  security = __builtin__.property(_get_security, _set_security)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('description', description), ('type', type), ('protocol', protocol), ('version', version), ('endpoint', endpoint), ('security', security), ])


class yc_transportsSupported_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDescriptor/service/transportsSupported. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Transports and serializers supported by the service
  """
  __slots__ = ('_path_helper', '_extmethods', '__transportId','__transport','__serializers',)

  _yang_name = 'transportsSupported'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transportId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transportId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {}, 'XML': {}, 'PROTOBUF3': {}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='SerializerType', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDescriptor', 'service', 'transportsSupported']

  def _get_transportId(self):
    """
    Getter method for transportId, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transportId (string)

    YANG Description: Unique identifier for the transport binding
    """
    return self.__transportId
      
  def _set_transportId(self, v, load=False):
    """
    Setter method for transportId, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transportId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transportId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transportId() directly.

    YANG Description: Unique identifier for the transport binding
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="transportId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transportId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transportId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__transportId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transportId(self):
    self.__transportId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transportId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport (container)

    YANG Description: Information about the transport
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Information about the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transport_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_serializers(self):
    """
    Getter method for serializers, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/serializers (SerializerType)

    YANG Description: Serializers supported for this transport binding
    """
    return self.__serializers
      
  def _set_serializers(self, v, load=False):
    """
    Setter method for serializers, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported/serializers (SerializerType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serializers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serializers() directly.

    YANG Description: Serializers supported for this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {}, 'XML': {}, 'PROTOBUF3': {}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='SerializerType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serializers must be of a type compatible with SerializerType""",
          'defined-type': "mec-app-descriptor:SerializerType",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {}, 'XML': {}, 'PROTOBUF3': {}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='SerializerType', is_config=True)""",
        })

    self.__serializers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serializers(self):
    self.__serializers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {}, 'XML': {}, 'PROTOBUF3': {}},)), is_leaf=False, yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='SerializerType', is_config=True)

  transportId = __builtin__.property(_get_transportId, _set_transportId)
  transport = __builtin__.property(_get_transport, _set_transport)
  serializers = __builtin__.property(_get_serializers, _set_serializers)


  _pyangbind_elements = OrderedDict([('transportId', transportId), ('transport', transport), ('serializers', serializers), ])


class yc_service_mec_app_descriptor__app_descriptor_ServiceDescriptor_service(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDescriptor/service. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__serName','__serCategory','__version','__transportsSupported',)

  _yang_name = 'service'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__serName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__serCategory = YANGDynClass(base=yc_serCategory_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_serCategory, is_container='container', yang_name="serCategory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__transportsSupported = YANGDynClass(base=YANGListType("transportId",yc_transportsSupported_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported, yang_name="transportsSupported", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='transportId', extensions=None), is_container='list', yang_name="transportsSupported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDescriptor', 'service']

  def _get_serName(self):
    """
    Getter method for serName, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serName (string)

    YANG Description: The name of the service, e.g. RNIS, LocationService
    """
    return self.__serName
      
  def _set_serName(self, v, load=False):
    """
    Setter method for serName, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serName() directly.

    YANG Description: The name of the service, e.g. RNIS, LocationService
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="serName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__serName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serName(self):
    self.__serName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_serCategory(self):
    """
    Getter method for serCategory, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serCategory (container)

    YANG Description: A Category reference of the service
    """
    return self.__serCategory
      
  def _set_serCategory(self, v, load=False):
    """
    Setter method for serCategory, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/serCategory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serCategory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serCategory() directly.

    YANG Description: A Category reference of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_serCategory_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_serCategory, is_container='container', yang_name="serCategory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serCategory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_serCategory_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_serCategory, is_container='container', yang_name="serCategory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__serCategory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serCategory(self):
    self.__serCategory = YANGDynClass(base=yc_serCategory_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_serCategory, is_container='container', yang_name="serCategory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/version (string)

    YANG Description: The version of the service
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_transportsSupported(self):
    """
    Getter method for transportsSupported, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported (list)

    YANG Description: Transports and serializers supported by the service
    """
    return self.__transportsSupported
      
  def _set_transportsSupported(self, v, load=False):
    """
    Setter method for transportsSupported, mapped from YANG variable /app_descriptor/ServiceDescriptor/service/transportsSupported (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transportsSupported is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transportsSupported() directly.

    YANG Description: Transports and serializers supported by the service
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("transportId",yc_transportsSupported_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported, yang_name="transportsSupported", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='transportId', extensions=None), is_container='list', yang_name="transportsSupported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transportsSupported must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("transportId",yc_transportsSupported_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported, yang_name="transportsSupported", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='transportId', extensions=None), is_container='list', yang_name="transportsSupported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__transportsSupported = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transportsSupported(self):
    self.__transportsSupported = YANGDynClass(base=YANGListType("transportId",yc_transportsSupported_mec_app_descriptor__app_descriptor_ServiceDescriptor_service_transportsSupported, yang_name="transportsSupported", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='transportId', extensions=None), is_container='list', yang_name="transportsSupported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  serName = __builtin__.property(_get_serName, _set_serName)
  serCategory = __builtin__.property(_get_serCategory, _set_serCategory)
  version = __builtin__.property(_get_version, _set_version)
  transportsSupported = __builtin__.property(_get_transportsSupported, _set_transportsSupported)


  _pyangbind_elements = OrderedDict([('serName', serName), ('serCategory', serCategory), ('version', version), ('transportsSupported', transportsSupported), ])


class yc_ServiceDescriptor_mec_app_descriptor__app_descriptor_ServiceDescriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ServiceDescriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Service Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__service',)

  _yang_name = 'ServiceDescriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__service = YANGDynClass(base=YANGListType("serName",yc_service_mec_app_descriptor__app_descriptor_ServiceDescriptor_service, yang_name="service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serName', extensions=None), is_container='list', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ServiceDescriptor']

  def _get_service(self):
    """
    Getter method for service, mapped from YANG variable /app_descriptor/ServiceDescriptor/service (list)
    """
    return self.__service
      
  def _set_service(self, v, load=False):
    """
    Setter method for service, mapped from YANG variable /app_descriptor/ServiceDescriptor/service (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("serName",yc_service_mec_app_descriptor__app_descriptor_ServiceDescriptor_service, yang_name="service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serName', extensions=None), is_container='list', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("serName",yc_service_mec_app_descriptor__app_descriptor_ServiceDescriptor_service, yang_name="service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serName', extensions=None), is_container='list', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__service = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service(self):
    self.__service = YANGDynClass(base=YANGListType("serName",yc_service_mec_app_descriptor__app_descriptor_ServiceDescriptor_service, yang_name="service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serName', extensions=None), is_container='list', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  service = __builtin__.property(_get_service, _set_service)


  _pyangbind_elements = OrderedDict([('service', service), ])


class yc_FeatureDependencyId_mec_app_descriptor__app_descriptor_FeatureDependency_FeatureDependencyId(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/FeatureDependency/FeatureDependencyId. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for feature dependency attributes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__featureName','__version',)

  _yang_name = 'FeatureDependencyId'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__featureName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="featureName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'FeatureDependency', 'FeatureDependencyId']

  def _get_featureName(self):
    """
    Getter method for featureName, mapped from YANG variable /app_descriptor/FeatureDependency/FeatureDependencyId/featureName (string)

    YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
    """
    return self.__featureName
      
  def _set_featureName(self, v, load=False):
    """
    Setter method for featureName, mapped from YANG variable /app_descriptor/FeatureDependency/FeatureDependencyId/featureName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_featureName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_featureName() directly.

    YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="featureName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """featureName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="featureName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__featureName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_featureName(self):
    self.__featureName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="featureName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/FeatureDependency/FeatureDependencyId/version (string)

    YANG Description: The version of the feature.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/FeatureDependency/FeatureDependencyId/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  featureName = __builtin__.property(_get_featureName, _set_featureName)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('featureName', featureName), ('version', version), ])


class yc_FeatureDependency_mec_app_descriptor__app_descriptor_FeatureDependency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/FeatureDependency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Feature Dependency into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__FeatureDependencyId',)

  _yang_name = 'FeatureDependency'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__FeatureDependencyId = YANGDynClass(base=yc_FeatureDependencyId_mec_app_descriptor__app_descriptor_FeatureDependency_FeatureDependencyId, is_container='container', yang_name="FeatureDependencyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'FeatureDependency']

  def _get_FeatureDependencyId(self):
    """
    Getter method for FeatureDependencyId, mapped from YANG variable /app_descriptor/FeatureDependency/FeatureDependencyId (container)

    YANG Description: Container for feature dependency attributes.
    """
    return self.__FeatureDependencyId
      
  def _set_FeatureDependencyId(self, v, load=False):
    """
    Setter method for FeatureDependencyId, mapped from YANG variable /app_descriptor/FeatureDependency/FeatureDependencyId (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_FeatureDependencyId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_FeatureDependencyId() directly.

    YANG Description: Container for feature dependency attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_FeatureDependencyId_mec_app_descriptor__app_descriptor_FeatureDependency_FeatureDependencyId, is_container='container', yang_name="FeatureDependencyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """FeatureDependencyId must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_FeatureDependencyId_mec_app_descriptor__app_descriptor_FeatureDependency_FeatureDependencyId, is_container='container', yang_name="FeatureDependencyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__FeatureDependencyId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_FeatureDependencyId(self):
    self.__FeatureDependencyId = YANGDynClass(base=yc_FeatureDependencyId_mec_app_descriptor__app_descriptor_FeatureDependency_FeatureDependencyId, is_container='container', yang_name="FeatureDependencyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  FeatureDependencyId = __builtin__.property(_get_FeatureDependencyId, _set_FeatureDependencyId)


  _pyangbind_elements = OrderedDict([('FeatureDependencyId', FeatureDependencyId), ])


class yc_addresses_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_endpoint_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TransportDependency/transportDependency/transport/endpoint/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Entry point information as IP address and port
  """
  __slots__ = ('_path_helper', '_extmethods', '__host','__port',)

  _yang_name = 'addresses'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__host = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', 'length': ['1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:host', is_config=True)
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TransportDependency', 'transportDependency', 'transport', 'endpoint', 'addresses']

  def _get_host(self):
    """
    Getter method for host, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/endpoint/addresses/host (inet:host)

    YANG Description: IP address of the entry point
    """
    return self.__host
      
  def _set_host(self, v, load=False):
    """
    Setter method for host, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/endpoint/addresses/host (inet:host)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host() directly.

    YANG Description: IP address of the entry point
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', 'length': ['1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:host', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """host must be of a type compatible with inet:host""",
          'defined-type': "inet:host",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', 'length': ['1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:host', is_config=True)""",
        })

    self.__host = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_host(self):
    self.__host = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', 'length': ['1..253']}),], is_leaf=True, yang_name="host", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:host', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/endpoint/addresses/port (inet:port-number)

    YANG Description: Port of the entry point
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/endpoint/addresses/port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: Port of the entry point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)

  host = __builtin__.property(_get_host, _set_host)
  port = __builtin__.property(_get_port, _set_port)


  _pyangbind_elements = OrderedDict([('host', host), ('port', port), ])


class yc_endpoint_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_endpoint(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TransportDependency/transportDependency/transport/endpoint. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the endpoint to access the transport
  """
  __slots__ = ('_path_helper', '_extmethods', '__uris','__addresses',)

  _yang_name = 'endpoint'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uris = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uris", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)
    self.__addresses = YANGDynClass(base=YANGListType("host",yc_addresses_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_endpoint_addresses, yang_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TransportDependency', 'transportDependency', 'transport', 'endpoint']

  def _get_uris(self):
    """
    Getter method for uris, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/endpoint/uris (inet:uri)

    YANG Description: Entry point information of the service as URI
    """
    return self.__uris
      
  def _set_uris(self, v, load=False):
    """
    Setter method for uris, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/endpoint/uris (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uris is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uris() directly.

    YANG Description: Entry point information of the service as URI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uris", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uris must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uris", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
        })

    self.__uris = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uris(self):
    self.__uris = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uris", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/endpoint/addresses (list)

    YANG Description: Entry point information as IP address and port
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/endpoint/addresses (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: Entry point information as IP address and port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("host",yc_addresses_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_endpoint_addresses, yang_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("host",yc_addresses_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_endpoint_addresses, yang_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=YANGListType("host",yc_addresses_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_endpoint_addresses, yang_name="addresses", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='host', extensions=None), is_container='list', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  uris = __builtin__.property(_get_uris, _set_uris)
  addresses = __builtin__.property(_get_addresses, _set_addresses)


  _pyangbind_elements = OrderedDict([('uris', uris), ('addresses', addresses), ])


class yc_oAuth2Info_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_security_oAuth2Info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TransportDependency/transportDependency/transport/security/oAuth2Info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about OAuth2 based security
  """
  __slots__ = ('_path_helper', '_extmethods', '__grantTypes','__tokenEndpoint',)

  _yang_name = 'oAuth2Info'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__grantTypes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grantTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__tokenEndpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tokenEndpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TransportDependency', 'transportDependency', 'transport', 'security', 'oAuth2Info']

  def _get_grantTypes(self):
    """
    Getter method for grantTypes, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/security/oAuth2Info/grantTypes (enumeration)

    YANG Description: Supported OAuth2 grant types
    """
    return self.__grantTypes
      
  def _set_grantTypes(self, v, load=False):
    """
    Setter method for grantTypes, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/security/oAuth2Info/grantTypes (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grantTypes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grantTypes() directly.

    YANG Description: Supported OAuth2 grant types
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grantTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grantTypes must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grantTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__grantTypes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grantTypes(self):
    self.__grantTypes = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'OAUTH2_AUTHORIZATION_CODE': {}, 'OAUTH2_IMPLICIT_GRANT': {}, 'OAUTH2_RESOURCE_OWNER': {}, 'OAUTH2_CLIENT_CREDENTIALS': {}},)), is_leaf=False, yang_name="grantTypes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_tokenEndpoint(self):
    """
    Getter method for tokenEndpoint, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/security/oAuth2Info/tokenEndpoint (inet:uri)

    YANG Description: The token endpoint
    """
    return self.__tokenEndpoint
      
  def _set_tokenEndpoint(self, v, load=False):
    """
    Setter method for tokenEndpoint, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/security/oAuth2Info/tokenEndpoint (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tokenEndpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tokenEndpoint() directly.

    YANG Description: The token endpoint
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tokenEndpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tokenEndpoint must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tokenEndpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)""",
        })

    self.__tokenEndpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tokenEndpoint(self):
    self.__tokenEndpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tokenEndpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:uri', is_config=True)

  grantTypes = __builtin__.property(_get_grantTypes, _set_grantTypes)
  tokenEndpoint = __builtin__.property(_get_tokenEndpoint, _set_tokenEndpoint)


  _pyangbind_elements = OrderedDict([('grantTypes', grantTypes), ('tokenEndpoint', tokenEndpoint), ])


class yc_security_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_security(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TransportDependency/transportDependency/transport/security. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the security used by the transport
  """
  __slots__ = ('_path_helper', '_extmethods', '__oAuth2Info',)

  _yang_name = 'security'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oAuth2Info = YANGDynClass(base=yc_oAuth2Info_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_security_oAuth2Info, is_container='container', yang_name="oAuth2Info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TransportDependency', 'transportDependency', 'transport', 'security']

  def _get_oAuth2Info(self):
    """
    Getter method for oAuth2Info, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/security/oAuth2Info (container)

    YANG Description: Information about OAuth2 based security
    """
    return self.__oAuth2Info
      
  def _set_oAuth2Info(self, v, load=False):
    """
    Setter method for oAuth2Info, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/security/oAuth2Info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oAuth2Info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oAuth2Info() directly.

    YANG Description: Information about OAuth2 based security
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_oAuth2Info_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_security_oAuth2Info, is_container='container', yang_name="oAuth2Info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oAuth2Info must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_oAuth2Info_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_security_oAuth2Info, is_container='container', yang_name="oAuth2Info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__oAuth2Info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oAuth2Info(self):
    self.__oAuth2Info = YANGDynClass(base=yc_oAuth2Info_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_security_oAuth2Info, is_container='container', yang_name="oAuth2Info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  oAuth2Info = __builtin__.property(_get_oAuth2Info, _set_oAuth2Info)


  _pyangbind_elements = OrderedDict([('oAuth2Info', oAuth2Info), ])


class yc_transport_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TransportDependency/transportDependency/transport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the transport in this transport binding
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__description','__type','__protocol','__version','__endpoint','__security',)

  _yang_name = 'transport'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='TransportType', is_config=True)
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__endpoint = YANGDynClass(base=yc_endpoint_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_endpoint, is_container='container', yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TransportDependency', 'transportDependency', 'transport']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/id (string)

    YANG Description: The identifier of this transport
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The identifier of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/name (string)

    YANG Description: The name of this transport
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/description (string)

    YANG Description: Human-readable description of this transport
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human-readable description of this transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/type (TransportType)

    YANG Description: Type of the transport
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/type (TransportType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='TransportType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with TransportType""",
          'defined-type': "mec-app-descriptor:TransportType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='TransportType', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'REST_HTTP': {}, 'MB_TOPIC_BASED': {}, 'MB_ROUTING': {}, 'MB_PUBSUB': {}, 'RPC': {}, 'RPC_STREAMING': {}, 'WEBSOCKET': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='TransportType', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/protocol (string)

    YANG Description: The name of the protocol used
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/protocol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: The name of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/version (string)

    YANG Description: The version of the protocol used
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the protocol used
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_endpoint(self):
    """
    Getter method for endpoint, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/endpoint (container)

    YANG Description: Information about the endpoint to access the transport
    """
    return self.__endpoint
      
  def _set_endpoint(self, v, load=False):
    """
    Setter method for endpoint, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/endpoint (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endpoint() directly.

    YANG Description: Information about the endpoint to access the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_endpoint_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_endpoint, is_container='container', yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """endpoint must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_endpoint_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_endpoint, is_container='container', yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__endpoint = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_endpoint(self):
    self.__endpoint = YANGDynClass(base=yc_endpoint_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_endpoint, is_container='container', yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_security(self):
    """
    Getter method for security, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/security (container)

    YANG Description: Information about the security used by the transport
    """
    return self.__security
      
  def _set_security(self, v, load=False):
    """
    Setter method for security, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport/security (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security() directly.

    YANG Description: Information about the security used by the transport
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_security_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """security must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_security(self):
    self.__security = YANGDynClass(base=yc_security_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport_security, is_container='container', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  type = __builtin__.property(_get_type, _set_type)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  version = __builtin__.property(_get_version, _set_version)
  endpoint = __builtin__.property(_get_endpoint, _set_endpoint)
  security = __builtin__.property(_get_security, _set_security)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('description', description), ('type', type), ('protocol', protocol), ('version', version), ('endpoint', endpoint), ('security', security), ])


class yc_serializers_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_serializers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TransportDependency/transportDependency/serializers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the serializers in this transport binding
  """
  __slots__ = ('_path_helper', '_extmethods', '__serializerType',)

  _yang_name = 'serializers'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__serializerType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {}, 'XML': {}, 'PROTOBUF3': {}},), is_leaf=True, yang_name="serializerType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='SerializerType', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TransportDependency', 'transportDependency', 'serializers']

  def _get_serializerType(self):
    """
    Getter method for serializerType, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/serializers/serializerType (SerializerType)

    YANG Description: Type of serializer
    """
    return self.__serializerType
      
  def _set_serializerType(self, v, load=False):
    """
    Setter method for serializerType, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/serializers/serializerType (SerializerType)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serializerType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serializerType() directly.

    YANG Description: Type of serializer
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {}, 'XML': {}, 'PROTOBUF3': {}},), is_leaf=True, yang_name="serializerType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='SerializerType', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serializerType must be of a type compatible with SerializerType""",
          'defined-type': "mec-app-descriptor:SerializerType",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {}, 'XML': {}, 'PROTOBUF3': {}},), is_leaf=True, yang_name="serializerType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='SerializerType', is_config=True)""",
        })

    self.__serializerType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serializerType(self):
    self.__serializerType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'JSON': {}, 'XML': {}, 'PROTOBUF3': {}},), is_leaf=True, yang_name="serializerType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='SerializerType', is_config=True)

  serializerType = __builtin__.property(_get_serializerType, _set_serializerType)


  _pyangbind_elements = OrderedDict([('serializerType', serializerType), ])


class yc_transportDependency_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TransportDependency/transportDependency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of transport dependencies
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__transport','__serializers','__labels',)

  _yang_name = 'transportDependency'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__serializers = YANGDynClass(base=YANGListType("serializerType",yc_serializers_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_serializers, yang_name="serializers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serializerType', extensions=None), is_container='list', yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__labels = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TransportDependency', 'transportDependency']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/id (string)

    YANG Description: Unique identifier for the transport dependency
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for the transport dependency
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport (container)

    YANG Description: Information about the transport in this transport binding
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Information about the transport in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transport_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=yc_transport_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_serializers(self):
    """
    Getter method for serializers, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/serializers (list)

    YANG Description: Information about the serializers in this transport binding
    """
    return self.__serializers
      
  def _set_serializers(self, v, load=False):
    """
    Setter method for serializers, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/serializers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serializers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serializers() directly.

    YANG Description: Information about the serializers in this transport binding
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("serializerType",yc_serializers_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_serializers, yang_name="serializers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serializerType', extensions=None), is_container='list', yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serializers must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("serializerType",yc_serializers_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_serializers, yang_name="serializers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serializerType', extensions=None), is_container='list', yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__serializers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serializers(self):
    self.__serializers = YANGDynClass(base=YANGListType("serializerType",yc_serializers_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency_serializers, yang_name="serializers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serializerType', extensions=None), is_container='list', yang_name="serializers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_labels(self):
    """
    Getter method for labels, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/labels (string)

    YANG Description: Set of labels that allow to define groups of transport bindings
    """
    return self.__labels
      
  def _set_labels(self, v, load=False):
    """
    Setter method for labels, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency/labels (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_labels is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_labels() directly.

    YANG Description: Set of labels that allow to define groups of transport bindings
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """labels must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__labels = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_labels(self):
    self.__labels = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="labels", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  transport = __builtin__.property(_get_transport, _set_transport)
  serializers = __builtin__.property(_get_serializers, _set_serializers)
  labels = __builtin__.property(_get_labels, _set_labels)


  _pyangbind_elements = OrderedDict([('id', id), ('transport', transport), ('serializers', serializers), ('labels', labels), ])


class yc_TransportDependency_mec_app_descriptor__app_descriptor_TransportDependency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TransportDependency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Transport Dependency into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__transportDependency',)

  _yang_name = 'TransportDependency'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transportDependency = YANGDynClass(base=YANGListType("id",yc_transportDependency_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency, yang_name="transportDependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transportDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TransportDependency']

  def _get_transportDependency(self):
    """
    Getter method for transportDependency, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency (list)

    YANG Description: List of transport dependencies
    """
    return self.__transportDependency
      
  def _set_transportDependency(self, v, load=False):
    """
    Setter method for transportDependency, mapped from YANG variable /app_descriptor/TransportDependency/transportDependency (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transportDependency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transportDependency() directly.

    YANG Description: List of transport dependencies
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_transportDependency_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency, yang_name="transportDependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transportDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transportDependency must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_transportDependency_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency, yang_name="transportDependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transportDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__transportDependency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transportDependency(self):
    self.__transportDependency = YANGDynClass(base=YANGListType("id",yc_transportDependency_mec_app_descriptor__app_descriptor_TransportDependency_transportDependency, yang_name="transportDependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="transportDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  transportDependency = __builtin__.property(_get_transportDependency, _set_transportDependency)


  _pyangbind_elements = OrderedDict([('transportDependency', transportDependency), ])


class yc_trafficFilter_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_trafficFilter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Filter to identify specific flow/packets
  """
  __slots__ = ('_path_helper', '_extmethods', '__filterId','__srcAddress','__dstAddress','__srcPort','__dstPort','__protocol','__tag','__uri','__packetLabel','__srcTunnelAddress','__tgtTunnelAddress','__srcTunnelPort','__dstTunnelPort','__qCI','__dSCP','__tC',)

  _yang_name = 'trafficFilter'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__filterId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="filterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__srcAddress = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="srcAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    self.__dstAddress = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="dstAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    self.__srcPort = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="srcPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    self.__dstPort = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dstPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    self.__protocol = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    self.__tag = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__uri = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__packetLabel = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="packetLabel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__srcTunnelAddress = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="srcTunnelAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    self.__tgtTunnelAddress = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="tgtTunnelAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    self.__srcTunnelPort = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="srcTunnelPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    self.__dstTunnelPort = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dstTunnelPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    self.__qCI = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="qCI", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    self.__dSCP = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dSCP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    self.__tC = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TrafficRuleDescriptor', 'trafficRule', 'trafficFilter']

  def _get_filterId(self):
    """
    Getter method for filterId, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/filterId (string)

    YANG Description: Unique identifier for the traffic filter
    """
    return self.__filterId
      
  def _set_filterId(self, v, load=False):
    """
    Setter method for filterId, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/filterId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filterId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filterId() directly.

    YANG Description: Unique identifier for the traffic filter
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="filterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filterId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="filterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__filterId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filterId(self):
    self.__filterId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="filterId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_srcAddress(self):
    """
    Getter method for srcAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/srcAddress (inet:ip-address)

    YANG Description: An IP address or a range of IP addresses
    """
    return self.__srcAddress
      
  def _set_srcAddress(self, v, load=False):
    """
    Setter method for srcAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/srcAddress (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srcAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srcAddress() directly.

    YANG Description: An IP address or a range of IP addresses
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="srcAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srcAddress must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="srcAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__srcAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srcAddress(self):
    self.__srcAddress = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="srcAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)


  def _get_dstAddress(self):
    """
    Getter method for dstAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/dstAddress (inet:ip-address)

    YANG Description: An IP address or a range of IP addresses
    """
    return self.__dstAddress
      
  def _set_dstAddress(self, v, load=False):
    """
    Setter method for dstAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/dstAddress (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dstAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dstAddress() directly.

    YANG Description: An IP address or a range of IP addresses
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="dstAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dstAddress must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="dstAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__dstAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dstAddress(self):
    self.__dstAddress = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="dstAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)


  def _get_srcPort(self):
    """
    Getter method for srcPort, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/srcPort (inet:port-number)

    YANG Description: A port or a range of ports
    """
    return self.__srcPort
      
  def _set_srcPort(self, v, load=False):
    """
    Setter method for srcPort, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/srcPort (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srcPort is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srcPort() directly.

    YANG Description: A port or a range of ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="srcPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srcPort must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="srcPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
        })

    self.__srcPort = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srcPort(self):
    self.__srcPort = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="srcPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)


  def _get_dstPort(self):
    """
    Getter method for dstPort, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/dstPort (inet:port-number)

    YANG Description: A port or a range of ports
    """
    return self.__dstPort
      
  def _set_dstPort(self, v, load=False):
    """
    Setter method for dstPort, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/dstPort (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dstPort is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dstPort() directly.

    YANG Description: A port or a range of ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dstPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dstPort must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dstPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
        })

    self.__dstPort = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dstPort(self):
    self.__dstPort = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dstPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)


  def _get_protocol(self):
    """
    Getter method for protocol, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/protocol (uint8)

    YANG Description: Specify the protocol of the traffic filter
    """
    return self.__protocol
      
  def _set_protocol(self, v, load=False):
    """
    Setter method for protocol, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/protocol (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Specify the protocol of the traffic filter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
        })

    self.__protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol(self):
    self.__protocol = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)), is_leaf=False, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)


  def _get_tag(self):
    """
    Getter method for tag, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/tag (string)

    YANG Description: Used for tag based traffic rule
    """
    return self.__tag
      
  def _set_tag(self, v, load=False):
    """
    Setter method for tag, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tag() directly.

    YANG Description: Used for tag based traffic rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tag must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tag(self):
    self.__tag = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_uri(self):
    """
    Getter method for uri, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/uri (string)

    YANG Description: An URI label used to filter the traffic
    """
    return self.__uri
      
  def _set_uri(self, v, load=False):
    """
    Setter method for uri, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/uri (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uri is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uri() directly.

    YANG Description: An URI label used to filter the traffic
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uri must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__uri = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uri(self):
    self.__uri = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_packetLabel(self):
    """
    Getter method for packetLabel, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/packetLabel (string)

    YANG Description: A customized packet label used to filter traffic
    """
    return self.__packetLabel
      
  def _set_packetLabel(self, v, load=False):
    """
    Setter method for packetLabel, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/packetLabel (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packetLabel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packetLabel() directly.

    YANG Description: A customized packet label used to filter traffic
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="packetLabel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packetLabel must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="packetLabel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__packetLabel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packetLabel(self):
    self.__packetLabel = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="packetLabel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_srcTunnelAddress(self):
    """
    Getter method for srcTunnelAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/srcTunnelAddress (inet:ip-address)

    YANG Description: Used for GTP tunnel based traffic rule
    """
    return self.__srcTunnelAddress
      
  def _set_srcTunnelAddress(self, v, load=False):
    """
    Setter method for srcTunnelAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/srcTunnelAddress (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srcTunnelAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srcTunnelAddress() directly.

    YANG Description: Used for GTP tunnel based traffic rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="srcTunnelAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srcTunnelAddress must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="srcTunnelAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__srcTunnelAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srcTunnelAddress(self):
    self.__srcTunnelAddress = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="srcTunnelAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)


  def _get_tgtTunnelAddress(self):
    """
    Getter method for tgtTunnelAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/tgtTunnelAddress (inet:ip-address)

    YANG Description: Used for GTP tunnel based traffic rule
    """
    return self.__tgtTunnelAddress
      
  def _set_tgtTunnelAddress(self, v, load=False):
    """
    Setter method for tgtTunnelAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/tgtTunnelAddress (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tgtTunnelAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tgtTunnelAddress() directly.

    YANG Description: Used for GTP tunnel based traffic rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="tgtTunnelAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tgtTunnelAddress must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="tgtTunnelAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__tgtTunnelAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tgtTunnelAddress(self):
    self.__tgtTunnelAddress = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="tgtTunnelAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)


  def _get_srcTunnelPort(self):
    """
    Getter method for srcTunnelPort, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/srcTunnelPort (inet:port-number)

    YANG Description: Used for GTP tunnel based traffic rule
    """
    return self.__srcTunnelPort
      
  def _set_srcTunnelPort(self, v, load=False):
    """
    Setter method for srcTunnelPort, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/srcTunnelPort (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srcTunnelPort is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srcTunnelPort() directly.

    YANG Description: Used for GTP tunnel based traffic rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="srcTunnelPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srcTunnelPort must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="srcTunnelPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
        })

    self.__srcTunnelPort = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srcTunnelPort(self):
    self.__srcTunnelPort = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="srcTunnelPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)


  def _get_dstTunnelPort(self):
    """
    Getter method for dstTunnelPort, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/dstTunnelPort (inet:port-number)

    YANG Description: Used for GTP tunnel based traffic rule
    """
    return self.__dstTunnelPort
      
  def _set_dstTunnelPort(self, v, load=False):
    """
    Setter method for dstTunnelPort, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/dstTunnelPort (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dstTunnelPort is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dstTunnelPort() directly.

    YANG Description: Used for GTP tunnel based traffic rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dstTunnelPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dstTunnelPort must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dstTunnelPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)""",
        })

    self.__dstTunnelPort = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dstTunnelPort(self):
    self.__dstTunnelPort = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']})), is_leaf=False, yang_name="dstTunnelPort", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:port-number', is_config=True)


  def _get_qCI(self):
    """
    Getter method for qCI, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/qCI (uint8)

    YANG Description: Used to match all packets that have the same QCI
    """
    return self.__qCI
      
  def _set_qCI(self, v, load=False):
    """
    Setter method for qCI, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/qCI (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qCI is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qCI() directly.

    YANG Description: Used to match all packets that have the same QCI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="qCI", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qCI must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="qCI", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
        })

    self.__qCI = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qCI(self):
    self.__qCI = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="qCI", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)


  def _get_dSCP(self):
    """
    Getter method for dSCP, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/dSCP (uint8)

    YANG Description: Used to match all IPv4 packets with same DSCP
    """
    return self.__dSCP
      
  def _set_dSCP(self, v, load=False):
    """
    Setter method for dSCP, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/dSCP (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dSCP is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dSCP() directly.

    YANG Description: Used to match all IPv4 packets with same DSCP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dSCP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dSCP must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dSCP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
        })

    self.__dSCP = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dSCP(self):
    self.__dSCP = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="dSCP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)


  def _get_tC(self):
    """
    Getter method for tC, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/tC (uint8)

    YANG Description: Used to match all IPv6 packets with same TC
    """
    return self.__tC
      
  def _set_tC(self, v, load=False):
    """
    Setter method for tC, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter/tC (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tC is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tC() directly.

    YANG Description: Used to match all IPv6 packets with same TC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tC must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
        })

    self.__tC = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tC(self):
    self.__tC = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="tC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)

  filterId = __builtin__.property(_get_filterId, _set_filterId)
  srcAddress = __builtin__.property(_get_srcAddress, _set_srcAddress)
  dstAddress = __builtin__.property(_get_dstAddress, _set_dstAddress)
  srcPort = __builtin__.property(_get_srcPort, _set_srcPort)
  dstPort = __builtin__.property(_get_dstPort, _set_dstPort)
  protocol = __builtin__.property(_get_protocol, _set_protocol)
  tag = __builtin__.property(_get_tag, _set_tag)
  uri = __builtin__.property(_get_uri, _set_uri)
  packetLabel = __builtin__.property(_get_packetLabel, _set_packetLabel)
  srcTunnelAddress = __builtin__.property(_get_srcTunnelAddress, _set_srcTunnelAddress)
  tgtTunnelAddress = __builtin__.property(_get_tgtTunnelAddress, _set_tgtTunnelAddress)
  srcTunnelPort = __builtin__.property(_get_srcTunnelPort, _set_srcTunnelPort)
  dstTunnelPort = __builtin__.property(_get_dstTunnelPort, _set_dstTunnelPort)
  qCI = __builtin__.property(_get_qCI, _set_qCI)
  dSCP = __builtin__.property(_get_dSCP, _set_dSCP)
  tC = __builtin__.property(_get_tC, _set_tC)


  _pyangbind_elements = OrderedDict([('filterId', filterId), ('srcAddress', srcAddress), ('dstAddress', dstAddress), ('srcPort', srcPort), ('dstPort', dstPort), ('protocol', protocol), ('tag', tag), ('uri', uri), ('packetLabel', packetLabel), ('srcTunnelAddress', srcTunnelAddress), ('tgtTunnelAddress', tgtTunnelAddress), ('srcTunnelPort', srcTunnelPort), ('dstTunnelPort', dstTunnelPort), ('qCI', qCI), ('dSCP', dSCP), ('tC', tC), ])


class yc_tunnelInfo_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_dstInterface_tunnelInfo(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/tunnelInfo. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Included only if interfaceType is TUNNEL
  """
  __slots__ = ('_path_helper', '_extmethods', '__tunnelType','__tunnelDstAddress','__tunnelSrcAddress',)

  _yang_name = 'tunnelInfo'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tunnelType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GTP-U': {}, 'GRE': {}},), is_leaf=True, yang_name="tunnelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__tunnelDstAddress = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnelDstAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    self.__tunnelSrcAddress = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnelSrcAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TrafficRuleDescriptor', 'trafficRule', 'dstInterface', 'tunnelInfo']

  def _get_tunnelType(self):
    """
    Getter method for tunnelType, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/tunnelInfo/tunnelType (enumeration)

    YANG Description: Type of tunnel: GTP-U, GRE, etc
    """
    return self.__tunnelType
      
  def _set_tunnelType(self, v, load=False):
    """
    Setter method for tunnelType, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/tunnelInfo/tunnelType (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnelType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnelType() directly.

    YANG Description: Type of tunnel: GTP-U, GRE, etc
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GTP-U': {}, 'GRE': {}},), is_leaf=True, yang_name="tunnelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnelType must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GTP-U': {}, 'GRE': {}},), is_leaf=True, yang_name="tunnelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__tunnelType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnelType(self):
    self.__tunnelType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GTP-U': {}, 'GRE': {}},), is_leaf=True, yang_name="tunnelType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_tunnelDstAddress(self):
    """
    Getter method for tunnelDstAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/tunnelInfo/tunnelDstAddress (inet:ip-address)

    YANG Description: Destination address of the tunnel
    """
    return self.__tunnelDstAddress
      
  def _set_tunnelDstAddress(self, v, load=False):
    """
    Setter method for tunnelDstAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/tunnelInfo/tunnelDstAddress (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnelDstAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnelDstAddress() directly.

    YANG Description: Destination address of the tunnel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnelDstAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnelDstAddress must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnelDstAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__tunnelDstAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnelDstAddress(self):
    self.__tunnelDstAddress = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnelDstAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)


  def _get_tunnelSrcAddress(self):
    """
    Getter method for tunnelSrcAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/tunnelInfo/tunnelSrcAddress (inet:ip-address)

    YANG Description: Source address of the tunnel
    """
    return self.__tunnelSrcAddress
      
  def _set_tunnelSrcAddress(self, v, load=False):
    """
    Setter method for tunnelSrcAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/tunnelInfo/tunnelSrcAddress (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnelSrcAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnelSrcAddress() directly.

    YANG Description: Source address of the tunnel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnelSrcAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnelSrcAddress must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnelSrcAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__tunnelSrcAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnelSrcAddress(self):
    self.__tunnelSrcAddress = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="tunnelSrcAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

  tunnelType = __builtin__.property(_get_tunnelType, _set_tunnelType)
  tunnelDstAddress = __builtin__.property(_get_tunnelDstAddress, _set_tunnelDstAddress)
  tunnelSrcAddress = __builtin__.property(_get_tunnelSrcAddress, _set_tunnelSrcAddress)


  _pyangbind_elements = OrderedDict([('tunnelType', tunnelType), ('tunnelDstAddress', tunnelDstAddress), ('tunnelSrcAddress', tunnelSrcAddress), ])


class yc_dstInterface_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_dstInterface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TrafficRuleDescriptor/trafficRule/dstInterface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Destination interface if action is FORWARD
  """
  __slots__ = ('_path_helper', '_extmethods', '__interfaceId','__interfaceType','__tunnelInfo','__srcMACAddress','__dstMACAddress','__dstIPAddress',)

  _yang_name = 'dstInterface'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interfaceId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interfaceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__interfaceType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'TUNNEL': {}, 'MAC': {}, 'IP': {}},), is_leaf=True, yang_name="interfaceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__tunnelInfo = YANGDynClass(base=yc_tunnelInfo_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_dstInterface_tunnelInfo, is_container='container', yang_name="tunnelInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__srcMACAddress = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="srcMACAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    self.__dstMACAddress = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="dstMACAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    self.__dstIPAddress = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="dstIPAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TrafficRuleDescriptor', 'trafficRule', 'dstInterface']

  def _get_interfaceId(self):
    """
    Getter method for interfaceId, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/interfaceId (string)

    YANG Description: Unique identifier for the interface
    """
    return self.__interfaceId
      
  def _set_interfaceId(self, v, load=False):
    """
    Setter method for interfaceId, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/interfaceId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaceId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaceId() directly.

    YANG Description: Unique identifier for the interface
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="interfaceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaceId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interfaceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__interfaceId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaceId(self):
    self.__interfaceId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interfaceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_interfaceType(self):
    """
    Getter method for interfaceType, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/interfaceType (enumeration)

    YANG Description: Type of interface: TUNNEL, MAC, IP, etc
    """
    return self.__interfaceType
      
  def _set_interfaceType(self, v, load=False):
    """
    Setter method for interfaceType, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/interfaceType (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaceType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaceType() directly.

    YANG Description: Type of interface: TUNNEL, MAC, IP, etc
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'TUNNEL': {}, 'MAC': {}, 'IP': {}},), is_leaf=True, yang_name="interfaceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaceType must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'TUNNEL': {}, 'MAC': {}, 'IP': {}},), is_leaf=True, yang_name="interfaceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__interfaceType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaceType(self):
    self.__interfaceType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'TUNNEL': {}, 'MAC': {}, 'IP': {}},), is_leaf=True, yang_name="interfaceType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_tunnelInfo(self):
    """
    Getter method for tunnelInfo, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/tunnelInfo (container)

    YANG Description: Included only if interfaceType is TUNNEL
    """
    return self.__tunnelInfo
      
  def _set_tunnelInfo(self, v, load=False):
    """
    Setter method for tunnelInfo, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/tunnelInfo (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnelInfo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnelInfo() directly.

    YANG Description: Included only if interfaceType is TUNNEL
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tunnelInfo_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_dstInterface_tunnelInfo, is_container='container', yang_name="tunnelInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnelInfo must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tunnelInfo_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_dstInterface_tunnelInfo, is_container='container', yang_name="tunnelInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__tunnelInfo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnelInfo(self):
    self.__tunnelInfo = YANGDynClass(base=yc_tunnelInfo_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_dstInterface_tunnelInfo, is_container='container', yang_name="tunnelInfo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_srcMACAddress(self):
    """
    Getter method for srcMACAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/srcMACAddress (yang:mac-address)

    YANG Description: Source MAC address if interfaceType is MAC
    """
    return self.__srcMACAddress
      
  def _set_srcMACAddress(self, v, load=False):
    """
    Setter method for srcMACAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/srcMACAddress (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srcMACAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srcMACAddress() directly.

    YANG Description: Source MAC address if interfaceType is MAC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="srcMACAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srcMACAddress must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="srcMACAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__srcMACAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srcMACAddress(self):
    self.__srcMACAddress = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="srcMACAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)


  def _get_dstMACAddress(self):
    """
    Getter method for dstMACAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/dstMACAddress (yang:mac-address)

    YANG Description: Destination MAC address if interfaceType is MAC
    """
    return self.__dstMACAddress
      
  def _set_dstMACAddress(self, v, load=False):
    """
    Setter method for dstMACAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/dstMACAddress (yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dstMACAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dstMACAddress() directly.

    YANG Description: Destination MAC address if interfaceType is MAC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="dstMACAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dstMACAddress must be of a type compatible with yang:mac-address""",
          'defined-type': "yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="dstMACAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)""",
        })

    self.__dstMACAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dstMACAddress(self):
    self.__dstMACAddress = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}'}), is_leaf=True, yang_name="dstMACAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='yang:mac-address', is_config=True)


  def _get_dstIPAddress(self):
    """
    Getter method for dstIPAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/dstIPAddress (inet:ip-address)

    YANG Description: Destination IP address if interfaceType is IP
    """
    return self.__dstIPAddress
      
  def _set_dstIPAddress(self, v, load=False):
    """
    Setter method for dstIPAddress, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface/dstIPAddress (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dstIPAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dstIPAddress() directly.

    YANG Description: Destination IP address if interfaceType is IP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="dstIPAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dstIPAddress must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="dstIPAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__dstIPAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dstIPAddress(self):
    self.__dstIPAddress = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="dstIPAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='inet:ip-address', is_config=True)

  interfaceId = __builtin__.property(_get_interfaceId, _set_interfaceId)
  interfaceType = __builtin__.property(_get_interfaceType, _set_interfaceType)
  tunnelInfo = __builtin__.property(_get_tunnelInfo, _set_tunnelInfo)
  srcMACAddress = __builtin__.property(_get_srcMACAddress, _set_srcMACAddress)
  dstMACAddress = __builtin__.property(_get_dstMACAddress, _set_dstMACAddress)
  dstIPAddress = __builtin__.property(_get_dstIPAddress, _set_dstIPAddress)


  _pyangbind_elements = OrderedDict([('interfaceId', interfaceId), ('interfaceType', interfaceType), ('tunnelInfo', tunnelInfo), ('srcMACAddress', srcMACAddress), ('dstMACAddress', dstMACAddress), ('dstIPAddress', dstIPAddress), ])


class yc_trafficRule_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TrafficRuleDescriptor/trafficRule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__trafficRuleId','__filterType','__priority','__trafficFilter','__action','__dstInterface',)

  _yang_name = 'trafficRule'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__trafficRuleId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficRuleId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='Identifier', is_config=True)
    self.__filterType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FLOW': {}, 'PACKET': {}},), is_leaf=True, yang_name="filterType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    self.__trafficFilter = YANGDynClass(base=YANGListType("filterId",yc_trafficFilter_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_trafficFilter, yang_name="trafficFilter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='filterId', extensions=None), is_container='list', yang_name="trafficFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DROP': {}, 'FORWARD_DECAPSULATED': {}, 'FORWARD_AS_IS': {}, 'PASSTHROUGH': {}, 'DUPLICATED_DECAPSULATED': {}, 'DUPLICATE_AS_IS': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__dstInterface = YANGDynClass(base=YANGListType("interfaceId",yc_dstInterface_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_dstInterface, yang_name="dstInterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interfaceId', extensions=None), is_container='list', yang_name="dstInterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TrafficRuleDescriptor', 'trafficRule']

  def _get_trafficRuleId(self):
    """
    Getter method for trafficRuleId, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficRuleId (Identifier)

    YANG Description: Identifies the traffic rule
    """
    return self.__trafficRuleId
      
  def _set_trafficRuleId(self, v, load=False):
    """
    Setter method for trafficRuleId, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficRuleId (Identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trafficRuleId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trafficRuleId() directly.

    YANG Description: Identifies the traffic rule
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="trafficRuleId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='Identifier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trafficRuleId must be of a type compatible with Identifier""",
          'defined-type': "mec-app-descriptor:Identifier",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficRuleId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='Identifier', is_config=True)""",
        })

    self.__trafficRuleId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trafficRuleId(self):
    self.__trafficRuleId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficRuleId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='Identifier', is_config=True)


  def _get_filterType(self):
    """
    Getter method for filterType, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/filterType (enumeration)

    YANG Description: Filter type: per FLOW or PACKET
    """
    return self.__filterType
      
  def _set_filterType(self, v, load=False):
    """
    Setter method for filterType, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/filterType (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_filterType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_filterType() directly.

    YANG Description: Filter type: per FLOW or PACKET
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FLOW': {}, 'PACKET': {}},), is_leaf=True, yang_name="filterType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """filterType must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FLOW': {}, 'PACKET': {}},), is_leaf=True, yang_name="filterType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__filterType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_filterType(self):
    self.__filterType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'FLOW': {}, 'PACKET': {}},), is_leaf=True, yang_name="filterType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/priority (uint8)

    YANG Description: Priority of traffic rule from 0 to 255
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Priority of traffic rule from 0 to 255
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint8', is_config=True)


  def _get_trafficFilter(self):
    """
    Getter method for trafficFilter, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter (list)

    YANG Description: Filter to identify specific flow/packets
    """
    return self.__trafficFilter
      
  def _set_trafficFilter(self, v, load=False):
    """
    Setter method for trafficFilter, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/trafficFilter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trafficFilter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trafficFilter() directly.

    YANG Description: Filter to identify specific flow/packets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("filterId",yc_trafficFilter_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_trafficFilter, yang_name="trafficFilter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='filterId', extensions=None), is_container='list', yang_name="trafficFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trafficFilter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("filterId",yc_trafficFilter_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_trafficFilter, yang_name="trafficFilter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='filterId', extensions=None), is_container='list', yang_name="trafficFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__trafficFilter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trafficFilter(self):
    self.__trafficFilter = YANGDynClass(base=YANGListType("filterId",yc_trafficFilter_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_trafficFilter, yang_name="trafficFilter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='filterId', extensions=None), is_container='list', yang_name="trafficFilter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/action (enumeration)

    YANG Description: Action when packet matches trafficFilter
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/action (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: Action when packet matches trafficFilter
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DROP': {}, 'FORWARD_DECAPSULATED': {}, 'FORWARD_AS_IS': {}, 'PASSTHROUGH': {}, 'DUPLICATED_DECAPSULATED': {}, 'DUPLICATE_AS_IS': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DROP': {}, 'FORWARD_DECAPSULATED': {}, 'FORWARD_AS_IS': {}, 'PASSTHROUGH': {}, 'DUPLICATED_DECAPSULATED': {}, 'DUPLICATE_AS_IS': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'DROP': {}, 'FORWARD_DECAPSULATED': {}, 'FORWARD_AS_IS': {}, 'PASSTHROUGH': {}, 'DUPLICATED_DECAPSULATED': {}, 'DUPLICATE_AS_IS': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_dstInterface(self):
    """
    Getter method for dstInterface, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface (list)

    YANG Description: Destination interface if action is FORWARD
    """
    return self.__dstInterface
      
  def _set_dstInterface(self, v, load=False):
    """
    Setter method for dstInterface, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule/dstInterface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dstInterface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dstInterface() directly.

    YANG Description: Destination interface if action is FORWARD
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("interfaceId",yc_dstInterface_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_dstInterface, yang_name="dstInterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interfaceId', extensions=None), is_container='list', yang_name="dstInterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dstInterface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("interfaceId",yc_dstInterface_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_dstInterface, yang_name="dstInterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interfaceId', extensions=None), is_container='list', yang_name="dstInterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__dstInterface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dstInterface(self):
    self.__dstInterface = YANGDynClass(base=YANGListType("interfaceId",yc_dstInterface_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule_dstInterface, yang_name="dstInterface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='interfaceId', extensions=None), is_container='list', yang_name="dstInterface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  trafficRuleId = __builtin__.property(_get_trafficRuleId, _set_trafficRuleId)
  filterType = __builtin__.property(_get_filterType, _set_filterType)
  priority = __builtin__.property(_get_priority, _set_priority)
  trafficFilter = __builtin__.property(_get_trafficFilter, _set_trafficFilter)
  action = __builtin__.property(_get_action, _set_action)
  dstInterface = __builtin__.property(_get_dstInterface, _set_dstInterface)


  _pyangbind_elements = OrderedDict([('trafficRuleId', trafficRuleId), ('filterType', filterType), ('priority', priority), ('trafficFilter', trafficFilter), ('action', action), ('dstInterface', dstInterface), ])


class yc_TrafficRuleDescriptor_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TrafficRuleDescriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Traffic Rule Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__trafficRule',)

  _yang_name = 'TrafficRuleDescriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__trafficRule = YANGDynClass(base=YANGListType("trafficRuleId",yc_trafficRule_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule, yang_name="trafficRule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trafficRuleId', extensions=None), is_container='list', yang_name="trafficRule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TrafficRuleDescriptor']

  def _get_trafficRule(self):
    """
    Getter method for trafficRule, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule (list)
    """
    return self.__trafficRule
      
  def _set_trafficRule(self, v, load=False):
    """
    Setter method for trafficRule, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor/trafficRule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trafficRule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trafficRule() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("trafficRuleId",yc_trafficRule_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule, yang_name="trafficRule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trafficRuleId', extensions=None), is_container='list', yang_name="trafficRule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trafficRule must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("trafficRuleId",yc_trafficRule_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule, yang_name="trafficRule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trafficRuleId', extensions=None), is_container='list', yang_name="trafficRule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__trafficRule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trafficRule(self):
    self.__trafficRule = YANGDynClass(base=YANGListType("trafficRuleId",yc_trafficRule_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor_trafficRule, yang_name="trafficRule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trafficRuleId', extensions=None), is_container='list', yang_name="trafficRule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  trafficRule = __builtin__.property(_get_trafficRule, _set_trafficRule)


  _pyangbind_elements = OrderedDict([('trafficRule', trafficRule), ])


class yc_dns_rule_descriptor_mec_app_descriptor__app_descriptor_DNSRuleDescriptor_dns_rule_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/DNSRuleDescriptor/dns-rule-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for DNS rule descriptor attributes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dnsRuleId','__domainName','__ipAddressType','__ipAddress','__ttl',)

  _yang_name = 'dns-rule-descriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dnsRuleId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dnsRuleId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__domainName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="domainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__ipAddressType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ipAddressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__ipAddress = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'DNSRuleDescriptor', 'dns-rule-descriptor']

  def _get_dnsRuleId(self):
    """
    Getter method for dnsRuleId, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor/dnsRuleId (string)

    YANG Description: Identifies the DNS Rule.
    """
    return self.__dnsRuleId
      
  def _set_dnsRuleId(self, v, load=False):
    """
    Setter method for dnsRuleId, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor/dnsRuleId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dnsRuleId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dnsRuleId() directly.

    YANG Description: Identifies the DNS Rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dnsRuleId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dnsRuleId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dnsRuleId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__dnsRuleId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dnsRuleId(self):
    self.__dnsRuleId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dnsRuleId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_domainName(self):
    """
    Getter method for domainName, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor/domainName (string)

    YANG Description: FQDN of the DNS rule.
    """
    return self.__domainName
      
  def _set_domainName(self, v, load=False):
    """
    Setter method for domainName, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor/domainName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domainName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domainName() directly.

    YANG Description: FQDN of the DNS rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="domainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domainName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="domainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__domainName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domainName(self):
    self.__domainName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="domainName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_ipAddressType(self):
    """
    Getter method for ipAddressType, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor/ipAddressType (enumeration)

    YANG Description: Specifies the IP address type, value: IP_V6, IP_V4.
    """
    return self.__ipAddressType
      
  def _set_ipAddressType(self, v, load=False):
    """
    Setter method for ipAddressType, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor/ipAddressType (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipAddressType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipAddressType() directly.

    YANG Description: Specifies the IP address type, value: IP_V6, IP_V4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ipAddressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipAddressType must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ipAddressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__ipAddressType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipAddressType(self):
    self.__ipAddressType = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ipAddressType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_ipAddress(self):
    """
    Getter method for ipAddress, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor/ipAddress (string)

    YANG Description: IP address given by the DNS rule.
    """
    return self.__ipAddress
      
  def _set_ipAddress(self, v, load=False):
    """
    Setter method for ipAddress, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor/ipAddress (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipAddress() directly.

    YANG Description: IP address given by the DNS rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipAddress must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__ipAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipAddress(self):
    self.__ipAddress = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_ttl(self):
    """
    Getter method for ttl, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor/ttl (uint32)

    YANG Description: Time-to-live value.
    """
    return self.__ttl
      
  def _set_ttl(self, v, load=False):
    """
    Setter method for ttl, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor/ttl (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl() directly.

    YANG Description: Time-to-live value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl(self):
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

  dnsRuleId = __builtin__.property(_get_dnsRuleId, _set_dnsRuleId)
  domainName = __builtin__.property(_get_domainName, _set_domainName)
  ipAddressType = __builtin__.property(_get_ipAddressType, _set_ipAddressType)
  ipAddress = __builtin__.property(_get_ipAddress, _set_ipAddress)
  ttl = __builtin__.property(_get_ttl, _set_ttl)


  _pyangbind_elements = OrderedDict([('dnsRuleId', dnsRuleId), ('domainName', domainName), ('ipAddressType', ipAddressType), ('ipAddress', ipAddress), ('ttl', ttl), ])


class yc_DNSRuleDescriptor_mec_app_descriptor__app_descriptor_DNSRuleDescriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/DNSRuleDescriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the DNS Rule Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dns_rule_descriptor',)

  _yang_name = 'DNSRuleDescriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dns_rule_descriptor = YANGDynClass(base=yc_dns_rule_descriptor_mec_app_descriptor__app_descriptor_DNSRuleDescriptor_dns_rule_descriptor, is_container='container', yang_name="dns-rule-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'DNSRuleDescriptor']

  def _get_dns_rule_descriptor(self):
    """
    Getter method for dns_rule_descriptor, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor (container)

    YANG Description: Container for DNS rule descriptor attributes.
    """
    return self.__dns_rule_descriptor
      
  def _set_dns_rule_descriptor(self, v, load=False):
    """
    Setter method for dns_rule_descriptor, mapped from YANG variable /app_descriptor/DNSRuleDescriptor/dns_rule_descriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_rule_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_rule_descriptor() directly.

    YANG Description: Container for DNS rule descriptor attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dns_rule_descriptor_mec_app_descriptor__app_descriptor_DNSRuleDescriptor_dns_rule_descriptor, is_container='container', yang_name="dns-rule-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_rule_descriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dns_rule_descriptor_mec_app_descriptor__app_descriptor_DNSRuleDescriptor_dns_rule_descriptor, is_container='container', yang_name="dns-rule-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__dns_rule_descriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_rule_descriptor(self):
    self.__dns_rule_descriptor = YANGDynClass(base=yc_dns_rule_descriptor_mec_app_descriptor__app_descriptor_DNSRuleDescriptor_dns_rule_descriptor, is_container='container', yang_name="dns-rule-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  dns_rule_descriptor = __builtin__.property(_get_dns_rule_descriptor, _set_dns_rule_descriptor)


  _pyangbind_elements = OrderedDict([('dns_rule_descriptor', dns_rule_descriptor), ])


class yc_latency_descriptor_mec_app_descriptor__app_descriptor_LatencyDescriptor_latency_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/LatencyDescriptor/latency-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for latency descriptor attributes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__maxLatency',)

  _yang_name = 'latency-descriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__maxLatency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxLatency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'LatencyDescriptor', 'latency-descriptor']

  def _get_maxLatency(self):
    """
    Getter method for maxLatency, mapped from YANG variable /app_descriptor/LatencyDescriptor/latency_descriptor/maxLatency (uint32)

    YANG Description: The value of the maximum latency in nano seconds tolerated by the MEC application.
    """
    return self.__maxLatency
      
  def _set_maxLatency(self, v, load=False):
    """
    Setter method for maxLatency, mapped from YANG variable /app_descriptor/LatencyDescriptor/latency_descriptor/maxLatency (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxLatency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxLatency() directly.

    YANG Description: The value of the maximum latency in nano seconds tolerated by the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxLatency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxLatency must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxLatency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__maxLatency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxLatency(self):
    self.__maxLatency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxLatency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

  maxLatency = __builtin__.property(_get_maxLatency, _set_maxLatency)


  _pyangbind_elements = OrderedDict([('maxLatency', maxLatency), ])


class yc_LatencyDescriptor_mec_app_descriptor__app_descriptor_LatencyDescriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/LatencyDescriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Latency Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__latency_descriptor',)

  _yang_name = 'LatencyDescriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__latency_descriptor = YANGDynClass(base=yc_latency_descriptor_mec_app_descriptor__app_descriptor_LatencyDescriptor_latency_descriptor, is_container='container', yang_name="latency-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'LatencyDescriptor']

  def _get_latency_descriptor(self):
    """
    Getter method for latency_descriptor, mapped from YANG variable /app_descriptor/LatencyDescriptor/latency_descriptor (container)

    YANG Description: Container for latency descriptor attributes.
    """
    return self.__latency_descriptor
      
  def _set_latency_descriptor(self, v, load=False):
    """
    Setter method for latency_descriptor, mapped from YANG variable /app_descriptor/LatencyDescriptor/latency_descriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latency_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latency_descriptor() directly.

    YANG Description: Container for latency descriptor attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_latency_descriptor_mec_app_descriptor__app_descriptor_LatencyDescriptor_latency_descriptor, is_container='container', yang_name="latency-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """latency_descriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_latency_descriptor_mec_app_descriptor__app_descriptor_LatencyDescriptor_latency_descriptor, is_container='container', yang_name="latency-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__latency_descriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_latency_descriptor(self):
    self.__latency_descriptor = YANGDynClass(base=yc_latency_descriptor_mec_app_descriptor__app_descriptor_LatencyDescriptor_latency_descriptor, is_container='container', yang_name="latency-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  latency_descriptor = __builtin__.property(_get_latency_descriptor, _set_latency_descriptor)


  _pyangbind_elements = OrderedDict([('latency_descriptor', latency_descriptor), ])


class yc_parameter_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig_terminate_app_instance_op_config_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TerminateAppInstanceOpConfig/terminate-app-instance-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'parameter'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TerminateAppInstanceOpConfig', 'terminate-app-instance-op-config', 'parameter']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config/parameter/key (string)

    YANG Description: Key of the VNF-specific parameter.
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key of the VNF-specific parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config/parameter/value (string)

    YANG Description: Value of the VNF-specific parameter.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value of the VNF-specific parameter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_terminate_app_instance_op_config_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig_terminate_app_instance_op_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TerminateAppInstanceOpConfig/terminate-app-instance-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the terminate application instance operation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__minGracefulStopTimeout','__maxRecommendedGracefulStopTimeout','__parameter',)

  _yang_name = 'terminate-app-instance-op-config'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__minGracefulStopTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    self.__maxRecommendedGracefulStopTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxRecommendedGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("key",yc_parameter_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig_terminate_app_instance_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TerminateAppInstanceOpConfig', 'terminate-app-instance-op-config']

  def _get_minGracefulStopTimeout(self):
    """
    Getter method for minGracefulStopTimeout, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config/minGracefulStopTimeout (uint32)

    YANG Description: Minimum timeout value for graceful stop of a VNF instance.
    """
    return self.__minGracefulStopTimeout
      
  def _set_minGracefulStopTimeout(self, v, load=False):
    """
    Setter method for minGracefulStopTimeout, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config/minGracefulStopTimeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minGracefulStopTimeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minGracefulStopTimeout() directly.

    YANG Description: Minimum timeout value for graceful stop of a VNF instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minGracefulStopTimeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__minGracefulStopTimeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minGracefulStopTimeout(self):
    self.__minGracefulStopTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)


  def _get_maxRecommendedGracefulStopTimeout(self):
    """
    Getter method for maxRecommendedGracefulStopTimeout, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config/maxRecommendedGracefulStopTimeout (uint32)

    YANG Description: Maximum recommended timeout value that can be needed to gracefully stop a VNF instance of a particular type under certain conditions, such as maximum load condition.
    """
    return self.__maxRecommendedGracefulStopTimeout
      
  def _set_maxRecommendedGracefulStopTimeout(self, v, load=False):
    """
    Setter method for maxRecommendedGracefulStopTimeout, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config/maxRecommendedGracefulStopTimeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxRecommendedGracefulStopTimeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxRecommendedGracefulStopTimeout() directly.

    YANG Description: Maximum recommended timeout value that can be needed to gracefully stop a VNF instance of a particular type under certain conditions, such as maximum load condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxRecommendedGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxRecommendedGracefulStopTimeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxRecommendedGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__maxRecommendedGracefulStopTimeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxRecommendedGracefulStopTimeout(self):
    self.__maxRecommendedGracefulStopTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxRecommendedGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_parameter_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig_terminate_app_instance_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig_terminate_app_instance_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("key",yc_parameter_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig_terminate_app_instance_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  minGracefulStopTimeout = __builtin__.property(_get_minGracefulStopTimeout, _set_minGracefulStopTimeout)
  maxRecommendedGracefulStopTimeout = __builtin__.property(_get_maxRecommendedGracefulStopTimeout, _set_maxRecommendedGracefulStopTimeout)
  parameter = __builtin__.property(_get_parameter, _set_parameter)


  _pyangbind_elements = OrderedDict([('minGracefulStopTimeout', minGracefulStopTimeout), ('maxRecommendedGracefulStopTimeout', maxRecommendedGracefulStopTimeout), ('parameter', parameter), ])


class yc_TerminateAppInstanceOpConfig_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/TerminateAppInstanceOpConfig. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Terminate Application Instance Operation Configuration into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__terminate_app_instance_op_config',)

  _yang_name = 'TerminateAppInstanceOpConfig'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__terminate_app_instance_op_config = YANGDynClass(base=yc_terminate_app_instance_op_config_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig_terminate_app_instance_op_config, is_container='container', yang_name="terminate-app-instance-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'TerminateAppInstanceOpConfig']

  def _get_terminate_app_instance_op_config(self):
    """
    Getter method for terminate_app_instance_op_config, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config (container)

    YANG Description: Configuration parameters for the terminate application instance operation.
    """
    return self.__terminate_app_instance_op_config
      
  def _set_terminate_app_instance_op_config(self, v, load=False):
    """
    Setter method for terminate_app_instance_op_config, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig/terminate_app_instance_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_app_instance_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_app_instance_op_config() directly.

    YANG Description: Configuration parameters for the terminate application instance operation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_terminate_app_instance_op_config_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig_terminate_app_instance_op_config, is_container='container', yang_name="terminate-app-instance-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminate_app_instance_op_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_terminate_app_instance_op_config_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig_terminate_app_instance_op_config, is_container='container', yang_name="terminate-app-instance-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__terminate_app_instance_op_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminate_app_instance_op_config(self):
    self.__terminate_app_instance_op_config = YANGDynClass(base=yc_terminate_app_instance_op_config_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig_terminate_app_instance_op_config, is_container='container', yang_name="terminate-app-instance-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  terminate_app_instance_op_config = __builtin__.property(_get_terminate_app_instance_op_config, _set_terminate_app_instance_op_config)


  _pyangbind_elements = OrderedDict([('terminate_app_instance_op_config', terminate_app_instance_op_config), ])


class yc_parameter_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig_change_app_instance_state_op_config_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ChangeAppInstanceStateOpConfig/change-app-instance-state-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__key','__value',)

  _yang_name = 'parameter'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ChangeAppInstanceStateOpConfig', 'change-app-instance-state-op-config', 'parameter']

  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config/parameter/key (string)

    YANG Description: Key of the VNF-specific parameter.
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key of the VNF-specific parameter.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config/parameter/value (string)

    YANG Description: Value of the VNF-specific parameter.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value of the VNF-specific parameter.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  key = __builtin__.property(_get_key, _set_key)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_change_app_instance_state_op_config_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig_change_app_instance_state_op_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ChangeAppInstanceStateOpConfig/change-app-instance-state-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the change application instance state operation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__minGracefulStopTimeout','__maxRecommendedGracefulStopTimeout','__parameter',)

  _yang_name = 'change-app-instance-state-op-config'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__minGracefulStopTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    self.__maxRecommendedGracefulStopTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxRecommendedGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    self.__parameter = YANGDynClass(base=YANGListType("key",yc_parameter_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig_change_app_instance_state_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ChangeAppInstanceStateOpConfig', 'change-app-instance-state-op-config']

  def _get_minGracefulStopTimeout(self):
    """
    Getter method for minGracefulStopTimeout, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config/minGracefulStopTimeout (uint32)

    YANG Description: Minimum timeout value for graceful stop of a VNF instance.
    """
    return self.__minGracefulStopTimeout
      
  def _set_minGracefulStopTimeout(self, v, load=False):
    """
    Setter method for minGracefulStopTimeout, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config/minGracefulStopTimeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_minGracefulStopTimeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_minGracefulStopTimeout() directly.

    YANG Description: Minimum timeout value for graceful stop of a VNF instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """minGracefulStopTimeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__minGracefulStopTimeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_minGracefulStopTimeout(self):
    self.__minGracefulStopTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="minGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)


  def _get_maxRecommendedGracefulStopTimeout(self):
    """
    Getter method for maxRecommendedGracefulStopTimeout, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config/maxRecommendedGracefulStopTimeout (uint32)

    YANG Description: Maximum recommended timeout value that can be needed to gracefully stop a VNF instance of a particular type under certain conditions, such as maximum load condition.
    """
    return self.__maxRecommendedGracefulStopTimeout
      
  def _set_maxRecommendedGracefulStopTimeout(self, v, load=False):
    """
    Setter method for maxRecommendedGracefulStopTimeout, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config/maxRecommendedGracefulStopTimeout (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxRecommendedGracefulStopTimeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxRecommendedGracefulStopTimeout() directly.

    YANG Description: Maximum recommended timeout value that can be needed to gracefully stop a VNF instance of a particular type under certain conditions, such as maximum load condition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxRecommendedGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxRecommendedGracefulStopTimeout must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxRecommendedGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__maxRecommendedGracefulStopTimeout = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxRecommendedGracefulStopTimeout(self):
    self.__maxRecommendedGracefulStopTimeout = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="maxRecommendedGracefulStopTimeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters to be passed when invoking the OperateVnf operation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("key",yc_parameter_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig_change_app_instance_state_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig_change_app_instance_state_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=YANGListType("key",yc_parameter_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig_change_app_instance_state_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  minGracefulStopTimeout = __builtin__.property(_get_minGracefulStopTimeout, _set_minGracefulStopTimeout)
  maxRecommendedGracefulStopTimeout = __builtin__.property(_get_maxRecommendedGracefulStopTimeout, _set_maxRecommendedGracefulStopTimeout)
  parameter = __builtin__.property(_get_parameter, _set_parameter)


  _pyangbind_elements = OrderedDict([('minGracefulStopTimeout', minGracefulStopTimeout), ('maxRecommendedGracefulStopTimeout', maxRecommendedGracefulStopTimeout), ('parameter', parameter), ])


class yc_ChangeAppInstanceStateOpConfig_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/ChangeAppInstanceStateOpConfig. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Change Application Instance State Operation Configuration into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__change_app_instance_state_op_config',)

  _yang_name = 'ChangeAppInstanceStateOpConfig'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__change_app_instance_state_op_config = YANGDynClass(base=yc_change_app_instance_state_op_config_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig_change_app_instance_state_op_config, is_container='container', yang_name="change-app-instance-state-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'ChangeAppInstanceStateOpConfig']

  def _get_change_app_instance_state_op_config(self):
    """
    Getter method for change_app_instance_state_op_config, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config (container)

    YANG Description: Configuration parameters for the change application instance state operation.
    """
    return self.__change_app_instance_state_op_config
      
  def _set_change_app_instance_state_op_config(self, v, load=False):
    """
    Setter method for change_app_instance_state_op_config, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig/change_app_instance_state_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_change_app_instance_state_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_change_app_instance_state_op_config() directly.

    YANG Description: Configuration parameters for the change application instance state operation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_change_app_instance_state_op_config_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig_change_app_instance_state_op_config, is_container='container', yang_name="change-app-instance-state-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """change_app_instance_state_op_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_change_app_instance_state_op_config_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig_change_app_instance_state_op_config, is_container='container', yang_name="change-app-instance-state-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__change_app_instance_state_op_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_change_app_instance_state_op_config(self):
    self.__change_app_instance_state_op_config = YANGDynClass(base=yc_change_app_instance_state_op_config_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig_change_app_instance_state_op_config, is_container='container', yang_name="change-app-instance-state-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  change_app_instance_state_op_config = __builtin__.property(_get_change_app_instance_state_op_config, _set_change_app_instance_state_op_config)


  _pyangbind_elements = OrderedDict([('change_app_instance_state_op_config', change_app_instance_state_op_config), ])


class yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_UserContextTransferCapability_user_context_transfer_capability(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/UserContextTransferCapability/user-context-transfer-capability. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for attributes related to the user context transfer capability of an application.
  """
  __slots__ = ('_path_helper', '_extmethods', '__statefulApplication','__userContextTransferSupport',)

  _yang_name = 'user-context-transfer-capability'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__statefulApplication = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statefulApplication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__userContextTransferSupport = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="userContextTransferSupport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'UserContextTransferCapability', 'user-context-transfer-capability']

  def _get_statefulApplication(self):
    """
    Getter method for statefulApplication, mapped from YANG variable /app_descriptor/UserContextTransferCapability/user_context_transfer_capability/statefulApplication (boolean)

    YANG Description: If the application is stateful, this attribute shall be set to true. Otherwise, this attribute shall be set to false.
    """
    return self.__statefulApplication
      
  def _set_statefulApplication(self, v, load=False):
    """
    Setter method for statefulApplication, mapped from YANG variable /app_descriptor/UserContextTransferCapability/user_context_transfer_capability/statefulApplication (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statefulApplication is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statefulApplication() directly.

    YANG Description: If the application is stateful, this attribute shall be set to true. Otherwise, this attribute shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="statefulApplication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statefulApplication must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statefulApplication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__statefulApplication = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statefulApplication(self):
    self.__statefulApplication = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statefulApplication", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_userContextTransferSupport(self):
    """
    Getter method for userContextTransferSupport, mapped from YANG variable /app_descriptor/UserContextTransferCapability/user_context_transfer_capability/userContextTransferSupport (boolean)

    YANG Description: This attribute shall be present if the application is stateful and supports the user context transfer. Otherwise, this attribute shall be set to false or be absent.
    """
    return self.__userContextTransferSupport
      
  def _set_userContextTransferSupport(self, v, load=False):
    """
    Setter method for userContextTransferSupport, mapped from YANG variable /app_descriptor/UserContextTransferCapability/user_context_transfer_capability/userContextTransferSupport (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_userContextTransferSupport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_userContextTransferSupport() directly.

    YANG Description: This attribute shall be present if the application is stateful and supports the user context transfer. Otherwise, this attribute shall be set to false or be absent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="userContextTransferSupport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """userContextTransferSupport must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="userContextTransferSupport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__userContextTransferSupport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_userContextTransferSupport(self):
    self.__userContextTransferSupport = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="userContextTransferSupport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

  statefulApplication = __builtin__.property(_get_statefulApplication, _set_statefulApplication)
  userContextTransferSupport = __builtin__.property(_get_userContextTransferSupport, _set_userContextTransferSupport)


  _pyangbind_elements = OrderedDict([('statefulApplication', statefulApplication), ('userContextTransferSupport', userContextTransferSupport), ])


class yc_UserContextTransferCapability_mec_app_descriptor__app_descriptor_UserContextTransferCapability(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/UserContextTransferCapability. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the user context transfer capability attributes into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__user_context_transfer_capability',)

  _yang_name = 'UserContextTransferCapability'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__user_context_transfer_capability = YANGDynClass(base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_UserContextTransferCapability_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'UserContextTransferCapability']

  def _get_user_context_transfer_capability(self):
    """
    Getter method for user_context_transfer_capability, mapped from YANG variable /app_descriptor/UserContextTransferCapability/user_context_transfer_capability (container)

    YANG Description: Container for attributes related to the user context transfer capability of an application.
    """
    return self.__user_context_transfer_capability
      
  def _set_user_context_transfer_capability(self, v, load=False):
    """
    Setter method for user_context_transfer_capability, mapped from YANG variable /app_descriptor/UserContextTransferCapability/user_context_transfer_capability (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_context_transfer_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_context_transfer_capability() directly.

    YANG Description: Container for attributes related to the user context transfer capability of an application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_UserContextTransferCapability_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_context_transfer_capability must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_UserContextTransferCapability_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__user_context_transfer_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_context_transfer_capability(self):
    self.__user_context_transfer_capability = YANGDynClass(base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_UserContextTransferCapability_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  user_context_transfer_capability = __builtin__.property(_get_user_context_transfer_capability, _set_user_context_transfer_capability)


  _pyangbind_elements = OrderedDict([('user_context_transfer_capability', user_context_transfer_capability), ])


class yc_app_network_policy_mec_app_descriptor__app_descriptor_appNetworkPolicy_app_network_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/appNetworkPolicy/app-network-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This attribute provides an option for the application to specify a type of network to carry the application traffic.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cellularNetwork','__wi_fiNetwork','__fixedAccessNetwork',)

  _yang_name = 'app-network-policy'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cellularNetwork = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellularNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__wi_fiNetwork = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wi-fiNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__fixedAccessNetwork = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixedAccessNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'appNetworkPolicy', 'app-network-policy']

  def _get_cellularNetwork(self):
    """
    Getter method for cellularNetwork, mapped from YANG variable /app_descriptor/appNetworkPolicy/app_network_policy/cellularNetwork (boolean)

    YANG Description: If present, and the application prefers to a cellular network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    return self.__cellularNetwork
      
  def _set_cellularNetwork(self, v, load=False):
    """
    Setter method for cellularNetwork, mapped from YANG variable /app_descriptor/appNetworkPolicy/app_network_policy/cellularNetwork (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cellularNetwork is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cellularNetwork() directly.

    YANG Description: If present, and the application prefers to a cellular network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellularNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cellularNetwork must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellularNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__cellularNetwork = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cellularNetwork(self):
    self.__cellularNetwork = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellularNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_wi_fiNetwork(self):
    """
    Getter method for wi_fiNetwork, mapped from YANG variable /app_descriptor/appNetworkPolicy/app_network_policy/wi_fiNetwork (boolean)

    YANG Description: If present, and the application prefers to a Wi-Fi network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    return self.__wi_fiNetwork
      
  def _set_wi_fiNetwork(self, v, load=False):
    """
    Setter method for wi_fiNetwork, mapped from YANG variable /app_descriptor/appNetworkPolicy/app_network_policy/wi_fiNetwork (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wi_fiNetwork is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wi_fiNetwork() directly.

    YANG Description: If present, and the application prefers to a Wi-Fi network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wi-fiNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wi_fiNetwork must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wi-fiNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__wi_fiNetwork = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wi_fiNetwork(self):
    self.__wi_fiNetwork = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wi-fiNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_fixedAccessNetwork(self):
    """
    Getter method for fixedAccessNetwork, mapped from YANG variable /app_descriptor/appNetworkPolicy/app_network_policy/fixedAccessNetwork (boolean)

    YANG Description: If present, and the application prefers to a fixed access network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    return self.__fixedAccessNetwork
      
  def _set_fixedAccessNetwork(self, v, load=False):
    """
    Setter method for fixedAccessNetwork, mapped from YANG variable /app_descriptor/appNetworkPolicy/app_network_policy/fixedAccessNetwork (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fixedAccessNetwork is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fixedAccessNetwork() directly.

    YANG Description: If present, and the application prefers to a fixed access network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixedAccessNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fixedAccessNetwork must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixedAccessNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__fixedAccessNetwork = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fixedAccessNetwork(self):
    self.__fixedAccessNetwork = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixedAccessNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

  cellularNetwork = __builtin__.property(_get_cellularNetwork, _set_cellularNetwork)
  wi_fiNetwork = __builtin__.property(_get_wi_fiNetwork, _set_wi_fiNetwork)
  fixedAccessNetwork = __builtin__.property(_get_fixedAccessNetwork, _set_fixedAccessNetwork)


  _pyangbind_elements = OrderedDict([('cellularNetwork', cellularNetwork), ('wi_fiNetwork', wi_fiNetwork), ('fixedAccessNetwork', fixedAccessNetwork), ])


class yc_appNetworkPolicy_mec_app_descriptor__app_descriptor_appNetworkPolicy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/appNetworkPolicy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for application network policy.
  """
  __slots__ = ('_path_helper', '_extmethods', '__app_network_policy',)

  _yang_name = 'appNetworkPolicy'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__app_network_policy = YANGDynClass(base=yc_app_network_policy_mec_app_descriptor__app_descriptor_appNetworkPolicy_app_network_policy, is_container='container', yang_name="app-network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'appNetworkPolicy']

  def _get_app_network_policy(self):
    """
    Getter method for app_network_policy, mapped from YANG variable /app_descriptor/appNetworkPolicy/app_network_policy (container)

    YANG Description: This attribute provides an option for the application to specify a type of network to carry the application traffic.
    """
    return self.__app_network_policy
      
  def _set_app_network_policy(self, v, load=False):
    """
    Setter method for app_network_policy, mapped from YANG variable /app_descriptor/appNetworkPolicy/app_network_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_app_network_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_app_network_policy() directly.

    YANG Description: This attribute provides an option for the application to specify a type of network to carry the application traffic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_app_network_policy_mec_app_descriptor__app_descriptor_appNetworkPolicy_app_network_policy, is_container='container', yang_name="app-network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """app_network_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_app_network_policy_mec_app_descriptor__app_descriptor_appNetworkPolicy_app_network_policy, is_container='container', yang_name="app-network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__app_network_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_app_network_policy(self):
    self.__app_network_policy = YANGDynClass(base=yc_app_network_policy_mec_app_descriptor__app_descriptor_appNetworkPolicy_app_network_policy, is_container='container', yang_name="app-network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  app_network_policy = __builtin__.property(_get_app_network_policy, _set_app_network_policy)


  _pyangbind_elements = OrderedDict([('app_network_policy', app_network_policy), ])


class yc_appServiceRequired_mec_app_descriptor__app_descriptor_appServiceRequired(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/appServiceRequired. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__serviceId',)

  _yang_name = 'appServiceRequired'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__serviceId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serviceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'appServiceRequired']

  def _get_serviceId(self):
    """
    Getter method for serviceId, mapped from YANG variable /app_descriptor/appServiceRequired/serviceId (string)

    YANG Description: Identifier for the required service.
    """
    return self.__serviceId
      
  def _set_serviceId(self, v, load=False):
    """
    Setter method for serviceId, mapped from YANG variable /app_descriptor/appServiceRequired/serviceId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serviceId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serviceId() directly.

    YANG Description: Identifier for the required service.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="serviceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serviceId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serviceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__serviceId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serviceId(self):
    self.__serviceId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serviceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  serviceId = __builtin__.property(_get_serviceId, _set_serviceId)


  _pyangbind_elements = OrderedDict([('serviceId', serviceId), ])


class yc_app_descriptor_mec_app_descriptor__app_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__appDId','__appName','__appProvider','__appSoftVersion','__appDVersion','__mecVersion','__appInfoName','__appDescription','__VirtualComputeDesc','__SwImageDescriptor','__VirtualStorageDesc','__appExtCpd','__ServiceDependency','__ServiceDescriptor','__FeatureDependency','__TransportDependency','__TrafficRuleDescriptor','__DNSRuleDescriptor','__LatencyDescriptor','__TerminateAppInstanceOpConfig','__ChangeAppInstanceStateOpConfig','__UserContextTransferCapability','__appNetworkPolicy','__appServiceRequired',)

  _yang_name = 'app-descriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__appDId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appDId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__appName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__appProvider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appProvider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__appSoftVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appSoftVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__appDVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appDVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__mecVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mecVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__appInfoName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appInfoName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__appDescription = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appDescription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__VirtualComputeDesc = YANGDynClass(base=yc_VirtualComputeDesc_mec_app_descriptor__app_descriptor_VirtualComputeDesc, is_container='container', yang_name="VirtualComputeDesc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__SwImageDescriptor = YANGDynClass(base=yc_SwImageDescriptor_mec_app_descriptor__app_descriptor_SwImageDescriptor, is_container='container', yang_name="SwImageDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__VirtualStorageDesc = YANGDynClass(base=yc_VirtualStorageDesc_mec_app_descriptor__app_descriptor_VirtualStorageDesc, is_container='container', yang_name="VirtualStorageDesc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__appExtCpd = YANGDynClass(base=YANGListType("id",yc_appExtCpd_mec_app_descriptor__app_descriptor_appExtCpd, yang_name="appExtCpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="appExtCpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__ServiceDependency = YANGDynClass(base=YANGListType("serName",yc_ServiceDependency_mec_app_descriptor__app_descriptor_ServiceDependency, yang_name="ServiceDependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serName', extensions=None), is_container='list', yang_name="ServiceDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__ServiceDescriptor = YANGDynClass(base=yc_ServiceDescriptor_mec_app_descriptor__app_descriptor_ServiceDescriptor, is_container='container', yang_name="ServiceDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__FeatureDependency = YANGDynClass(base=yc_FeatureDependency_mec_app_descriptor__app_descriptor_FeatureDependency, is_container='container', yang_name="FeatureDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__TransportDependency = YANGDynClass(base=yc_TransportDependency_mec_app_descriptor__app_descriptor_TransportDependency, is_container='container', yang_name="TransportDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__TrafficRuleDescriptor = YANGDynClass(base=yc_TrafficRuleDescriptor_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor, is_container='container', yang_name="TrafficRuleDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__DNSRuleDescriptor = YANGDynClass(base=yc_DNSRuleDescriptor_mec_app_descriptor__app_descriptor_DNSRuleDescriptor, is_container='container', yang_name="DNSRuleDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__LatencyDescriptor = YANGDynClass(base=yc_LatencyDescriptor_mec_app_descriptor__app_descriptor_LatencyDescriptor, is_container='container', yang_name="LatencyDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__TerminateAppInstanceOpConfig = YANGDynClass(base=yc_TerminateAppInstanceOpConfig_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig, is_container='container', yang_name="TerminateAppInstanceOpConfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__ChangeAppInstanceStateOpConfig = YANGDynClass(base=yc_ChangeAppInstanceStateOpConfig_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig, is_container='container', yang_name="ChangeAppInstanceStateOpConfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__UserContextTransferCapability = YANGDynClass(base=yc_UserContextTransferCapability_mec_app_descriptor__app_descriptor_UserContextTransferCapability, is_container='container', yang_name="UserContextTransferCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__appNetworkPolicy = YANGDynClass(base=yc_appNetworkPolicy_mec_app_descriptor__app_descriptor_appNetworkPolicy, is_container='container', yang_name="appNetworkPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__appServiceRequired = YANGDynClass(base=YANGListType("serviceId",yc_appServiceRequired_mec_app_descriptor__app_descriptor_appServiceRequired, yang_name="appServiceRequired", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serviceId', extensions=None), is_container='list', yang_name="appServiceRequired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor']

  def _get_appDId(self):
    """
    Getter method for appDId, mapped from YANG variable /app_descriptor/appDId (string)

    YANG Description: Identifier of this MEC application descriptor. This attribute shall be globally unique.
    """
    return self.__appDId
      
  def _set_appDId(self, v, load=False):
    """
    Setter method for appDId, mapped from YANG variable /app_descriptor/appDId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appDId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appDId() directly.

    YANG Description: Identifier of this MEC application descriptor. This attribute shall be globally unique.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="appDId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appDId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appDId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__appDId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appDId(self):
    self.__appDId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appDId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_appName(self):
    """
    Getter method for appName, mapped from YANG variable /app_descriptor/appName (string)

    YANG Description: Name to identify the MEC application.
    """
    return self.__appName
      
  def _set_appName(self, v, load=False):
    """
    Setter method for appName, mapped from YANG variable /app_descriptor/appName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appName() directly.

    YANG Description: Name to identify the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="appName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__appName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appName(self):
    self.__appName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_appProvider(self):
    """
    Getter method for appProvider, mapped from YANG variable /app_descriptor/appProvider (string)

    YANG Description: Provider of the application and of the AppD.
    """
    return self.__appProvider
      
  def _set_appProvider(self, v, load=False):
    """
    Setter method for appProvider, mapped from YANG variable /app_descriptor/appProvider (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appProvider is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appProvider() directly.

    YANG Description: Provider of the application and of the AppD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="appProvider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appProvider must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appProvider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__appProvider = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appProvider(self):
    self.__appProvider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appProvider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_appSoftVersion(self):
    """
    Getter method for appSoftVersion, mapped from YANG variable /app_descriptor/appSoftVersion (string)

    YANG Description: Identifies the version of software of the MEC application.
    """
    return self.__appSoftVersion
      
  def _set_appSoftVersion(self, v, load=False):
    """
    Setter method for appSoftVersion, mapped from YANG variable /app_descriptor/appSoftVersion (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appSoftVersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appSoftVersion() directly.

    YANG Description: Identifies the version of software of the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="appSoftVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appSoftVersion must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appSoftVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__appSoftVersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appSoftVersion(self):
    self.__appSoftVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appSoftVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_appDVersion(self):
    """
    Getter method for appDVersion, mapped from YANG variable /app_descriptor/appDVersion (string)

    YANG Description: Identifies the version of the application descriptor.
    """
    return self.__appDVersion
      
  def _set_appDVersion(self, v, load=False):
    """
    Setter method for appDVersion, mapped from YANG variable /app_descriptor/appDVersion (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appDVersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appDVersion() directly.

    YANG Description: Identifies the version of the application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="appDVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appDVersion must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appDVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__appDVersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appDVersion(self):
    self.__appDVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appDVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_mecVersion(self):
    """
    Getter method for mecVersion, mapped from YANG variable /app_descriptor/mecVersion (string)

    YANG Description: Identifies version(s) of MEC system compatible with the MEC application described in this version of the AppD. The value shall be formatted as comma-separated list of strings.
    """
    return self.__mecVersion
      
  def _set_mecVersion(self, v, load=False):
    """
    Setter method for mecVersion, mapped from YANG variable /app_descriptor/mecVersion (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mecVersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mecVersion() directly.

    YANG Description: Identifies version(s) of MEC system compatible with the MEC application described in this version of the AppD. The value shall be formatted as comma-separated list of strings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mecVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mecVersion must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mecVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__mecVersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mecVersion(self):
    self.__mecVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mecVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_appInfoName(self):
    """
    Getter method for appInfoName, mapped from YANG variable /app_descriptor/appInfoName (string)

    YANG Description: Human readable name for the MEC application.
    """
    return self.__appInfoName
      
  def _set_appInfoName(self, v, load=False):
    """
    Setter method for appInfoName, mapped from YANG variable /app_descriptor/appInfoName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appInfoName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appInfoName() directly.

    YANG Description: Human readable name for the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="appInfoName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appInfoName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appInfoName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__appInfoName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appInfoName(self):
    self.__appInfoName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appInfoName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_appDescription(self):
    """
    Getter method for appDescription, mapped from YANG variable /app_descriptor/appDescription (string)

    YANG Description: Human readable description of the MEC application.
    """
    return self.__appDescription
      
  def _set_appDescription(self, v, load=False):
    """
    Setter method for appDescription, mapped from YANG variable /app_descriptor/appDescription (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appDescription is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appDescription() directly.

    YANG Description: Human readable description of the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="appDescription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appDescription must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appDescription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__appDescription = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appDescription(self):
    self.__appDescription = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="appDescription", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_VirtualComputeDesc(self):
    """
    Getter method for VirtualComputeDesc, mapped from YANG variable /app_descriptor/VirtualComputeDesc (container)

    YANG Description: Incorporates Virtual Compute Descriptor into the MEC application descriptor.
    """
    return self.__VirtualComputeDesc
      
  def _set_VirtualComputeDesc(self, v, load=False):
    """
    Setter method for VirtualComputeDesc, mapped from YANG variable /app_descriptor/VirtualComputeDesc (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_VirtualComputeDesc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_VirtualComputeDesc() directly.

    YANG Description: Incorporates Virtual Compute Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_VirtualComputeDesc_mec_app_descriptor__app_descriptor_VirtualComputeDesc, is_container='container', yang_name="VirtualComputeDesc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """VirtualComputeDesc must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_VirtualComputeDesc_mec_app_descriptor__app_descriptor_VirtualComputeDesc, is_container='container', yang_name="VirtualComputeDesc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__VirtualComputeDesc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_VirtualComputeDesc(self):
    self.__VirtualComputeDesc = YANGDynClass(base=yc_VirtualComputeDesc_mec_app_descriptor__app_descriptor_VirtualComputeDesc, is_container='container', yang_name="VirtualComputeDesc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_SwImageDescriptor(self):
    """
    Getter method for SwImageDescriptor, mapped from YANG variable /app_descriptor/SwImageDescriptor (container)

    YANG Description: Incorporates the Software Image Descriptor into the MEC application descriptor.
    """
    return self.__SwImageDescriptor
      
  def _set_SwImageDescriptor(self, v, load=False):
    """
    Setter method for SwImageDescriptor, mapped from YANG variable /app_descriptor/SwImageDescriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_SwImageDescriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_SwImageDescriptor() directly.

    YANG Description: Incorporates the Software Image Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_SwImageDescriptor_mec_app_descriptor__app_descriptor_SwImageDescriptor, is_container='container', yang_name="SwImageDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """SwImageDescriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_SwImageDescriptor_mec_app_descriptor__app_descriptor_SwImageDescriptor, is_container='container', yang_name="SwImageDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__SwImageDescriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_SwImageDescriptor(self):
    self.__SwImageDescriptor = YANGDynClass(base=yc_SwImageDescriptor_mec_app_descriptor__app_descriptor_SwImageDescriptor, is_container='container', yang_name="SwImageDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_VirtualStorageDesc(self):
    """
    Getter method for VirtualStorageDesc, mapped from YANG variable /app_descriptor/VirtualStorageDesc (container)

    YANG Description: Incorporates Virtual Storage Descriptor into the MEC application descriptor.
    """
    return self.__VirtualStorageDesc
      
  def _set_VirtualStorageDesc(self, v, load=False):
    """
    Setter method for VirtualStorageDesc, mapped from YANG variable /app_descriptor/VirtualStorageDesc (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_VirtualStorageDesc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_VirtualStorageDesc() directly.

    YANG Description: Incorporates Virtual Storage Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_VirtualStorageDesc_mec_app_descriptor__app_descriptor_VirtualStorageDesc, is_container='container', yang_name="VirtualStorageDesc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """VirtualStorageDesc must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_VirtualStorageDesc_mec_app_descriptor__app_descriptor_VirtualStorageDesc, is_container='container', yang_name="VirtualStorageDesc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__VirtualStorageDesc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_VirtualStorageDesc(self):
    self.__VirtualStorageDesc = YANGDynClass(base=yc_VirtualStorageDesc_mec_app_descriptor__app_descriptor_VirtualStorageDesc, is_container='container', yang_name="VirtualStorageDesc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_appExtCpd(self):
    """
    Getter method for appExtCpd, mapped from YANG variable /app_descriptor/appExtCpd (list)

    YANG Description: Describes an external connection point of a MEC application
    """
    return self.__appExtCpd
      
  def _set_appExtCpd(self, v, load=False):
    """
    Setter method for appExtCpd, mapped from YANG variable /app_descriptor/appExtCpd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appExtCpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appExtCpd() directly.

    YANG Description: Describes an external connection point of a MEC application
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_appExtCpd_mec_app_descriptor__app_descriptor_appExtCpd, yang_name="appExtCpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="appExtCpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appExtCpd must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_appExtCpd_mec_app_descriptor__app_descriptor_appExtCpd, yang_name="appExtCpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="appExtCpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__appExtCpd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appExtCpd(self):
    self.__appExtCpd = YANGDynClass(base=YANGListType("id",yc_appExtCpd_mec_app_descriptor__app_descriptor_appExtCpd, yang_name="appExtCpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="appExtCpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_ServiceDependency(self):
    """
    Getter method for ServiceDependency, mapped from YANG variable /app_descriptor/ServiceDependency (list)

    YANG Description: Describes service dependencies of the MEC app
    """
    return self.__ServiceDependency
      
  def _set_ServiceDependency(self, v, load=False):
    """
    Setter method for ServiceDependency, mapped from YANG variable /app_descriptor/ServiceDependency (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ServiceDependency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ServiceDependency() directly.

    YANG Description: Describes service dependencies of the MEC app
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("serName",yc_ServiceDependency_mec_app_descriptor__app_descriptor_ServiceDependency, yang_name="ServiceDependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serName', extensions=None), is_container='list', yang_name="ServiceDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ServiceDependency must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("serName",yc_ServiceDependency_mec_app_descriptor__app_descriptor_ServiceDependency, yang_name="ServiceDependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serName', extensions=None), is_container='list', yang_name="ServiceDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__ServiceDependency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ServiceDependency(self):
    self.__ServiceDependency = YANGDynClass(base=YANGListType("serName",yc_ServiceDependency_mec_app_descriptor__app_descriptor_ServiceDependency, yang_name="ServiceDependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serName', extensions=None), is_container='list', yang_name="ServiceDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_ServiceDescriptor(self):
    """
    Getter method for ServiceDescriptor, mapped from YANG variable /app_descriptor/ServiceDescriptor (container)

    YANG Description: Incorporates the Service Descriptor into the MEC application descriptor.
    """
    return self.__ServiceDescriptor
      
  def _set_ServiceDescriptor(self, v, load=False):
    """
    Setter method for ServiceDescriptor, mapped from YANG variable /app_descriptor/ServiceDescriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ServiceDescriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ServiceDescriptor() directly.

    YANG Description: Incorporates the Service Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ServiceDescriptor_mec_app_descriptor__app_descriptor_ServiceDescriptor, is_container='container', yang_name="ServiceDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ServiceDescriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ServiceDescriptor_mec_app_descriptor__app_descriptor_ServiceDescriptor, is_container='container', yang_name="ServiceDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__ServiceDescriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ServiceDescriptor(self):
    self.__ServiceDescriptor = YANGDynClass(base=yc_ServiceDescriptor_mec_app_descriptor__app_descriptor_ServiceDescriptor, is_container='container', yang_name="ServiceDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_FeatureDependency(self):
    """
    Getter method for FeatureDependency, mapped from YANG variable /app_descriptor/FeatureDependency (container)

    YANG Description: Incorporates the Feature Dependency into the MEC application descriptor.
    """
    return self.__FeatureDependency
      
  def _set_FeatureDependency(self, v, load=False):
    """
    Setter method for FeatureDependency, mapped from YANG variable /app_descriptor/FeatureDependency (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_FeatureDependency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_FeatureDependency() directly.

    YANG Description: Incorporates the Feature Dependency into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_FeatureDependency_mec_app_descriptor__app_descriptor_FeatureDependency, is_container='container', yang_name="FeatureDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """FeatureDependency must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_FeatureDependency_mec_app_descriptor__app_descriptor_FeatureDependency, is_container='container', yang_name="FeatureDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__FeatureDependency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_FeatureDependency(self):
    self.__FeatureDependency = YANGDynClass(base=yc_FeatureDependency_mec_app_descriptor__app_descriptor_FeatureDependency, is_container='container', yang_name="FeatureDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_TransportDependency(self):
    """
    Getter method for TransportDependency, mapped from YANG variable /app_descriptor/TransportDependency (container)

    YANG Description: Incorporates the Transport Dependency into the MEC application descriptor.
    """
    return self.__TransportDependency
      
  def _set_TransportDependency(self, v, load=False):
    """
    Setter method for TransportDependency, mapped from YANG variable /app_descriptor/TransportDependency (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_TransportDependency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_TransportDependency() directly.

    YANG Description: Incorporates the Transport Dependency into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_TransportDependency_mec_app_descriptor__app_descriptor_TransportDependency, is_container='container', yang_name="TransportDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """TransportDependency must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_TransportDependency_mec_app_descriptor__app_descriptor_TransportDependency, is_container='container', yang_name="TransportDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__TransportDependency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_TransportDependency(self):
    self.__TransportDependency = YANGDynClass(base=yc_TransportDependency_mec_app_descriptor__app_descriptor_TransportDependency, is_container='container', yang_name="TransportDependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_TrafficRuleDescriptor(self):
    """
    Getter method for TrafficRuleDescriptor, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor (container)

    YANG Description: Incorporates the Traffic Rule Descriptor into the MEC application descriptor.
    """
    return self.__TrafficRuleDescriptor
      
  def _set_TrafficRuleDescriptor(self, v, load=False):
    """
    Setter method for TrafficRuleDescriptor, mapped from YANG variable /app_descriptor/TrafficRuleDescriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_TrafficRuleDescriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_TrafficRuleDescriptor() directly.

    YANG Description: Incorporates the Traffic Rule Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_TrafficRuleDescriptor_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor, is_container='container', yang_name="TrafficRuleDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """TrafficRuleDescriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_TrafficRuleDescriptor_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor, is_container='container', yang_name="TrafficRuleDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__TrafficRuleDescriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_TrafficRuleDescriptor(self):
    self.__TrafficRuleDescriptor = YANGDynClass(base=yc_TrafficRuleDescriptor_mec_app_descriptor__app_descriptor_TrafficRuleDescriptor, is_container='container', yang_name="TrafficRuleDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_DNSRuleDescriptor(self):
    """
    Getter method for DNSRuleDescriptor, mapped from YANG variable /app_descriptor/DNSRuleDescriptor (container)

    YANG Description: Incorporates the DNS Rule Descriptor into the MEC application descriptor.
    """
    return self.__DNSRuleDescriptor
      
  def _set_DNSRuleDescriptor(self, v, load=False):
    """
    Setter method for DNSRuleDescriptor, mapped from YANG variable /app_descriptor/DNSRuleDescriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_DNSRuleDescriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_DNSRuleDescriptor() directly.

    YANG Description: Incorporates the DNS Rule Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_DNSRuleDescriptor_mec_app_descriptor__app_descriptor_DNSRuleDescriptor, is_container='container', yang_name="DNSRuleDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """DNSRuleDescriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_DNSRuleDescriptor_mec_app_descriptor__app_descriptor_DNSRuleDescriptor, is_container='container', yang_name="DNSRuleDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__DNSRuleDescriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_DNSRuleDescriptor(self):
    self.__DNSRuleDescriptor = YANGDynClass(base=yc_DNSRuleDescriptor_mec_app_descriptor__app_descriptor_DNSRuleDescriptor, is_container='container', yang_name="DNSRuleDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_LatencyDescriptor(self):
    """
    Getter method for LatencyDescriptor, mapped from YANG variable /app_descriptor/LatencyDescriptor (container)

    YANG Description: Incorporates the Latency Descriptor into the MEC application descriptor.
    """
    return self.__LatencyDescriptor
      
  def _set_LatencyDescriptor(self, v, load=False):
    """
    Setter method for LatencyDescriptor, mapped from YANG variable /app_descriptor/LatencyDescriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_LatencyDescriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_LatencyDescriptor() directly.

    YANG Description: Incorporates the Latency Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_LatencyDescriptor_mec_app_descriptor__app_descriptor_LatencyDescriptor, is_container='container', yang_name="LatencyDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """LatencyDescriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_LatencyDescriptor_mec_app_descriptor__app_descriptor_LatencyDescriptor, is_container='container', yang_name="LatencyDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__LatencyDescriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_LatencyDescriptor(self):
    self.__LatencyDescriptor = YANGDynClass(base=yc_LatencyDescriptor_mec_app_descriptor__app_descriptor_LatencyDescriptor, is_container='container', yang_name="LatencyDescriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_TerminateAppInstanceOpConfig(self):
    """
    Getter method for TerminateAppInstanceOpConfig, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig (container)

    YANG Description: Incorporates the Terminate Application Instance Operation Configuration into the MEC application descriptor.
    """
    return self.__TerminateAppInstanceOpConfig
      
  def _set_TerminateAppInstanceOpConfig(self, v, load=False):
    """
    Setter method for TerminateAppInstanceOpConfig, mapped from YANG variable /app_descriptor/TerminateAppInstanceOpConfig (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_TerminateAppInstanceOpConfig is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_TerminateAppInstanceOpConfig() directly.

    YANG Description: Incorporates the Terminate Application Instance Operation Configuration into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_TerminateAppInstanceOpConfig_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig, is_container='container', yang_name="TerminateAppInstanceOpConfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """TerminateAppInstanceOpConfig must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_TerminateAppInstanceOpConfig_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig, is_container='container', yang_name="TerminateAppInstanceOpConfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__TerminateAppInstanceOpConfig = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_TerminateAppInstanceOpConfig(self):
    self.__TerminateAppInstanceOpConfig = YANGDynClass(base=yc_TerminateAppInstanceOpConfig_mec_app_descriptor__app_descriptor_TerminateAppInstanceOpConfig, is_container='container', yang_name="TerminateAppInstanceOpConfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_ChangeAppInstanceStateOpConfig(self):
    """
    Getter method for ChangeAppInstanceStateOpConfig, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig (container)

    YANG Description: Incorporates the Change Application Instance State Operation Configuration into the MEC application descriptor.
    """
    return self.__ChangeAppInstanceStateOpConfig
      
  def _set_ChangeAppInstanceStateOpConfig(self, v, load=False):
    """
    Setter method for ChangeAppInstanceStateOpConfig, mapped from YANG variable /app_descriptor/ChangeAppInstanceStateOpConfig (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ChangeAppInstanceStateOpConfig is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ChangeAppInstanceStateOpConfig() directly.

    YANG Description: Incorporates the Change Application Instance State Operation Configuration into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ChangeAppInstanceStateOpConfig_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig, is_container='container', yang_name="ChangeAppInstanceStateOpConfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ChangeAppInstanceStateOpConfig must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ChangeAppInstanceStateOpConfig_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig, is_container='container', yang_name="ChangeAppInstanceStateOpConfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__ChangeAppInstanceStateOpConfig = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ChangeAppInstanceStateOpConfig(self):
    self.__ChangeAppInstanceStateOpConfig = YANGDynClass(base=yc_ChangeAppInstanceStateOpConfig_mec_app_descriptor__app_descriptor_ChangeAppInstanceStateOpConfig, is_container='container', yang_name="ChangeAppInstanceStateOpConfig", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_UserContextTransferCapability(self):
    """
    Getter method for UserContextTransferCapability, mapped from YANG variable /app_descriptor/UserContextTransferCapability (container)

    YANG Description: Incorporates the user context transfer capability attributes into the MEC application descriptor.
    """
    return self.__UserContextTransferCapability
      
  def _set_UserContextTransferCapability(self, v, load=False):
    """
    Setter method for UserContextTransferCapability, mapped from YANG variable /app_descriptor/UserContextTransferCapability (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_UserContextTransferCapability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_UserContextTransferCapability() directly.

    YANG Description: Incorporates the user context transfer capability attributes into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_UserContextTransferCapability_mec_app_descriptor__app_descriptor_UserContextTransferCapability, is_container='container', yang_name="UserContextTransferCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """UserContextTransferCapability must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_UserContextTransferCapability_mec_app_descriptor__app_descriptor_UserContextTransferCapability, is_container='container', yang_name="UserContextTransferCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__UserContextTransferCapability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_UserContextTransferCapability(self):
    self.__UserContextTransferCapability = YANGDynClass(base=yc_UserContextTransferCapability_mec_app_descriptor__app_descriptor_UserContextTransferCapability, is_container='container', yang_name="UserContextTransferCapability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_appNetworkPolicy(self):
    """
    Getter method for appNetworkPolicy, mapped from YANG variable /app_descriptor/appNetworkPolicy (container)

    YANG Description: Container for application network policy.
    """
    return self.__appNetworkPolicy
      
  def _set_appNetworkPolicy(self, v, load=False):
    """
    Setter method for appNetworkPolicy, mapped from YANG variable /app_descriptor/appNetworkPolicy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appNetworkPolicy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appNetworkPolicy() directly.

    YANG Description: Container for application network policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_appNetworkPolicy_mec_app_descriptor__app_descriptor_appNetworkPolicy, is_container='container', yang_name="appNetworkPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appNetworkPolicy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_appNetworkPolicy_mec_app_descriptor__app_descriptor_appNetworkPolicy, is_container='container', yang_name="appNetworkPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__appNetworkPolicy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appNetworkPolicy(self):
    self.__appNetworkPolicy = YANGDynClass(base=yc_appNetworkPolicy_mec_app_descriptor__app_descriptor_appNetworkPolicy, is_container='container', yang_name="appNetworkPolicy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_appServiceRequired(self):
    """
    Getter method for appServiceRequired, mapped from YANG variable /app_descriptor/appServiceRequired (list)
    """
    return self.__appServiceRequired
      
  def _set_appServiceRequired(self, v, load=False):
    """
    Setter method for appServiceRequired, mapped from YANG variable /app_descriptor/appServiceRequired (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_appServiceRequired is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_appServiceRequired() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("serviceId",yc_appServiceRequired_mec_app_descriptor__app_descriptor_appServiceRequired, yang_name="appServiceRequired", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serviceId', extensions=None), is_container='list', yang_name="appServiceRequired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """appServiceRequired must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("serviceId",yc_appServiceRequired_mec_app_descriptor__app_descriptor_appServiceRequired, yang_name="appServiceRequired", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serviceId', extensions=None), is_container='list', yang_name="appServiceRequired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__appServiceRequired = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_appServiceRequired(self):
    self.__appServiceRequired = YANGDynClass(base=YANGListType("serviceId",yc_appServiceRequired_mec_app_descriptor__app_descriptor_appServiceRequired, yang_name="appServiceRequired", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='serviceId', extensions=None), is_container='list', yang_name="appServiceRequired", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)

  appDId = __builtin__.property(_get_appDId, _set_appDId)
  appName = __builtin__.property(_get_appName, _set_appName)
  appProvider = __builtin__.property(_get_appProvider, _set_appProvider)
  appSoftVersion = __builtin__.property(_get_appSoftVersion, _set_appSoftVersion)
  appDVersion = __builtin__.property(_get_appDVersion, _set_appDVersion)
  mecVersion = __builtin__.property(_get_mecVersion, _set_mecVersion)
  appInfoName = __builtin__.property(_get_appInfoName, _set_appInfoName)
  appDescription = __builtin__.property(_get_appDescription, _set_appDescription)
  VirtualComputeDesc = __builtin__.property(_get_VirtualComputeDesc, _set_VirtualComputeDesc)
  SwImageDescriptor = __builtin__.property(_get_SwImageDescriptor, _set_SwImageDescriptor)
  VirtualStorageDesc = __builtin__.property(_get_VirtualStorageDesc, _set_VirtualStorageDesc)
  appExtCpd = __builtin__.property(_get_appExtCpd, _set_appExtCpd)
  ServiceDependency = __builtin__.property(_get_ServiceDependency, _set_ServiceDependency)
  ServiceDescriptor = __builtin__.property(_get_ServiceDescriptor, _set_ServiceDescriptor)
  FeatureDependency = __builtin__.property(_get_FeatureDependency, _set_FeatureDependency)
  TransportDependency = __builtin__.property(_get_TransportDependency, _set_TransportDependency)
  TrafficRuleDescriptor = __builtin__.property(_get_TrafficRuleDescriptor, _set_TrafficRuleDescriptor)
  DNSRuleDescriptor = __builtin__.property(_get_DNSRuleDescriptor, _set_DNSRuleDescriptor)
  LatencyDescriptor = __builtin__.property(_get_LatencyDescriptor, _set_LatencyDescriptor)
  TerminateAppInstanceOpConfig = __builtin__.property(_get_TerminateAppInstanceOpConfig, _set_TerminateAppInstanceOpConfig)
  ChangeAppInstanceStateOpConfig = __builtin__.property(_get_ChangeAppInstanceStateOpConfig, _set_ChangeAppInstanceStateOpConfig)
  UserContextTransferCapability = __builtin__.property(_get_UserContextTransferCapability, _set_UserContextTransferCapability)
  appNetworkPolicy = __builtin__.property(_get_appNetworkPolicy, _set_appNetworkPolicy)
  appServiceRequired = __builtin__.property(_get_appServiceRequired, _set_appServiceRequired)


  _pyangbind_elements = OrderedDict([('appDId', appDId), ('appName', appName), ('appProvider', appProvider), ('appSoftVersion', appSoftVersion), ('appDVersion', appDVersion), ('mecVersion', mecVersion), ('appInfoName', appInfoName), ('appDescription', appDescription), ('VirtualComputeDesc', VirtualComputeDesc), ('SwImageDescriptor', SwImageDescriptor), ('VirtualStorageDesc', VirtualStorageDesc), ('appExtCpd', appExtCpd), ('ServiceDependency', ServiceDependency), ('ServiceDescriptor', ServiceDescriptor), ('FeatureDependency', FeatureDependency), ('TransportDependency', TransportDependency), ('TrafficRuleDescriptor', TrafficRuleDescriptor), ('DNSRuleDescriptor', DNSRuleDescriptor), ('LatencyDescriptor', LatencyDescriptor), ('TerminateAppInstanceOpConfig', TerminateAppInstanceOpConfig), ('ChangeAppInstanceStateOpConfig', ChangeAppInstanceStateOpConfig), ('UserContextTransferCapability', UserContextTransferCapability), ('appNetworkPolicy', appNetworkPolicy), ('appServiceRequired', appServiceRequired), ])


class mec_app_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /mec-app-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: YANG module for MEC Application Descriptors based on ETSI GS MEC 010-2 V2.2.1.
  """
  __slots__ = ('_path_helper', '_extmethods', '__app_descriptor',)

  _yang_name = 'mec-app-descriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__app_descriptor = YANGDynClass(base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_app_descriptor(self):
    """
    Getter method for app_descriptor, mapped from YANG variable /app_descriptor (container)
    """
    return self.__app_descriptor
      
  def _set_app_descriptor(self, v, load=False):
    """
    Setter method for app_descriptor, mapped from YANG variable /app_descriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_app_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_app_descriptor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """app_descriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__app_descriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_app_descriptor(self):
    self.__app_descriptor = YANGDynClass(base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  app_descriptor = __builtin__.property(_get_app_descriptor, _set_app_descriptor)


  _pyangbind_elements = OrderedDict([('app_descriptor', app_descriptor), ])


