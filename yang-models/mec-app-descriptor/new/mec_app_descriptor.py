# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_network_policy_mec_app_descriptor__app_descriptor_network_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/network-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Application network policy.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cellular_network','__wifi_network','__fixed_access_network',)

  _yang_name = 'network-policy'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cellular_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellular-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__wifi_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wifi-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__fixed_access_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixed-access-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'network-policy']

  def _get_cellular_network(self):
    """
    Getter method for cellular_network, mapped from YANG variable /app_descriptor/network_policy/cellular_network (boolean)

    YANG Description: If present, and the application prefers to a cellular network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    return self.__cellular_network
      
  def _set_cellular_network(self, v, load=False):
    """
    Setter method for cellular_network, mapped from YANG variable /app_descriptor/network_policy/cellular_network (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cellular_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cellular_network() directly.

    YANG Description: If present, and the application prefers to a cellular network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellular-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cellular_network must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellular-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__cellular_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cellular_network(self):
    self.__cellular_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="cellular-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_wifi_network(self):
    """
    Getter method for wifi_network, mapped from YANG variable /app_descriptor/network_policy/wifi_network (boolean)

    YANG Description: If present, and the application prefers to a Wi-Fi network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    return self.__wifi_network
      
  def _set_wifi_network(self, v, load=False):
    """
    Setter method for wifi_network, mapped from YANG variable /app_descriptor/network_policy/wifi_network (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wifi_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wifi_network() directly.

    YANG Description: If present, and the application prefers to a Wi-Fi network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wifi-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wifi_network must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wifi-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__wifi_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wifi_network(self):
    self.__wifi_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="wifi-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_fixed_access_network(self):
    """
    Getter method for fixed_access_network, mapped from YANG variable /app_descriptor/network_policy/fixed_access_network (boolean)

    YANG Description: If present, and the application prefers to a fixed access network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    return self.__fixed_access_network
      
  def _set_fixed_access_network(self, v, load=False):
    """
    Setter method for fixed_access_network, mapped from YANG variable /app_descriptor/network_policy/fixed_access_network (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fixed_access_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fixed_access_network() directly.

    YANG Description: If present, and the application prefers to a fixed access network to carry its traffic, this attribute shall be set to true. Otherwise, it shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixed-access-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fixed_access_network must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixed-access-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__fixed_access_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fixed_access_network(self):
    self.__fixed_access_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="fixed-access-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

  cellular_network = __builtin__.property(_get_cellular_network, _set_cellular_network)
  wifi_network = __builtin__.property(_get_wifi_network, _set_wifi_network)
  fixed_access_network = __builtin__.property(_get_fixed_access_network, _set_fixed_access_network)


  _pyangbind_elements = OrderedDict([('cellular_network', cellular_network), ('wifi_network', wifi_network), ('fixed_access_network', fixed_access_network), ])


class yc_sw_image_mec_app_descriptor__app_descriptor_sw_image(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/sw-image. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Software Image Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__version','__checksum','__container_format','__disk_format','__min_disk','__min_ram','__size','__sw_image','__operating_system','__supported_virtualisation_environment',)

  _yang_name = 'sw-image'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__container_format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__disk_format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__min_disk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__min_ram = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__sw_image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__operating_system = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__supported_virtualisation_environment = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualisation-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'sw-image']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/sw_image/id (string)

    YANG Description: The identifier of this software image.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/sw_image/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The identifier of this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/sw_image/name (string)

    YANG Description: The name of this software image.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/sw_image/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/sw_image/version (string)

    YANG Description: The version of this software image.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/sw_image/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_checksum(self):
    """
    Getter method for checksum, mapped from YANG variable /app_descriptor/sw_image/checksum (string)

    YANG Description: The checksum of the software image file.
    """
    return self.__checksum
      
  def _set_checksum(self, v, load=False):
    """
    Setter method for checksum, mapped from YANG variable /app_descriptor/sw_image/checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checksum() directly.

    YANG Description: The checksum of the software image file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """checksum must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__checksum = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_checksum(self):
    self.__checksum = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_container_format(self):
    """
    Getter method for container_format, mapped from YANG variable /app_descriptor/sw_image/container_format (string)

    YANG Description: The container format describes the container file format in which software image is provided.
    """
    return self.__container_format
      
  def _set_container_format(self, v, load=False):
    """
    Setter method for container_format, mapped from YANG variable /app_descriptor/sw_image/container_format (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_container_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_container_format() directly.

    YANG Description: The container format describes the container file format in which software image is provided.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """container_format must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__container_format = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_container_format(self):
    self.__container_format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_disk_format(self):
    """
    Getter method for disk_format, mapped from YANG variable /app_descriptor/sw_image/disk_format (string)

    YANG Description: The disk format of a software image is the format of the underlying disk image.
    """
    return self.__disk_format
      
  def _set_disk_format(self, v, load=False):
    """
    Setter method for disk_format, mapped from YANG variable /app_descriptor/sw_image/disk_format (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disk_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disk_format() directly.

    YANG Description: The disk format of a software image is the format of the underlying disk image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """disk_format must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__disk_format = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_disk_format(self):
    self.__disk_format = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_min_disk(self):
    """
    Getter method for min_disk, mapped from YANG variable /app_descriptor/sw_image/min_disk (uint64)

    YANG Description: The minimal disk size requirement for this software image.
    """
    return self.__min_disk
      
  def _set_min_disk(self, v, load=False):
    """
    Setter method for min_disk, mapped from YANG variable /app_descriptor/sw_image/min_disk (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_disk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_disk() directly.

    YANG Description: The minimal disk size requirement for this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_disk must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__min_disk = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_disk(self):
    self.__min_disk = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_min_ram(self):
    """
    Getter method for min_ram, mapped from YANG variable /app_descriptor/sw_image/min_ram (uint64)

    YANG Description: The minimal RAM requirement for this software image.
    """
    return self.__min_ram
      
  def _set_min_ram(self, v, load=False):
    """
    Setter method for min_ram, mapped from YANG variable /app_descriptor/sw_image/min_ram (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ram is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_ram() directly.

    YANG Description: The minimal RAM requirement for this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ram must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__min_ram = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_ram(self):
    self.__min_ram = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_size(self):
    """
    Getter method for size, mapped from YANG variable /app_descriptor/sw_image/size (uint64)

    YANG Description: The size of this software image file.
    """
    return self.__size
      
  def _set_size(self, v, load=False):
    """
    Setter method for size, mapped from YANG variable /app_descriptor/sw_image/size (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: The size of this software image file.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size(self):
    self.__size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_sw_image(self):
    """
    Getter method for sw_image, mapped from YANG variable /app_descriptor/sw_image/sw_image (string)

    YANG Description: This is a reference to the actual software image.
    """
    return self.__sw_image
      
  def _set_sw_image(self, v, load=False):
    """
    Setter method for sw_image, mapped from YANG variable /app_descriptor/sw_image/sw_image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image() directly.

    YANG Description: This is a reference to the actual software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sw_image must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__sw_image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sw_image(self):
    self.__sw_image = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_operating_system(self):
    """
    Getter method for operating_system, mapped from YANG variable /app_descriptor/sw_image/operating_system (string)

    YANG Description: Specifies the operating system used in the software image.
    """
    return self.__operating_system
      
  def _set_operating_system(self, v, load=False):
    """
    Setter method for operating_system, mapped from YANG variable /app_descriptor/sw_image/operating_system (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_system() directly.

    YANG Description: Specifies the operating system used in the software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operating_system must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__operating_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operating_system(self):
    self.__operating_system = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_supported_virtualisation_environment(self):
    """
    Getter method for supported_virtualisation_environment, mapped from YANG variable /app_descriptor/sw_image/supported_virtualisation_environment (string)

    YANG Description: Specifies the virtualisation environments compatible with this software image.
    """
    return self.__supported_virtualisation_environment
      
  def _set_supported_virtualisation_environment(self, v, load=False):
    """
    Setter method for supported_virtualisation_environment, mapped from YANG variable /app_descriptor/sw_image/supported_virtualisation_environment (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_virtualisation_environment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_virtualisation_environment() directly.

    YANG Description: Specifies the virtualisation environments compatible with this software image.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualisation-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supported_virtualisation_environment must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualisation-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__supported_virtualisation_environment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supported_virtualisation_environment(self):
    self.__supported_virtualisation_environment = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualisation-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)
  checksum = __builtin__.property(_get_checksum, _set_checksum)
  container_format = __builtin__.property(_get_container_format, _set_container_format)
  disk_format = __builtin__.property(_get_disk_format, _set_disk_format)
  min_disk = __builtin__.property(_get_min_disk, _set_min_disk)
  min_ram = __builtin__.property(_get_min_ram, _set_min_ram)
  size = __builtin__.property(_get_size, _set_size)
  sw_image = __builtin__.property(_get_sw_image, _set_sw_image)
  operating_system = __builtin__.property(_get_operating_system, _set_operating_system)
  supported_virtualisation_environment = __builtin__.property(_get_supported_virtualisation_environment, _set_supported_virtualisation_environment)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('checksum', checksum), ('container_format', container_format), ('disk_format', disk_format), ('min_disk', min_disk), ('min_ram', min_ram), ('size', size), ('sw_image', sw_image), ('operating_system', operating_system), ('supported_virtualisation_environment', supported_virtualisation_environment), ])


class yc_dns_rule_mec_app_descriptor__app_descriptor_dns_rule(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/dns-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the DNS Rule Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__domain_name','__ip_address_type','__ip_address','__ttl',)

  _yang_name = 'dns-rule'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__domain_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__ip_address_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__ip_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'dns-rule']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/dns_rule/id (string)

    YANG Description: Identifies the DNS Rule.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/dns_rule/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies the DNS Rule.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_domain_name(self):
    """
    Getter method for domain_name, mapped from YANG variable /app_descriptor/dns_rule/domain_name (string)

    YANG Description: FQDN of the DNS rule.
    """
    return self.__domain_name
      
  def _set_domain_name(self, v, load=False):
    """
    Setter method for domain_name, mapped from YANG variable /app_descriptor/dns_rule/domain_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_domain_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_domain_name() directly.

    YANG Description: FQDN of the DNS rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """domain_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__domain_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_domain_name(self):
    self.__domain_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="domain-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_ip_address_type(self):
    """
    Getter method for ip_address_type, mapped from YANG variable /app_descriptor/dns_rule/ip_address_type (enumeration)

    YANG Description: Specifies the IP address type, value: IP_V6, IP_V4.
    """
    return self.__ip_address_type
      
  def _set_ip_address_type(self, v, load=False):
    """
    Setter method for ip_address_type, mapped from YANG variable /app_descriptor/dns_rule/ip_address_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_type() directly.

    YANG Description: Specifies the IP address type, value: IP_V6, IP_V4.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address_type must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__ip_address_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address_type(self):
    self.__ip_address_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'IP_V4': {}, 'IP_V6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_ip_address(self):
    """
    Getter method for ip_address, mapped from YANG variable /app_descriptor/dns_rule/ip_address (string)

    YANG Description: IP address given by the DNS rule.
    """
    return self.__ip_address
      
  def _set_ip_address(self, v, load=False):
    """
    Setter method for ip_address, mapped from YANG variable /app_descriptor/dns_rule/ip_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address given by the DNS rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip_address must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__ip_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip_address(self):
    self.__ip_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_ttl(self):
    """
    Getter method for ttl, mapped from YANG variable /app_descriptor/dns_rule/ttl (uint32)

    YANG Description: Time-to-live value.
    """
    return self.__ttl
      
  def _set_ttl(self, v, load=False):
    """
    Setter method for ttl, mapped from YANG variable /app_descriptor/dns_rule/ttl (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl() directly.

    YANG Description: Time-to-live value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl(self):
    self.__ttl = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  domain_name = __builtin__.property(_get_domain_name, _set_domain_name)
  ip_address_type = __builtin__.property(_get_ip_address_type, _set_ip_address_type)
  ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
  ttl = __builtin__.property(_get_ttl, _set_ttl)


  _pyangbind_elements = OrderedDict([('id', id), ('domain_name', domain_name), ('ip_address_type', ip_address_type), ('ip_address', ip_address), ('ttl', ttl), ])


class yc_latency_mec_app_descriptor__app_descriptor_latency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/latency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Latency Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_latency',)

  _yang_name = 'latency'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_latency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'latency']

  def _get_max_latency(self):
    """
    Getter method for max_latency, mapped from YANG variable /app_descriptor/latency/max_latency (uint32)

    YANG Description: The value of the maximum latency in nano seconds tolerated by the MEC application.
    """
    return self.__max_latency
      
  def _set_max_latency(self, v, load=False):
    """
    Setter method for max_latency, mapped from YANG variable /app_descriptor/latency/max_latency (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_latency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_latency() directly.

    YANG Description: The value of the maximum latency in nano seconds tolerated by the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_latency must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)""",
        })

    self.__max_latency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_latency(self):
    self.__max_latency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint32', is_config=True)

  max_latency = __builtin__.property(_get_max_latency, _set_max_latency)


  _pyangbind_elements = OrderedDict([('max_latency', max_latency), ])


class yc_block_storage_mec_app_descriptor__app_descriptor_virtual_storage_block_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-storage/block-storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Block storage data, applicable only if typeOfStorage=BLOCK
  """
  __slots__ = ('_path_helper', '_extmethods', '__hosting_provides_iops','__guaranteed_iops','__max_iops',)

  _yang_name = 'block-storage'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__hosting_provides_iops = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__guaranteed_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-storage', 'block-storage']

  def _get_hosting_provides_iops(self):
    """
    Getter method for hosting_provides_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/hosting_provides_iops (boolean)

    YANG Description: If set to true, the NFVI provides dedicated IOPS (I/O operations per second) to the virtualised block storage resource
    """
    return self.__hosting_provides_iops
      
  def _set_hosting_provides_iops(self, v, load=False):
    """
    Setter method for hosting_provides_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/hosting_provides_iops (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hosting_provides_iops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hosting_provides_iops() directly.

    YANG Description: If set to true, the NFVI provides dedicated IOPS (I/O operations per second) to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hosting_provides_iops must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__hosting_provides_iops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hosting_provides_iops(self):
    self.__hosting_provides_iops = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hosting-provides-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_guaranteed_iops(self):
    """
    Getter method for guaranteed_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/guaranteed_iops (uint64)

    YANG Description: Minimum IOPS that the NFVI provides to the virtualised block storage resource
    """
    return self.__guaranteed_iops
      
  def _set_guaranteed_iops(self, v, load=False):
    """
    Setter method for guaranteed_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/guaranteed_iops (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_guaranteed_iops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_guaranteed_iops() directly.

    YANG Description: Minimum IOPS that the NFVI provides to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """guaranteed_iops must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__guaranteed_iops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_guaranteed_iops(self):
    self.__guaranteed_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="guaranteed-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_iops(self):
    """
    Getter method for max_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/max_iops (uint64)

    YANG Description: Maximum IOPS that the NFVI provides to the virtualised block storage resource
    """
    return self.__max_iops
      
  def _set_max_iops(self, v, load=False):
    """
    Setter method for max_iops, mapped from YANG variable /app_descriptor/virtual_storage/block_storage/max_iops (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_iops is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_iops() directly.

    YANG Description: Maximum IOPS that the NFVI provides to the virtualised block storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_iops must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_iops = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_iops(self):
    self.__max_iops = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-iops", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  hosting_provides_iops = __builtin__.property(_get_hosting_provides_iops, _set_hosting_provides_iops)
  guaranteed_iops = __builtin__.property(_get_guaranteed_iops, _set_guaranteed_iops)
  max_iops = __builtin__.property(_get_max_iops, _set_max_iops)

  __choices__ = {'storage': {'block-storage': ['hosting_provides_iops', 'guaranteed_iops', 'max_iops']}}
  _pyangbind_elements = OrderedDict([('hosting_provides_iops', hosting_provides_iops), ('guaranteed_iops', guaranteed_iops), ('max_iops', max_iops), ])


class yc_object_storage_mec_app_descriptor__app_descriptor_virtual_storage_object_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-storage/object-storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Object storage data, applicable only if typeOfStorage=OBJECT
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_size_of_object','__max_concurrent_incoming_transfers','__max_concurrent_outgoing_transfers',)

  _yang_name = 'object-storage'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_size_of_object = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-object", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_concurrent_incoming_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_concurrent_outgoing_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-storage', 'object-storage']

  def _get_max_size_of_object(self):
    """
    Getter method for max_size_of_object, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_size_of_object (uint64)

    YANG Description: Maximum size of object that can be stored in the object storage resource
    """
    return self.__max_size_of_object
      
  def _set_max_size_of_object(self, v, load=False):
    """
    Setter method for max_size_of_object, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_size_of_object (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_size_of_object is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_size_of_object() directly.

    YANG Description: Maximum size of object that can be stored in the object storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-object", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_size_of_object must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-object", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_size_of_object = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_size_of_object(self):
    self.__max_size_of_object = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-object", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_concurrent_incoming_transfers(self):
    """
    Getter method for max_concurrent_incoming_transfers, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_concurrent_incoming_transfers (uint64)

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the object storage resource can handle
    """
    return self.__max_concurrent_incoming_transfers
      
  def _set_max_concurrent_incoming_transfers(self, v, load=False):
    """
    Setter method for max_concurrent_incoming_transfers, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_concurrent_incoming_transfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_concurrent_incoming_transfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_concurrent_incoming_transfers() directly.

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the object storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_concurrent_incoming_transfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_concurrent_incoming_transfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_concurrent_incoming_transfers(self):
    self.__max_concurrent_incoming_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_concurrent_outgoing_transfers(self):
    """
    Getter method for max_concurrent_outgoing_transfers, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_concurrent_outgoing_transfers (uint64)

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the object storage resource can handle
    """
    return self.__max_concurrent_outgoing_transfers
      
  def _set_max_concurrent_outgoing_transfers(self, v, load=False):
    """
    Setter method for max_concurrent_outgoing_transfers, mapped from YANG variable /app_descriptor/virtual_storage/object_storage/max_concurrent_outgoing_transfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_concurrent_outgoing_transfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_concurrent_outgoing_transfers() directly.

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the object storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_concurrent_outgoing_transfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_concurrent_outgoing_transfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_concurrent_outgoing_transfers(self):
    self.__max_concurrent_outgoing_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  max_size_of_object = __builtin__.property(_get_max_size_of_object, _set_max_size_of_object)
  max_concurrent_incoming_transfers = __builtin__.property(_get_max_concurrent_incoming_transfers, _set_max_concurrent_incoming_transfers)
  max_concurrent_outgoing_transfers = __builtin__.property(_get_max_concurrent_outgoing_transfers, _set_max_concurrent_outgoing_transfers)

  __choices__ = {'storage': {'object-storage': ['max_size_of_object', 'max_concurrent_incoming_transfers', 'max_concurrent_outgoing_transfers']}}
  _pyangbind_elements = OrderedDict([('max_size_of_object', max_size_of_object), ('max_concurrent_incoming_transfers', max_concurrent_incoming_transfers), ('max_concurrent_outgoing_transfers', max_concurrent_outgoing_transfers), ])


class yc_file_storage_mec_app_descriptor__app_descriptor_virtual_storage_file_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-storage/file-storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: File storage data, applicable only if typeOfStorage=FILE
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_size_of_file','__max_concurrent_incoming_transfers','__max_concurrent_outgoing_transfers',)

  _yang_name = 'file-storage'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_size_of_file = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-file", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_concurrent_incoming_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__max_concurrent_outgoing_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-storage', 'file-storage']

  def _get_max_size_of_file(self):
    """
    Getter method for max_size_of_file, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_size_of_file (uint64)

    YANG Description: Maximum size of file that can be stored in the file storage resource
    """
    return self.__max_size_of_file
      
  def _set_max_size_of_file(self, v, load=False):
    """
    Setter method for max_size_of_file, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_size_of_file (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_size_of_file is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_size_of_file() directly.

    YANG Description: Maximum size of file that can be stored in the file storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-file", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_size_of_file must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-file", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_size_of_file = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_size_of_file(self):
    self.__max_size_of_file = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-size-of-file", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_concurrent_incoming_transfers(self):
    """
    Getter method for max_concurrent_incoming_transfers, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_concurrent_incoming_transfers (uint64)

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the file storage resource can handle
    """
    return self.__max_concurrent_incoming_transfers
      
  def _set_max_concurrent_incoming_transfers(self, v, load=False):
    """
    Setter method for max_concurrent_incoming_transfers, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_concurrent_incoming_transfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_concurrent_incoming_transfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_concurrent_incoming_transfers() directly.

    YANG Description: Maximum number of concurrent incoming transfers (downloads) that the file storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_concurrent_incoming_transfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_concurrent_incoming_transfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_concurrent_incoming_transfers(self):
    self.__max_concurrent_incoming_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-incoming-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_max_concurrent_outgoing_transfers(self):
    """
    Getter method for max_concurrent_outgoing_transfers, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_concurrent_outgoing_transfers (uint64)

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the file storage resource can handle
    """
    return self.__max_concurrent_outgoing_transfers
      
  def _set_max_concurrent_outgoing_transfers(self, v, load=False):
    """
    Setter method for max_concurrent_outgoing_transfers, mapped from YANG variable /app_descriptor/virtual_storage/file_storage/max_concurrent_outgoing_transfers (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_concurrent_outgoing_transfers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_concurrent_outgoing_transfers() directly.

    YANG Description: Maximum number of concurrent outgoing transfers (uploads) that the file storage resource can handle
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_concurrent_outgoing_transfers must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__max_concurrent_outgoing_transfers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_concurrent_outgoing_transfers(self):
    self.__max_concurrent_outgoing_transfers = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-concurrent-outgoing-transfers", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)

  max_size_of_file = __builtin__.property(_get_max_size_of_file, _set_max_size_of_file)
  max_concurrent_incoming_transfers = __builtin__.property(_get_max_concurrent_incoming_transfers, _set_max_concurrent_incoming_transfers)
  max_concurrent_outgoing_transfers = __builtin__.property(_get_max_concurrent_outgoing_transfers, _set_max_concurrent_outgoing_transfers)

  __choices__ = {'storage': {'file-storage': ['max_size_of_file', 'max_concurrent_incoming_transfers', 'max_concurrent_outgoing_transfers']}}
  _pyangbind_elements = OrderedDict([('max_size_of_file', max_size_of_file), ('max_concurrent_incoming_transfers', max_concurrent_incoming_transfers), ('max_concurrent_outgoing_transfers', max_concurrent_outgoing_transfers), ])


class yc_virtual_storage_mec_app_descriptor__app_descriptor_virtual_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/virtual-storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates Virtual Storage Descriptor into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__type_of_storage','__block_storage','__object_storage','__file_storage','__size_of_storage','__operation_status',)

  _yang_name = 'virtual-storage'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__type_of_storage = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    self.__block_storage = YANGDynClass(base=yc_block_storage_mec_app_descriptor__app_descriptor_virtual_storage_block_storage, is_container='container', yang_name="block-storage", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__object_storage = YANGDynClass(base=yc_object_storage_mec_app_descriptor__app_descriptor_virtual_storage_object_storage, is_container='container', yang_name="object-storage", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__file_storage = YANGDynClass(base=yc_file_storage_mec_app_descriptor__app_descriptor_virtual_storage_file_storage, is_container='container', yang_name="file-storage", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__size_of_storage = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    self.__operation_status = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'virtual-storage']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/virtual_storage/id (string)

    YANG Description: Unique identifier for this VirtualStorageDesc
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/virtual_storage/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier for this VirtualStorageDesc
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_type_of_storage(self):
    """
    Getter method for type_of_storage, mapped from YANG variable /app_descriptor/virtual_storage/type_of_storage (enumeration)

    YANG Description: Type of virtualised storage resource
    """
    return self.__type_of_storage
      
  def _set_type_of_storage(self, v, load=False):
    """
    Setter method for type_of_storage, mapped from YANG variable /app_descriptor/virtual_storage/type_of_storage (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_of_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_of_storage() directly.

    YANG Description: Type of virtualised storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_of_storage must be of a type compatible with enumeration""",
          'defined-type': "mec-app-descriptor:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)""",
        })

    self.__type_of_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_of_storage(self):
    self.__type_of_storage = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'BLOCK': {}, 'OBJECT': {}, 'FILE': {}},), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='enumeration', is_config=True)


  def _get_block_storage(self):
    """
    Getter method for block_storage, mapped from YANG variable /app_descriptor/virtual_storage/block_storage (container)

    YANG Description: Block storage data, applicable only if typeOfStorage=BLOCK
    """
    return self.__block_storage
      
  def _set_block_storage(self, v, load=False):
    """
    Setter method for block_storage, mapped from YANG variable /app_descriptor/virtual_storage/block_storage (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_block_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_block_storage() directly.

    YANG Description: Block storage data, applicable only if typeOfStorage=BLOCK
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_block_storage_mec_app_descriptor__app_descriptor_virtual_storage_block_storage, is_container='container', yang_name="block-storage", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """block_storage must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_block_storage_mec_app_descriptor__app_descriptor_virtual_storage_block_storage, is_container='container', yang_name="block-storage", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__block_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_block_storage(self):
    self.__block_storage = YANGDynClass(base=yc_block_storage_mec_app_descriptor__app_descriptor_virtual_storage_block_storage, is_container='container', yang_name="block-storage", parent=self, choice=('storage', 'block-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_object_storage(self):
    """
    Getter method for object_storage, mapped from YANG variable /app_descriptor/virtual_storage/object_storage (container)

    YANG Description: Object storage data, applicable only if typeOfStorage=OBJECT
    """
    return self.__object_storage
      
  def _set_object_storage(self, v, load=False):
    """
    Setter method for object_storage, mapped from YANG variable /app_descriptor/virtual_storage/object_storage (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_object_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_object_storage() directly.

    YANG Description: Object storage data, applicable only if typeOfStorage=OBJECT
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_object_storage_mec_app_descriptor__app_descriptor_virtual_storage_object_storage, is_container='container', yang_name="object-storage", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """object_storage must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_object_storage_mec_app_descriptor__app_descriptor_virtual_storage_object_storage, is_container='container', yang_name="object-storage", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__object_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_object_storage(self):
    self.__object_storage = YANGDynClass(base=yc_object_storage_mec_app_descriptor__app_descriptor_virtual_storage_object_storage, is_container='container', yang_name="object-storage", parent=self, choice=('storage', 'object-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_file_storage(self):
    """
    Getter method for file_storage, mapped from YANG variable /app_descriptor/virtual_storage/file_storage (container)

    YANG Description: File storage data, applicable only if typeOfStorage=FILE
    """
    return self.__file_storage
      
  def _set_file_storage(self, v, load=False):
    """
    Setter method for file_storage, mapped from YANG variable /app_descriptor/virtual_storage/file_storage (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_file_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_file_storage() directly.

    YANG Description: File storage data, applicable only if typeOfStorage=FILE
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_file_storage_mec_app_descriptor__app_descriptor_virtual_storage_file_storage, is_container='container', yang_name="file-storage", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """file_storage must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_file_storage_mec_app_descriptor__app_descriptor_virtual_storage_file_storage, is_container='container', yang_name="file-storage", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__file_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_file_storage(self):
    self.__file_storage = YANGDynClass(base=yc_file_storage_mec_app_descriptor__app_descriptor_virtual_storage_file_storage, is_container='container', yang_name="file-storage", parent=self, choice=('storage', 'file-storage'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_size_of_storage(self):
    """
    Getter method for size_of_storage, mapped from YANG variable /app_descriptor/virtual_storage/size_of_storage (uint64)

    YANG Description: Size of virtualised storage resource (e.g. size of block storage device)
    """
    return self.__size_of_storage
      
  def _set_size_of_storage(self, v, load=False):
    """
    Setter method for size_of_storage, mapped from YANG variable /app_descriptor/virtual_storage/size_of_storage (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size_of_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size_of_storage() directly.

    YANG Description: Size of virtualised storage resource (e.g. size of block storage device)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """size_of_storage must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)""",
        })

    self.__size_of_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_size_of_storage(self):
    self.__size_of_storage = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='uint64', is_config=True)


  def _get_operation_status(self):
    """
    Getter method for operation_status, mapped from YANG variable /app_descriptor/virtual_storage/operation_status (string)

    YANG Description: Operation status of the virtualised storage resource
    """
    return self.__operation_status
      
  def _set_operation_status(self, v, load=False):
    """
    Setter method for operation_status, mapped from YANG variable /app_descriptor/virtual_storage/operation_status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operation_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operation_status() directly.

    YANG Description: Operation status of the virtualised storage resource
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operation_status must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__operation_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operation_status(self):
    self.__operation_status = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="operation-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  type_of_storage = __builtin__.property(_get_type_of_storage, _set_type_of_storage)
  block_storage = __builtin__.property(_get_block_storage, _set_block_storage)
  object_storage = __builtin__.property(_get_object_storage, _set_object_storage)
  file_storage = __builtin__.property(_get_file_storage, _set_file_storage)
  size_of_storage = __builtin__.property(_get_size_of_storage, _set_size_of_storage)
  operation_status = __builtin__.property(_get_operation_status, _set_operation_status)

  __choices__ = {'storage': {'block-storage': ['block_storage'], 'object-storage': ['object_storage'], 'file-storage': ['file_storage']}}
  _pyangbind_elements = OrderedDict([('id', id), ('type_of_storage', type_of_storage), ('block_storage', block_storage), ('object_storage', object_storage), ('file_storage', file_storage), ('size_of_storage', size_of_storage), ('operation_status', operation_status), ])


class yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_user_context_transfer_capability(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/user-context-transfer-capability. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the user context transfer capability attributes into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__stateful_application','__user_context_transfer_support',)

  _yang_name = 'user-context-transfer-capability'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__stateful_application = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stateful-application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    self.__user_context_transfer_support = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="user-context-transfer-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'user-context-transfer-capability']

  def _get_stateful_application(self):
    """
    Getter method for stateful_application, mapped from YANG variable /app_descriptor/user_context_transfer_capability/stateful_application (boolean)

    YANG Description: If the application is stateful, this attribute shall be set to true. Otherwise, this attribute shall be set to false.
    """
    return self.__stateful_application
      
  def _set_stateful_application(self, v, load=False):
    """
    Setter method for stateful_application, mapped from YANG variable /app_descriptor/user_context_transfer_capability/stateful_application (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stateful_application is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stateful_application() directly.

    YANG Description: If the application is stateful, this attribute shall be set to true. Otherwise, this attribute shall be set to false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="stateful-application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stateful_application must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stateful-application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__stateful_application = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stateful_application(self):
    self.__stateful_application = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="stateful-application", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)


  def _get_user_context_transfer_support(self):
    """
    Getter method for user_context_transfer_support, mapped from YANG variable /app_descriptor/user_context_transfer_capability/user_context_transfer_support (boolean)

    YANG Description: This attribute shall be present if the application is stateful and supports the user context transfer. Otherwise, this attribute shall be set to false or be absent.
    """
    return self.__user_context_transfer_support
      
  def _set_user_context_transfer_support(self, v, load=False):
    """
    Setter method for user_context_transfer_support, mapped from YANG variable /app_descriptor/user_context_transfer_capability/user_context_transfer_support (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_context_transfer_support is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_context_transfer_support() directly.

    YANG Description: This attribute shall be present if the application is stateful and supports the user context transfer. Otherwise, this attribute shall be set to false or be absent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="user-context-transfer-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_context_transfer_support must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="user-context-transfer-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)""",
        })

    self.__user_context_transfer_support = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_context_transfer_support(self):
    self.__user_context_transfer_support = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="user-context-transfer-support", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='boolean', is_config=True)

  stateful_application = __builtin__.property(_get_stateful_application, _set_stateful_application)
  user_context_transfer_support = __builtin__.property(_get_user_context_transfer_support, _set_user_context_transfer_support)


  _pyangbind_elements = OrderedDict([('stateful_application', stateful_application), ('user_context_transfer_support', user_context_transfer_support), ])


class yc_feature_dependency_mec_app_descriptor__app_descriptor_feature_dependency(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor/feature-dependency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Incorporates the Feature Dependency into the MEC application descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__version',)

  _yang_name = 'feature-dependency'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor', 'feature-dependency']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/feature_dependency/name (string)

    YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/feature_dependency/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the feature, for example, UserApps, UEIdentity, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/feature_dependency/version (string)

    YANG Description: The version of the feature.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/feature_dependency/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of the feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  version = __builtin__.property(_get_version, _set_version)


  _pyangbind_elements = OrderedDict([('name', name), ('version', version), ])


class yc_app_descriptor_mec_app_descriptor__app_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /app-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__name','__provider','__soft_version','__version','__mec_version','__info_name','__description','__network_policy','__sw_image','__dns_rule','__latency','__virtual_storage','__user_context_transfer_capability','__feature_dependency',)

  _yang_name = 'app-descriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__provider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__soft_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="soft-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__mec_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mec-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__info_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    self.__network_policy = YANGDynClass(base=yc_network_policy_mec_app_descriptor__app_descriptor_network_policy, is_container='container', yang_name="network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__sw_image = YANGDynClass(base=yc_sw_image_mec_app_descriptor__app_descriptor_sw_image, is_container='container', yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__dns_rule = YANGDynClass(base=YANGListType("id",yc_dns_rule_mec_app_descriptor__app_descriptor_dns_rule, yang_name="dns-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dns-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__latency = YANGDynClass(base=yc_latency_mec_app_descriptor__app_descriptor_latency, is_container='container', yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__virtual_storage = YANGDynClass(base=YANGListType("id",yc_virtual_storage_mec_app_descriptor__app_descriptor_virtual_storage, yang_name="virtual-storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    self.__user_context_transfer_capability = YANGDynClass(base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    self.__feature_dependency = YANGDynClass(base=yc_feature_dependency_mec_app_descriptor__app_descriptor_feature_dependency, is_container='container', yang_name="feature-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['app-descriptor']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /app_descriptor/id (string)

    YANG Description: Identifier of this MEC application descriptor. This attribute shall be globally unique.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /app_descriptor/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this MEC application descriptor. This attribute shall be globally unique.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /app_descriptor/name (string)

    YANG Description: Name to identify the MEC application.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /app_descriptor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name to identify the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_provider(self):
    """
    Getter method for provider, mapped from YANG variable /app_descriptor/provider (string)

    YANG Description: Provider of the application and of the AppD.
    """
    return self.__provider
      
  def _set_provider(self, v, load=False):
    """
    Setter method for provider, mapped from YANG variable /app_descriptor/provider (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider() directly.

    YANG Description: Provider of the application and of the AppD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provider must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__provider = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provider(self):
    self.__provider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_soft_version(self):
    """
    Getter method for soft_version, mapped from YANG variable /app_descriptor/soft_version (string)

    YANG Description: Identifies the version of software of the MEC application.
    """
    return self.__soft_version
      
  def _set_soft_version(self, v, load=False):
    """
    Setter method for soft_version, mapped from YANG variable /app_descriptor/soft_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_version() directly.

    YANG Description: Identifies the version of software of the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="soft-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="soft-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__soft_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_version(self):
    self.__soft_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="soft-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_version(self):
    """
    Getter method for version, mapped from YANG variable /app_descriptor/version (string)

    YANG Description: Identifies the version of the application descriptor.
    """
    return self.__version
      
  def _set_version(self, v, load=False):
    """
    Setter method for version, mapped from YANG variable /app_descriptor/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Identifies the version of the application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_version(self):
    self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_mec_version(self):
    """
    Getter method for mec_version, mapped from YANG variable /app_descriptor/mec_version (string)

    YANG Description: Identifies version(s) of MEC system compatible with the MEC application described in this version of the AppD. The value shall be formatted as comma-separated list of strings.
    """
    return self.__mec_version
      
  def _set_mec_version(self, v, load=False):
    """
    Setter method for mec_version, mapped from YANG variable /app_descriptor/mec_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mec_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mec_version() directly.

    YANG Description: Identifies version(s) of MEC system compatible with the MEC application described in this version of the AppD. The value shall be formatted as comma-separated list of strings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mec-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mec_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mec-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__mec_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mec_version(self):
    self.__mec_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mec-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_info_name(self):
    """
    Getter method for info_name, mapped from YANG variable /app_descriptor/info_name (string)

    YANG Description: Human readable name for the MEC application.
    """
    return self.__info_name
      
  def _set_info_name(self, v, load=False):
    """
    Setter method for info_name, mapped from YANG variable /app_descriptor/info_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_info_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_info_name() directly.

    YANG Description: Human readable name for the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """info_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__info_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_info_name(self):
    self.__info_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /app_descriptor/description (string)

    YANG Description: Human readable description of the MEC application.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /app_descriptor/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the MEC application.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='string', is_config=True)


  def _get_network_policy(self):
    """
    Getter method for network_policy, mapped from YANG variable /app_descriptor/network_policy (container)

    YANG Description: Application network policy.
    """
    return self.__network_policy
      
  def _set_network_policy(self, v, load=False):
    """
    Setter method for network_policy, mapped from YANG variable /app_descriptor/network_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_policy() directly.

    YANG Description: Application network policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_policy_mec_app_descriptor__app_descriptor_network_policy, is_container='container', yang_name="network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_policy_mec_app_descriptor__app_descriptor_network_policy, is_container='container', yang_name="network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__network_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_policy(self):
    self.__network_policy = YANGDynClass(base=yc_network_policy_mec_app_descriptor__app_descriptor_network_policy, is_container='container', yang_name="network-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_sw_image(self):
    """
    Getter method for sw_image, mapped from YANG variable /app_descriptor/sw_image (container)

    YANG Description: Incorporates the Software Image Descriptor into the MEC application descriptor.
    """
    return self.__sw_image
      
  def _set_sw_image(self, v, load=False):
    """
    Setter method for sw_image, mapped from YANG variable /app_descriptor/sw_image (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image() directly.

    YANG Description: Incorporates the Software Image Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sw_image_mec_app_descriptor__app_descriptor_sw_image, is_container='container', yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sw_image must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sw_image_mec_app_descriptor__app_descriptor_sw_image, is_container='container', yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__sw_image = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sw_image(self):
    self.__sw_image = YANGDynClass(base=yc_sw_image_mec_app_descriptor__app_descriptor_sw_image, is_container='container', yang_name="sw-image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_dns_rule(self):
    """
    Getter method for dns_rule, mapped from YANG variable /app_descriptor/dns_rule (list)

    YANG Description: Incorporates the DNS Rule Descriptor into the MEC application descriptor.
    """
    return self.__dns_rule
      
  def _set_dns_rule(self, v, load=False):
    """
    Setter method for dns_rule, mapped from YANG variable /app_descriptor/dns_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_rule() directly.

    YANG Description: Incorporates the DNS Rule Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_dns_rule_mec_app_descriptor__app_descriptor_dns_rule, yang_name="dns-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dns-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns_rule must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_dns_rule_mec_app_descriptor__app_descriptor_dns_rule, yang_name="dns-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dns-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__dns_rule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns_rule(self):
    self.__dns_rule = YANGDynClass(base=YANGListType("id",yc_dns_rule_mec_app_descriptor__app_descriptor_dns_rule, yang_name="dns-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dns-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_latency(self):
    """
    Getter method for latency, mapped from YANG variable /app_descriptor/latency (container)

    YANG Description: Incorporates the Latency Descriptor into the MEC application descriptor.
    """
    return self.__latency
      
  def _set_latency(self, v, load=False):
    """
    Setter method for latency, mapped from YANG variable /app_descriptor/latency (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latency() directly.

    YANG Description: Incorporates the Latency Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_latency_mec_app_descriptor__app_descriptor_latency, is_container='container', yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """latency must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_latency_mec_app_descriptor__app_descriptor_latency, is_container='container', yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__latency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_latency(self):
    self.__latency = YANGDynClass(base=yc_latency_mec_app_descriptor__app_descriptor_latency, is_container='container', yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_virtual_storage(self):
    """
    Getter method for virtual_storage, mapped from YANG variable /app_descriptor/virtual_storage (list)

    YANG Description: Incorporates Virtual Storage Descriptor into the MEC application descriptor.
    """
    return self.__virtual_storage
      
  def _set_virtual_storage(self, v, load=False):
    """
    Setter method for virtual_storage, mapped from YANG variable /app_descriptor/virtual_storage (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_storage() directly.

    YANG Description: Incorporates Virtual Storage Descriptor into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_virtual_storage_mec_app_descriptor__app_descriptor_virtual_storage, yang_name="virtual-storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """virtual_storage must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_storage_mec_app_descriptor__app_descriptor_virtual_storage, yang_name="virtual-storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)""",
        })

    self.__virtual_storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_virtual_storage(self):
    self.__virtual_storage = YANGDynClass(base=YANGListType("id",yc_virtual_storage_mec_app_descriptor__app_descriptor_virtual_storage, yang_name="virtual-storage", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='list', is_config=True)


  def _get_user_context_transfer_capability(self):
    """
    Getter method for user_context_transfer_capability, mapped from YANG variable /app_descriptor/user_context_transfer_capability (container)

    YANG Description: Incorporates the user context transfer capability attributes into the MEC application descriptor.
    """
    return self.__user_context_transfer_capability
      
  def _set_user_context_transfer_capability(self, v, load=False):
    """
    Setter method for user_context_transfer_capability, mapped from YANG variable /app_descriptor/user_context_transfer_capability (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_context_transfer_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_context_transfer_capability() directly.

    YANG Description: Incorporates the user context transfer capability attributes into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """user_context_transfer_capability must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__user_context_transfer_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_user_context_transfer_capability(self):
    self.__user_context_transfer_capability = YANGDynClass(base=yc_user_context_transfer_capability_mec_app_descriptor__app_descriptor_user_context_transfer_capability, is_container='container', yang_name="user-context-transfer-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)


  def _get_feature_dependency(self):
    """
    Getter method for feature_dependency, mapped from YANG variable /app_descriptor/feature_dependency (container)

    YANG Description: Incorporates the Feature Dependency into the MEC application descriptor.
    """
    return self.__feature_dependency
      
  def _set_feature_dependency(self, v, load=False):
    """
    Setter method for feature_dependency, mapped from YANG variable /app_descriptor/feature_dependency (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature_dependency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature_dependency() directly.

    YANG Description: Incorporates the Feature Dependency into the MEC application descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_feature_dependency_mec_app_descriptor__app_descriptor_feature_dependency, is_container='container', yang_name="feature-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """feature_dependency must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_feature_dependency_mec_app_descriptor__app_descriptor_feature_dependency, is_container='container', yang_name="feature-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__feature_dependency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_feature_dependency(self):
    self.__feature_dependency = YANGDynClass(base=yc_feature_dependency_mec_app_descriptor__app_descriptor_feature_dependency, is_container='container', yang_name="feature-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  name = __builtin__.property(_get_name, _set_name)
  provider = __builtin__.property(_get_provider, _set_provider)
  soft_version = __builtin__.property(_get_soft_version, _set_soft_version)
  version = __builtin__.property(_get_version, _set_version)
  mec_version = __builtin__.property(_get_mec_version, _set_mec_version)
  info_name = __builtin__.property(_get_info_name, _set_info_name)
  description = __builtin__.property(_get_description, _set_description)
  network_policy = __builtin__.property(_get_network_policy, _set_network_policy)
  sw_image = __builtin__.property(_get_sw_image, _set_sw_image)
  dns_rule = __builtin__.property(_get_dns_rule, _set_dns_rule)
  latency = __builtin__.property(_get_latency, _set_latency)
  virtual_storage = __builtin__.property(_get_virtual_storage, _set_virtual_storage)
  user_context_transfer_capability = __builtin__.property(_get_user_context_transfer_capability, _set_user_context_transfer_capability)
  feature_dependency = __builtin__.property(_get_feature_dependency, _set_feature_dependency)


  _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('provider', provider), ('soft_version', soft_version), ('version', version), ('mec_version', mec_version), ('info_name', info_name), ('description', description), ('network_policy', network_policy), ('sw_image', sw_image), ('dns_rule', dns_rule), ('latency', latency), ('virtual_storage', virtual_storage), ('user_context_transfer_capability', user_context_transfer_capability), ('feature_dependency', feature_dependency), ])


class mec_app_descriptor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mec-app-descriptor - based on the path /mec-app-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: YANG module for MEC Application Descriptors based on ETSI GS MEC 010-2 V2.2.1.
  """
  __slots__ = ('_path_helper', '_extmethods', '__app_descriptor',)

  _yang_name = 'mec-app-descriptor'
  _yang_namespace = 'http://example.com/ns/mec-app-descriptor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__app_descriptor = YANGDynClass(base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_app_descriptor(self):
    """
    Getter method for app_descriptor, mapped from YANG variable /app_descriptor (container)
    """
    return self.__app_descriptor
      
  def _set_app_descriptor(self, v, load=False):
    """
    Setter method for app_descriptor, mapped from YANG variable /app_descriptor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_app_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_app_descriptor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """app_descriptor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)""",
        })

    self.__app_descriptor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_app_descriptor(self):
    self.__app_descriptor = YANGDynClass(base=yc_app_descriptor_mec_app_descriptor__app_descriptor, is_container='container', yang_name="app-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/ns/mec-app-descriptor', defining_module='mec-app-descriptor', yang_type='container', is_config=True)

  app_descriptor = __builtin__.property(_get_app_descriptor, _set_app_descriptor)


  _pyangbind_elements = OrderedDict([('app_descriptor', app_descriptor), ])


